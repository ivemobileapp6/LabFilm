/*!
 * Quasar Framework v2.11.9
 * (c) 2015-present Razvan Stoenescu
 * Released under the MIT License.
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('vue')) :
  typeof define === 'function' && define.amd ? define(['vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Quasar = factory(global.Vue));
})(this, (function (vue) { 'use strict';

  function injectProp (target, propName, get, set) {
    Object.defineProperty(target, propName, {
      get,
      set,
      enumerable: true
    });
    return target
  }

  function injectMultipleProps (target, props) {
    for (const key in props) {
      injectProp(target, key, props[ key ]);
    }
    return target
  }

  /* eslint-disable no-useless-escape */

  /**
   * __ QUASAR_SSR __            -> runs on SSR on client or server
   * __ QUASAR_SSR_SERVER __     -> runs on SSR on server
   * __ QUASAR_SSR_CLIENT __     -> runs on SSR on client
   * __ QUASAR_SSR_PWA __        -> built with SSR+PWA; may run on SSR on client or on PWA client
   *                              (needs runtime detection)
   */

  const isRuntimeSsrPreHydration = vue.ref(
      false 
    );
  let iosCorrection;

  function getMatch (userAgent, platformMatch) {
    const match = /(edg|edge|edga|edgios)\/([\w.]+)/.exec(userAgent)
      || /(opr)[\/]([\w.]+)/.exec(userAgent)
      || /(vivaldi)[\/]([\w.]+)/.exec(userAgent)
      || /(chrome|crios)[\/]([\w.]+)/.exec(userAgent)
      || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent)
      || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent)
      || /(firefox|fxios)[\/]([\w.]+)/.exec(userAgent)
      || /(webkit)[\/]([\w.]+)/.exec(userAgent)
      || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(userAgent)
      || [];

    return {
      browser: match[ 5 ] || match[ 3 ] || match[ 1 ] || '',
      version: match[ 2 ] || match[ 4 ] || '0',
      versionNumber: match[ 4 ] || match[ 2 ] || '0',
      platform: platformMatch[ 0 ] || ''
    }
  }

  function getPlatformMatch (userAgent) {
    return /(ipad)/.exec(userAgent)
      || /(ipod)/.exec(userAgent)
      || /(windows phone)/.exec(userAgent)
      || /(iphone)/.exec(userAgent)
      || /(kindle)/.exec(userAgent)
      || /(silk)/.exec(userAgent)
      || /(android)/.exec(userAgent)
      || /(win)/.exec(userAgent)
      || /(mac)/.exec(userAgent)
      || /(linux)/.exec(userAgent)
      || /(cros)/.exec(userAgent)
      // TODO: Remove BlackBerry detection. BlackBerry OS, BlackBerry 10, and BlackBerry PlayBook OS
      // is officially dead as of January 4, 2022 (https://www.blackberry.com/us/en/support/devices/end-of-life)
      || /(playbook)/.exec(userAgent)
      || /(bb)/.exec(userAgent)
      || /(blackberry)/.exec(userAgent)
      || []
  }

  const hasTouch = 'ontouchstart' in window || window.navigator.maxTouchPoints > 0;

  function applyIosCorrection (is) {
    iosCorrection = { is: { ...is } };

    delete is.mac;
    delete is.desktop;

    const platform = Math.min(window.innerHeight, window.innerWidth) > 414
      ? 'ipad'
      : 'iphone';

    Object.assign(is, {
      mobile: true,
      ios: true,
      platform,
      [ platform ]: true
    });
  }

  function getPlatform (UA) {
    const
      userAgent = UA.toLowerCase(),
      platformMatch = getPlatformMatch(userAgent),
      matched = getMatch(userAgent, platformMatch),
      browser = {};

    if (matched.browser) {
      browser[ matched.browser ] = true;
      browser.version = matched.version;
      browser.versionNumber = parseInt(matched.versionNumber, 10);
    }

    if (matched.platform) {
      browser[ matched.platform ] = true;
    }

    const knownMobiles = browser.android
      || browser.ios
      || browser.bb
      || browser.blackberry
      || browser.ipad
      || browser.iphone
      || browser.ipod
      || browser.kindle
      || browser.playbook
      || browser.silk
      || browser[ 'windows phone' ];

    // These are all considered mobile platforms, meaning they run a mobile browser
    if (knownMobiles === true || userAgent.indexOf('mobile') > -1) {
      browser.mobile = true;

      if (browser.edga || browser.edgios) {
        browser.edge = true;
        matched.browser = 'edge';
      }
      else if (browser.crios) {
        browser.chrome = true;
        matched.browser = 'chrome';
      }
      else if (browser.fxios) {
        browser.firefox = true;
        matched.browser = 'firefox';
      }
    }
    // If it's not mobile we should consider it's desktop platform, meaning it runs a desktop browser
    // It's a workaround for anonymized user agents
    // (browser.cros || browser.mac || browser.linux || browser.win)
    else {
      browser.desktop = true;
    }

    // Set iOS if on iPod, iPad or iPhone
    if (browser.ipod || browser.ipad || browser.iphone) {
      browser.ios = true;
    }

    if (browser[ 'windows phone' ]) {
      browser.winphone = true;
      delete browser[ 'windows phone' ];
    }

    // TODO: The assumption about WebKit based browsers below is not completely accurate.
    // Google released Blink(a fork of WebKit) engine on April 3, 2013, which is really different than WebKit today.
    // Today, one might want to check for WebKit to deal with its bugs, which is used on all browsers on iOS, and Safari browser on all platforms.

    // Chrome, Opera 15+, Vivaldi and Safari are webkit based browsers
    if (
      browser.chrome
      || browser.opr
      || browser.safari
      || browser.vivaldi
      // we expect unknown, non iOS mobile browsers to be webkit based
      || (
        browser.mobile === true
        && browser.ios !== true
        && knownMobiles !== true
      )
    ) {
      browser.webkit = true;
    }

    // TODO: (Qv3) rename the terms 'edge' to 'edge legacy'(or remove it) then 'edge chromium' to 'edge' to match with the known up-to-date terms
    // Microsoft Edge is the new Chromium-based browser. Microsoft Edge Legacy is the old EdgeHTML-based browser (EOL: March 9, 2021).
    if (browser.edg) {
      matched.browser = 'edgechromium';
      browser.edgeChromium = true;
    }

    // Blackberry browsers are marked as Safari on BlackBerry
    if ((browser.safari && browser.blackberry) || browser.bb) {
      matched.browser = 'blackberry';
      browser.blackberry = true;
    }

    // Playbook browsers are marked as Safari on Playbook
    if (browser.safari && browser.playbook) {
      matched.browser = 'playbook';
      browser.playbook = true;
    }

    // Opera 15+ are identified as opr
    if (browser.opr) {
      matched.browser = 'opera';
      browser.opera = true;
    }

    // Stock Android browsers are marked as Safari on Android.
    if (browser.safari && browser.android) {
      matched.browser = 'android';
      browser.android = true;
    }

    // Kindle browsers are marked as Safari on Kindle
    if (browser.safari && browser.kindle) {
      matched.browser = 'kindle';
      browser.kindle = true;
    }

    // Kindle Silk browsers are marked as Safari on Kindle
    if (browser.safari && browser.silk) {
      matched.browser = 'silk';
      browser.silk = true;
    }

    if (browser.vivaldi) {
      matched.browser = 'vivaldi';
      browser.vivaldi = true;
    }

    // Assign the name and platform variable
    browser.name = matched.browser;
    browser.platform = matched.platform;

    {
      if (userAgent.indexOf('electron') > -1) {
        browser.electron = true;
      }
      else if (document.location.href.indexOf('-extension://') > -1) {
        browser.bex = true;
      }
      else {
        if (window.Capacitor !== void 0) {
          browser.capacitor = true;
          browser.nativeMobile = true;
          browser.nativeMobileWrapper = 'capacitor';
        }
        else if (window._cordovaNative !== void 0 || window.cordova !== void 0) {
          browser.cordova = true;
          browser.nativeMobile = true;
          browser.nativeMobileWrapper = 'cordova';
        }

        if (
          hasTouch === true
          && browser.mac === true
          && (
            (browser.desktop === true && browser.safari === true)
            || (
              browser.nativeMobile === true
              && browser.android !== true
              && browser.ios !== true
              && browser.ipad !== true
            )
          )
        ) {
          /*
          * Correction needed for iOS since the default
          * setting on iPad is to request desktop view; if we have
          * touch support and the user agent says it's a
          * desktop, we infer that it's an iPhone/iPad with desktop view
          * so we must fix the false positives
          */
          applyIosCorrection(browser);
        }
      }
    }

    return browser
  }

  const userAgent = navigator.userAgent || navigator.vendor || window.opera;

  const ssrClient = {
    has: {
      touch: false,
      webStorage: false
    },
    within: { iframe: false }
  };

  // We export "client" for hydration error-free parts,
  // like touch directives who do not (and must NOT) wait
  // for the client takeover;
  // Do NOT import this directly in your app, unless you really know
  // what you are doing.
  const client = {
        userAgent,
        is: getPlatform(userAgent),
        has: {
          touch: hasTouch
        },
        within: {
          iframe: window.self !== window.top
        }
      };

  const Platform = {
    install (opts) {
      const { $q } = opts;

      if (isRuntimeSsrPreHydration.value === true) {
        // takeover should increase accuracy for
        // the rest of the props; we also avoid
        // hydration errors
        opts.onSSRHydrated.push(() => {
          Object.assign($q.platform, client);
          isRuntimeSsrPreHydration.value = false;
          iosCorrection = void 0;
        });

        // we need to make platform reactive
        // for the takeover phase
        $q.platform = vue.reactive(this);
      }
      else {
        $q.platform = this;
      }
    }
  };

  {
    // do not access window.localStorage without
    // devland actually using it as this will get
    // reported under "Cookies" in Google Chrome
    let hasWebStorage;

    injectProp(client.has, 'webStorage', () => {
      if (hasWebStorage !== void 0) {
        return hasWebStorage
      }

      try {
        if (window.localStorage) {
          hasWebStorage = true;
          return true
        }
      }
      catch (e) {}

      hasWebStorage = false;
      return false
    });

    client.is.ios === true
      && window.navigator.vendor.toLowerCase().indexOf('apple') === -1;

    if (isRuntimeSsrPreHydration.value === true) {
      // must match with server-side before
      // client taking over in order to prevent
      // hydration errors
      Object.assign(Platform, client, iosCorrection, ssrClient);
    }
    else {
      Object.assign(Platform, client);
    }
  }

  var defineReactivePlugin = (state, plugin) => {
        const reactiveState = vue.reactive(state);

        for (const name in state) {
          injectProp(
            plugin,
            name,
            () => reactiveState[ name ],
            val => { reactiveState[ name ] = val; }
          );
        }

        return plugin
      };

  const listenOpts = {
    hasPassive: false,
    passiveCapture: true,
    notPassiveCapture: true
  };

  try {
    const opts = Object.defineProperty({}, 'passive', {
      get () {
        Object.assign(listenOpts, {
          hasPassive: true,
          passive: { passive: true },
          notPassive: { passive: false },
          passiveCapture: { passive: true, capture: true },
          notPassiveCapture: { passive: false, capture: true }
        });
      }
    });
    window.addEventListener('qtest', null, opts);
    window.removeEventListener('qtest', null, opts);
  }
  catch (e) {}

  function noop () {}

  function leftClick (e) {
    return e.button === 0
  }

  function middleClick (e) {
    return e.button === 1
  }

  function rightClick (e) {
    return e.button === 2
  }

  function position (e) {
    if (e.touches && e.touches[ 0 ]) {
      e = e.touches[ 0 ];
    }
    else if (e.changedTouches && e.changedTouches[ 0 ]) {
      e = e.changedTouches[ 0 ];
    }
    else if (e.targetTouches && e.targetTouches[ 0 ]) {
      e = e.targetTouches[ 0 ];
    }

    return {
      top: e.clientY,
      left: e.clientX
    }
  }

  function getEventPath (e) {
    if (e.path) {
      return e.path
    }
    if (e.composedPath) {
      return e.composedPath()
    }

    const path = [];
    let el = e.target;

    while (el) {
      path.push(el);

      if (el.tagName === 'HTML') {
        path.push(document);
        path.push(window);
        return path
      }

      el = el.parentElement;
    }
  }

  // Reasonable defaults
  const
    LINE_HEIGHT = 40,
    PAGE_HEIGHT = 800;

  function getMouseWheelDistance (e) {
    let x = e.deltaX, y = e.deltaY;

    if ((x || y) && e.deltaMode) {
      const multiplier = e.deltaMode === 1 ? LINE_HEIGHT : PAGE_HEIGHT;
      x *= multiplier;
      y *= multiplier;
    }

    if (e.shiftKey && !x) {
      [ y, x ] = [ x, y ];
    }

    return { x, y }
  }

  function stop (e) {
    e.stopPropagation();
  }

  function prevent (e) {
    e.cancelable !== false && e.preventDefault();
  }

  function stopAndPrevent (e) {
    e.cancelable !== false && e.preventDefault();
    e.stopPropagation();
  }

  function preventDraggable (el, status) {
    if (el === void 0 || (status === true && el.__dragPrevented === true)) {
      return
    }

    const fn = status === true
      ? el => {
        el.__dragPrevented = true;
        el.addEventListener('dragstart', prevent, listenOpts.notPassiveCapture);
      }
      : el => {
        delete el.__dragPrevented;
        el.removeEventListener('dragstart', prevent, listenOpts.notPassiveCapture);
      };

    el.querySelectorAll('a, img').forEach(fn);
  }

  function addEvt (ctx, targetName, events) {
    const name = `__q_${ targetName }_evt`;

    ctx[ name ] = ctx[ name ] !== void 0
      ? ctx[ name ].concat(events)
      : events;

    events.forEach(evt => {
      evt[ 0 ].addEventListener(evt[ 1 ], ctx[ evt[ 2 ] ], listenOpts[ evt[ 3 ] ]);
    });
  }

  function cleanEvt (ctx, targetName) {
    const name = `__q_${ targetName }_evt`;

    if (ctx[ name ] !== void 0) {
      ctx[ name ].forEach(evt => {
        evt[ 0 ].removeEventListener(evt[ 1 ], ctx[ evt[ 2 ] ], listenOpts[ evt[ 3 ] ]);
      });
      ctx[ name ] = void 0;
    }
  }

  /*
   * also update /types/utils/event.d.ts
   */

  var event = {
    listenOpts,
    leftClick,
    middleClick,
    rightClick,
    position,
    getEventPath,
    getMouseWheelDistance,
    stop,
    prevent,
    stopAndPrevent,
    preventDraggable
  };

  function debounce (fn, wait = 250, immediate) {
    let timer = null;

    function debounced (/* ...args */) {
      const args = arguments;

      const later = () => {
        timer = null;
        if (immediate !== true) {
          fn.apply(this, args);
        }
      };

      if (timer !== null) {
        clearTimeout(timer);
      }
      else if (immediate === true) {
        fn.apply(this, args);
      }

      timer = setTimeout(later, wait);
    }

    debounced.cancel = () => {
      timer !== null && clearTimeout(timer);
    };

    return debounced
  }

  const SIZE_LIST = [ 'sm', 'md', 'lg', 'xl' ];
  const { passive: passive$4 } = listenOpts;

  var Screen = defineReactivePlugin({
    width: 0,
    height: 0,
    name: 'xs',

    sizes: {
      sm: 600,
      md: 1024,
      lg: 1440,
      xl: 1920
    },

    lt: {
      sm: true,
      md: true,
      lg: true,
      xl: true
    },
    gt: {
      xs: false,
      sm: false,
      md: false,
      lg: false
    },

    xs: true,
    sm: false,
    md: false,
    lg: false,
    xl: false
  }, {
    setSizes: noop,
    setDebounce: noop,

    install ({ $q, onSSRHydrated }) {
      $q.screen = this;

      if (this.__installed === true) {
        if ($q.config.screen !== void 0) {
          if ($q.config.screen.bodyClasses === false) {
            document.body.classList.remove(`screen--${ this.name }`);
          }
          else {
            this.__update(true);
          }
        }
        return
      }

      const { visualViewport } = window;
      const target = visualViewport || window;
      const scrollingElement = document.scrollingElement || document.documentElement;
      const getSize = visualViewport === void 0 || client.is.mobile === true
        ? () => [
            Math.max(window.innerWidth, scrollingElement.clientWidth),
            Math.max(window.innerHeight, scrollingElement.clientHeight)
          ]
        : () => [
            visualViewport.width * visualViewport.scale + window.innerWidth - scrollingElement.clientWidth,
            visualViewport.height * visualViewport.scale + window.innerHeight - scrollingElement.clientHeight
          ];

      const classes = $q.config.screen !== void 0 && $q.config.screen.bodyClasses === true;

      this.__update = force => {
        const [ w, h ] = getSize();

        if (h !== this.height) {
          this.height = h;
        }

        if (w !== this.width) {
          this.width = w;
        }
        else if (force !== true) {
          return
        }

        let s = this.sizes;

        this.gt.xs = w >= s.sm;
        this.gt.sm = w >= s.md;
        this.gt.md = w >= s.lg;
        this.gt.lg = w >= s.xl;
        this.lt.sm = w < s.sm;
        this.lt.md = w < s.md;
        this.lt.lg = w < s.lg;
        this.lt.xl = w < s.xl;
        this.xs = this.lt.sm;
        this.sm = this.gt.xs === true && this.lt.md === true;
        this.md = this.gt.sm === true && this.lt.lg === true;
        this.lg = this.gt.md === true && this.lt.xl === true;
        this.xl = this.gt.lg;

        s = (this.xs === true && 'xs')
          || (this.sm === true && 'sm')
          || (this.md === true && 'md')
          || (this.lg === true && 'lg')
          || 'xl';

        if (s !== this.name) {
          if (classes === true) {
            document.body.classList.remove(`screen--${ this.name }`);
            document.body.classList.add(`screen--${ s }`);
          }
          this.name = s;
        }
      };

      let updateEvt, updateSizes = {}, updateDebounce = 16;

      this.setSizes = sizes => {
        SIZE_LIST.forEach(name => {
          if (sizes[ name ] !== void 0) {
            updateSizes[ name ] = sizes[ name ];
          }
        });
      };
      this.setDebounce = deb => {
        updateDebounce = deb;
      };

      const start = () => {
        const style = getComputedStyle(document.body);

        // if css props available
        if (style.getPropertyValue('--q-size-sm')) {
          SIZE_LIST.forEach(name => {
            this.sizes[ name ] = parseInt(style.getPropertyValue(`--q-size-${ name }`), 10);
          });
        }

        this.setSizes = sizes => {
          SIZE_LIST.forEach(name => {
            if (sizes[ name ]) {
              this.sizes[ name ] = sizes[ name ];
            }
          });
          this.__update(true);
        };

        this.setDebounce = delay => {
          updateEvt !== void 0 && target.removeEventListener('resize', updateEvt, passive$4);
          updateEvt = delay > 0
            ? debounce(this.__update, delay)
            : this.__update;
          target.addEventListener('resize', updateEvt, passive$4);
        };

        this.setDebounce(updateDebounce);

        if (Object.keys(updateSizes).length > 0) {
          this.setSizes(updateSizes);
          updateSizes = void 0; // free up memory
        }
        else {
          this.__update();
        }

        // due to optimizations, this would be left out otherwise
        classes === true && this.name === 'xs'
          && document.body.classList.add('screen--xs');
      };

      if (isRuntimeSsrPreHydration.value === true) {
        onSSRHydrated.push(start);
      }
      else {
        start();
      }
    }
  });

  const Plugin$9 = defineReactivePlugin({
    isActive: false,
    mode: false
  }, {
    __media: void 0,

    set (val) {

      Plugin$9.mode = val;

      if (val === 'auto') {
        if (Plugin$9.__media === void 0) {
          Plugin$9.__media = window.matchMedia('(prefers-color-scheme: dark)');
          Plugin$9.__updateMedia = () => { Plugin$9.set('auto'); };
          Plugin$9.__media.addListener(Plugin$9.__updateMedia);
        }

        val = Plugin$9.__media.matches;
      }
      else if (Plugin$9.__media !== void 0) {
        Plugin$9.__media.removeListener(Plugin$9.__updateMedia);
        Plugin$9.__media = void 0;
      }

      Plugin$9.isActive = val === true;

      document.body.classList.remove(`body--${ val === true ? 'light' : 'dark' }`);
      document.body.classList.add(`body--${ val === true ? 'dark' : 'light' }`);
    },

    toggle () {
      {
        Plugin$9.set(Plugin$9.isActive === false);
      }
    },

    install ({ $q, onSSRHydrated, ssrContext }) {
      const { dark } = $q.config;

      $q.dark = this;

      if (this.__installed === true && dark === void 0) {
        return
      }

      this.isActive = dark === true;

      const initialVal = dark !== void 0 ? dark : false;

      if (isRuntimeSsrPreHydration.value === true) {
        const ssrSet = val => {
          this.__fromSSR = val;
        };

        const originalSet = this.set;

        this.set = ssrSet;
        ssrSet(initialVal);

        onSSRHydrated.push(() => {
          this.set = originalSet;
          this.set(this.__fromSSR);
        });
      }
      else {
        this.set(initialVal);
      }
    }
  });

  const getTrue = () => true;

  function filterInvalidPath (path) {
    return typeof path === 'string'
      && path !== ''
      && path !== '/'
      && path !== '#/'
  }

  function normalizeExitPath (path) {
    path.startsWith('#') === true && (path = path.substring(1));
    path.startsWith('/') === false && (path = '/' + path);
    path.endsWith('/') === true && (path = path.substring(0, path.length - 1));
    return '#' + path
  }

  function getShouldExitFn (cfg) {
    if (cfg.backButtonExit === false) {
      return () => false
    }

    if (cfg.backButtonExit === '*') {
      return getTrue
    }

    // Add default root path
    const exitPaths = [ '#/' ];

    // Add custom exit paths
    Array.isArray(cfg.backButtonExit) === true && exitPaths.push(
      ...cfg.backButtonExit.filter(filterInvalidPath).map(normalizeExitPath)
    );

    return () => exitPaths.includes(window.location.hash)
  }

  var History = {
    __history: [],
    add: noop,
    remove: noop,

    install ({ $q }) {
      if (this.__installed === true) { return }

      const { cordova, capacitor } = client.is;

      if (cordova !== true && capacitor !== true) {
        return
      }

      const qConf = $q.config[ cordova === true ? 'cordova' : 'capacitor' ];

      if (qConf !== void 0 && qConf.backButton === false) {
        return
      }

      // if the '@capacitor/app' plugin is not installed
      // then we got nothing to do
      if (
        // if we're on Capacitor mode
        capacitor === true
        // and it's also not in Capacitor's main instance
        && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0)
      ) {
        return
      }

      this.add = entry => {
        if (entry.condition === void 0) {
          entry.condition = getTrue;
        }
        this.__history.push(entry);
      };

      this.remove = entry => {
        const index = this.__history.indexOf(entry);
        if (index >= 0) {
          this.__history.splice(index, 1);
        }
      };

      const shouldExit = getShouldExitFn(
        Object.assign(
          { backButtonExit: true },
          qConf
        )
      );

      const backHandler = () => {
        if (this.__history.length) {
          const entry = this.__history[ this.__history.length - 1 ];

          if (entry.condition() === true) {
            this.__history.pop();
            entry.handler();
          }
        }
        else if (shouldExit() === true) {
          navigator.app.exitApp();
        }
        else {
          window.history.back();
        }
      };

      if (cordova === true) {
        document.addEventListener('deviceready', () => {
          document.addEventListener('backbutton', backHandler, false);
        });
      }
      else {
        window.Capacitor.Plugins.App.addListener('backButton', backHandler);
      }
    }
  };

  var defaultLang = {
    isoName: 'en-US',
    nativeName: 'English (US)',
    label: {
      clear: 'Clear',
      ok: 'OK',
      cancel: 'Cancel',
      close: 'Close',
      set: 'Set',
      select: 'Select',
      reset: 'Reset',
      remove: 'Remove',
      update: 'Update',
      create: 'Create',
      search: 'Search',
      filter: 'Filter',
      refresh: 'Refresh',
      expand: label => (label ? `Expand "${ label }"` : 'Expand'),
      collapse: label => (label ? `Collapse "${ label }"` : 'Collapse')
    },
    date: {
      days: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
      daysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      firstDayOfWeek: 0, // 0-6, 0 - Sunday, 1 Monday, ...
      format24h: false,
      pluralDay: 'days'
    },
    table: {
      noData: 'No data available',
      noResults: 'No matching records found',
      loading: 'Loading...',
      selectedRecords: rows => (
        rows === 1
          ? '1 record selected.'
          : (rows === 0 ? 'No' : rows) + ' records selected.'
      ),
      recordsPerPage: 'Records per page:',
      allRows: 'All',
      pagination: (start, end, total) => start + '-' + end + ' of ' + total,
      columns: 'Columns'
    },
    editor: {
      url: 'URL',
      bold: 'Bold',
      italic: 'Italic',
      strikethrough: 'Strikethrough',
      underline: 'Underline',
      unorderedList: 'Unordered List',
      orderedList: 'Ordered List',
      subscript: 'Subscript',
      superscript: 'Superscript',
      hyperlink: 'Hyperlink',
      toggleFullscreen: 'Toggle Fullscreen',
      quote: 'Quote',
      left: 'Left align',
      center: 'Center align',
      right: 'Right align',
      justify: 'Justify align',
      print: 'Print',
      outdent: 'Decrease indentation',
      indent: 'Increase indentation',
      removeFormat: 'Remove formatting',
      formatting: 'Formatting',
      fontSize: 'Font Size',
      align: 'Align',
      hr: 'Insert Horizontal Rule',
      undo: 'Undo',
      redo: 'Redo',
      heading1: 'Heading 1',
      heading2: 'Heading 2',
      heading3: 'Heading 3',
      heading4: 'Heading 4',
      heading5: 'Heading 5',
      heading6: 'Heading 6',
      paragraph: 'Paragraph',
      code: 'Code',
      size1: 'Very small',
      size2: 'A bit small',
      size3: 'Normal',
      size4: 'Medium-large',
      size5: 'Big',
      size6: 'Very big',
      size7: 'Maximum',
      defaultFont: 'Default Font',
      viewSource: 'View Source'
    },
    tree: {
      noNodes: 'No nodes available',
      noResults: 'No matching nodes found'
    }
  };

  function getLocale () {

    const val = Array.isArray(navigator.languages) === true && navigator.languages.length > 0
      ? navigator.languages[ 0 ]
      : navigator.language;

    if (typeof val === 'string') {
      return val.split(/[-_]/).map((v, i) => (
        i === 0
          ? v.toLowerCase()
          : (
              i > 1 || v.length < 4
                ? v.toUpperCase()
                : (v[ 0 ].toUpperCase() + v.slice(1).toLowerCase())
            )
      )).join('-')
    }
  }

  const Plugin$8 = defineReactivePlugin({
    __langPack: {}
  }, {
    getLocale,

    set (langObject = defaultLang, ssrContext) {
      const lang = {
        ...langObject,
        rtl: langObject.rtl === true,
        getLocale
      };

      {
        lang.set = Plugin$8.set;

        if (Plugin$8.__langConfig === void 0 || Plugin$8.__langConfig.noHtmlAttrs !== true) {
          const el = document.documentElement;
          el.setAttribute('dir', lang.rtl === true ? 'rtl' : 'ltr');
          el.setAttribute('lang', lang.isoName);
        }

        Object.assign(Plugin$8.__langPack, lang);

        Plugin$8.props = lang;
        Plugin$8.isoName = lang.isoName;
        Plugin$8.nativeName = lang.nativeName;
      }
    },

    install ({ $q, lang, ssrContext }) {
      {
        $q.lang = Plugin$8.__langPack;
        Plugin$8.__langConfig = $q.config.lang;

        if (this.__installed === true) {
          lang !== void 0 && this.set(lang);
        }
        else {
          this.set(lang || defaultLang);
        }
      }
    }
  });

  function setCssVar (propName, value, element = document.body) {
    if (typeof propName !== 'string') {
      throw new TypeError('Expected a string as propName')
    }
    if (typeof value !== 'string') {
      throw new TypeError('Expected a string as value')
    }
    if (!(element instanceof Element)) {
      throw new TypeError('Expected a DOM element')
    }

    element.style.setProperty(`--q-${ propName }`, value);
  }

  let lastKeyCompositionStatus = false;

  function onKeyDownComposition (evt) {
    lastKeyCompositionStatus = evt.isComposing === true;
  }

  function shouldIgnoreKey (evt) {
    return lastKeyCompositionStatus === true
      || evt !== Object(evt)
      || evt.isComposing === true
      || evt.qKeyEvent === true
  }

  function isKeyCode (evt, keyCodes) {
    return shouldIgnoreKey(evt) === true
      ? false
      : [].concat(keyCodes).includes(evt.keyCode)
  }

  function getMobilePlatform (is) {
    if (is.ios === true) return 'ios'
    if (is.android === true) return 'android'
  }

  function getBodyClasses ({ is, has, within }, cfg) {
    const cls = [
      is.desktop === true ? 'desktop' : 'mobile',
      `${ has.touch === false ? 'no-' : '' }touch`
    ];

    if (is.mobile === true) {
      const mobile = getMobilePlatform(is);
      mobile !== void 0 && cls.push('platform-' + mobile);
    }

    if (is.nativeMobile === true) {
      const type = is.nativeMobileWrapper;

      cls.push(type);
      cls.push('native-mobile');

      if (
        is.ios === true
        && (cfg[ type ] === void 0 || cfg[ type ].iosStatusBarPadding !== false)
      ) {
        cls.push('q-ios-padding');
      }
    }
    else if (is.electron === true) {
      cls.push('electron');
    }
    else if (is.bex === true) {
      cls.push('bex');
    }

    within.iframe === true && cls.push('within-iframe');

    return cls
  }

  function applyClientSsrCorrections () {
    const { is } = client;
    const classes = document.body.className;

    const classList = new Set(classes.replace(/ {2}/g, ' ').split(' '));

    if (iosCorrection !== void 0) {
      classList.delete('desktop');
      classList.add('platform-ios');
      classList.add('mobile');
    }
    // else: is it SSG?
    else if (is.nativeMobile !== true && is.electron !== true && is.bex !== true) {
      if (is.desktop === true) {
        classList.delete('mobile');
        classList.delete('platform-ios');
        classList.delete('platform-android');
        classList.add('desktop');
      }
      else if (is.mobile === true) {
        classList.delete('desktop');
        classList.add('mobile');

        const mobile = getMobilePlatform(is);
        if (mobile !== void 0) {
          classList.add(`platform-${ mobile }`);
          classList.delete(`platform-${ mobile === 'ios' ? 'android' : 'ios' }`);
        }
        else {
          classList.delete('platform-ios');
          classList.delete('platform-android');
        }
      }
    }

    if (client.has.touch === true) {
      classList.delete('no-touch');
      classList.add('touch');
    }

    if (client.within.iframe === true) {
      classList.add('within-iframe');
    }

    const newCls = Array.from(classList).join(' ');

    if (classes !== newCls) {
      document.body.className = newCls;
    }
  }

  function setColors (brand) {
    for (const color in brand) {
      setCssVar(color, brand[ color ]);
    }
  }

  var Body = {
    install (opts) {

      if (this.__installed === true) { return }

      if (isRuntimeSsrPreHydration.value === true) {
        applyClientSsrCorrections();
      }
      else {
        const { $q } = opts;

        $q.config.brand !== void 0 && setColors($q.config.brand);

        const cls = getBodyClasses(client, $q.config);
        document.body.classList.add.apply(document.body.classList, cls);
      }

      if (client.is.ios === true) {
        // needed for iOS button active state
        document.body.addEventListener('touchstart', noop);
      }

      window.addEventListener('keydown', onKeyDownComposition, true);
    }
  };

  var materialIcons = {
    name: 'material-icons',
    type: {
      positive: 'check_circle',
      negative: 'warning',
      info: 'info',
      warning: 'priority_high'
    },
    arrow: {
      up: 'arrow_upward',
      right: 'arrow_forward',
      down: 'arrow_downward',
      left: 'arrow_back',
      dropdown: 'arrow_drop_down'
    },
    chevron: {
      left: 'chevron_left',
      right: 'chevron_right'
    },
    colorPicker: {
      spectrum: 'gradient',
      tune: 'tune',
      palette: 'style'
    },
    pullToRefresh: {
      icon: 'refresh'
    },
    carousel: {
      left: 'chevron_left',
      right: 'chevron_right',
      up: 'keyboard_arrow_up',
      down: 'keyboard_arrow_down',
      navigationIcon: 'lens'
    },
    chip: {
      remove: 'cancel',
      selected: 'check'
    },
    datetime: {
      arrowLeft: 'chevron_left',
      arrowRight: 'chevron_right',
      now: 'access_time',
      today: 'today'
    },
    editor: {
      bold: 'format_bold',
      italic: 'format_italic',
      strikethrough: 'strikethrough_s',
      underline: 'format_underlined',
      unorderedList: 'format_list_bulleted',
      orderedList: 'format_list_numbered',
      subscript: 'vertical_align_bottom',
      superscript: 'vertical_align_top',
      hyperlink: 'link',
      toggleFullscreen: 'fullscreen',
      quote: 'format_quote',
      left: 'format_align_left',
      center: 'format_align_center',
      right: 'format_align_right',
      justify: 'format_align_justify',
      print: 'print',
      outdent: 'format_indent_decrease',
      indent: 'format_indent_increase',
      removeFormat: 'format_clear',
      formatting: 'text_format',
      fontSize: 'format_size',
      align: 'format_align_left',
      hr: 'remove',
      undo: 'undo',
      redo: 'redo',
      heading: 'format_size',
      code: 'code',
      size: 'format_size',
      font: 'font_download',
      viewSource: 'code'
    },
    expansionItem: {
      icon: 'keyboard_arrow_down',
      denseIcon: 'arrow_drop_down'
    },
    fab: {
      icon: 'add',
      activeIcon: 'close'
    },
    field: {
      clear: 'cancel',
      error: 'error'
    },
    pagination: {
      first: 'first_page',
      prev: 'keyboard_arrow_left',
      next: 'keyboard_arrow_right',
      last: 'last_page'
    },
    rating: {
      icon: 'grade'
    },
    stepper: {
      done: 'check',
      active: 'edit',
      error: 'warning'
    },
    tabs: {
      left: 'chevron_left',
      right: 'chevron_right',
      up: 'keyboard_arrow_up',
      down: 'keyboard_arrow_down'
    },
    table: {
      arrowUp: 'arrow_upward',
      warning: 'warning',
      firstPage: 'first_page',
      prevPage: 'chevron_left',
      nextPage: 'chevron_right',
      lastPage: 'last_page'
    },
    tree: {
      icon: 'play_arrow'
    },
    uploader: {
      done: 'done',
      clear: 'clear',
      add: 'add_box',
      upload: 'cloud_upload',
      removeQueue: 'clear_all',
      removeUploaded: 'done_all'
    }
  };

  const Plugin$7 = defineReactivePlugin({
    iconMapFn: null,
    __icons: {}
  }, {
    set (setObject, ssrContext) {
      const def = { ...setObject, rtl: setObject.rtl === true };

      {
        def.set = Plugin$7.set;
        Object.assign(Plugin$7.__icons, def);
      }
    },

    install ({ $q, iconSet, ssrContext }) {
      {
        if ($q.config.iconMapFn !== void 0) {
          this.iconMapFn = $q.config.iconMapFn;
        }

        $q.iconSet = this.__icons;

        injectProp($q, 'iconMapFn', () => this.iconMapFn, val => { this.iconMapFn = val; });

        if (this.__installed === true) {
          iconSet !== void 0 && this.set(iconSet);
        }
        else {
          this.set(iconSet || materialIcons);
        }
      }
    }
  });

  const quasarKey = '_q_';
  const timelineKey = '_q_t_';
  const stepperKey = '_q_s_';
  const layoutKey = '_q_l_';
  const pageContainerKey = '_q_pc_';
  const fabKey = '_q_f_';
  const formKey = '_q_fo_';
  const tabsKey = '_q_tabs_';
  const uploaderKey = '_q_u_';

  const emptyRenderFn = () => {};

  const globalConfig = {};
  let globalConfigIsFrozen = false;

  function freezeGlobalConfig () {
    globalConfigIsFrozen = true;
  }

  function isDeepEqual (a, b) {
    if (a === b) {
      return true
    }

    if (a !== null && b !== null && typeof a === 'object' && typeof b === 'object') {
      if (a.constructor !== b.constructor) {
        return false
      }

      let length, i;

      if (a.constructor === Array) {
        length = a.length;

        if (length !== b.length) {
          return false
        }

        for (i = length; i-- !== 0;) {
          if (isDeepEqual(a[ i ], b[ i ]) !== true) {
            return false
          }
        }

        return true
      }

      if (a.constructor === Map) {
        if (a.size !== b.size) {
          return false
        }

        let iter = a.entries();

        i = iter.next();
        while (i.done !== true) {
          if (b.has(i.value[ 0 ]) !== true) {
            return false
          }
          i = iter.next();
        }

        iter = a.entries();
        i = iter.next();
        while (i.done !== true) {
          if (isDeepEqual(i.value[ 1 ], b.get(i.value[ 0 ])) !== true) {
            return false
          }
          i = iter.next();
        }

        return true
      }

      if (a.constructor === Set) {
        if (a.size !== b.size) {
          return false
        }

        const iter = a.entries();

        i = iter.next();
        while (i.done !== true) {
          if (b.has(i.value[ 0 ]) !== true) {
            return false
          }
          i = iter.next();
        }

        return true
      }

      if (a.buffer != null && a.buffer.constructor === ArrayBuffer) {
        length = a.length;

        if (length !== b.length) {
          return false
        }

        for (i = length; i-- !== 0;) {
          if (a[ i ] !== b[ i ]) {
            return false
          }
        }

        return true
      }

      if (a.constructor === RegExp) {
        return a.source === b.source && a.flags === b.flags
      }

      if (a.valueOf !== Object.prototype.valueOf) {
        return a.valueOf() === b.valueOf()
      }

      if (a.toString !== Object.prototype.toString) {
        return a.toString() === b.toString()
      }

      const keys = Object.keys(a).filter(key => a[ key ] !== void 0);
      length = keys.length;

      if (length !== Object.keys(b).filter(key => b[ key ] !== void 0).length) {
        return false
      }

      for (i = length; i-- !== 0;) {
        const key = keys[ i ];
        if (isDeepEqual(a[ key ], b[ key ]) !== true) {
          return false
        }
      }

      return true
    }

    // true if both NaN, false otherwise
    return a !== a && b !== b // eslint-disable-line no-self-compare
  }

  // not perfect, but what we ARE interested is for Arrays not to slip in
  // as spread operator will mess things up in various areas
  function isObject (v) {
    return v !== null && typeof v === 'object' && Array.isArray(v) !== true
  }

  function isDate (v) {
    return Object.prototype.toString.call(v) === '[object Date]'
  }

  function isRegexp (v) {
    return Object.prototype.toString.call(v) === '[object RegExp]'
  }

  function isNumber (v) {
    return typeof v === 'number' && isFinite(v)
  }

  var is = {
    deepEqual: isDeepEqual,
    object: isObject,
    date: isDate,
    regexp: isRegexp,
    number: isNumber
  };

  const autoInstalledPlugins = [
    Platform,
    Body,
    Plugin$9,
    Screen,
    History,
    Plugin$8,
    Plugin$7
  ];

  function createChildApp (appCfg, parentApp) {
    const app = vue.createApp(appCfg);

    app.config.globalProperties = parentApp.config.globalProperties;

    const { reload, ...appContext } = parentApp._context;
    Object.assign(app._context, appContext);

    return app
  }

  function installPlugins (pluginOpts, pluginList) {
    pluginList.forEach(Plugin => {
      Plugin.install(pluginOpts);
      Plugin.__installed = true;
    });
  }

  function prepareApp (app, uiOpts, pluginOpts) {
    app.config.globalProperties.$q = pluginOpts.$q;
    app.provide(quasarKey, pluginOpts.$q);

    installPlugins(pluginOpts, autoInstalledPlugins);

    uiOpts.components !== void 0 && Object.values(uiOpts.components).forEach(c => {
      if (isObject(c) === true && c.name !== void 0) {
        app.component(c.name, c);
      }
    });

    uiOpts.directives !== void 0 && Object.values(uiOpts.directives).forEach(d => {
      if (isObject(d) === true && d.name !== void 0) {
        app.directive(d.name, d);
      }
    });

    uiOpts.plugins !== void 0 && installPlugins(
      pluginOpts,
      Object.values(uiOpts.plugins).filter(
        p => typeof p.install === 'function' && autoInstalledPlugins.includes(p) === false
      )
    );

    if (isRuntimeSsrPreHydration.value === true) {
      pluginOpts.$q.onSSRHydrated = () => {
        pluginOpts.onSSRHydrated.forEach(fn => { fn(); });
        pluginOpts.$q.onSSRHydrated = () => {};
      };
    }
  }

  var installQuasar = function (parentApp, opts = {}) {
      const $q = { version: '2.11.9' };

      if (globalConfigIsFrozen === false) {
        if (opts.config !== void 0) {
          Object.assign(globalConfig, opts.config);
        }

        $q.config = { ...globalConfig };
        freezeGlobalConfig();
      }
      else {
        $q.config = opts.config || {};
      }

      prepareApp(parentApp, opts, {
        parentApp,
        $q,
        lang: opts.lang,
        iconSet: opts.iconSet,
        onSSRHydrated: []
      });
    };

  const createComponent = raw => vue.markRaw(vue.defineComponent(raw));
  const createDirective = raw => vue.markRaw(raw);

  const units = [ 'B', 'KB', 'MB', 'GB', 'TB', 'PB' ];

  function humanStorageSize (bytes) {
    let u = 0;

    while (parseInt(bytes, 10) >= 1024 && u < units.length - 1) {
      bytes /= 1024;
      ++u;
    }

    return `${ bytes.toFixed(1) }${ units[ u ] }`
  }

  function capitalize (str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }

  function between (v, min, max) {
    return max <= min
      ? min
      : Math.min(max, Math.max(min, v))
  }

  function normalizeToInterval (v, min, max) {
    if (max <= min) {
      return min
    }

    const size = (max - min + 1);

    let index = min + (v - min) % size;
    if (index < min) {
      index = size + index;
    }

    return index === 0 ? 0 : index // fix for (-a % a) => -0
  }

  function pad (v, length = 2, char = '0') {
    if (v === void 0 || v === null) {
      return v
    }

    const val = '' + v;
    return val.length >= length
      ? val
      : new Array(length - val.length + 1).join(char) + val
  }

  var format = {
    humanStorageSize,
    capitalize,
    between,
    normalizeToInterval,
    pad
  };

  const
    xhr = XMLHttpRequest,
    open = xhr.prototype.open,
    positionValues = [ 'top', 'right', 'bottom', 'left' ];

  let stack = [];
  let highjackCount = 0;

  function translate ({ p, pos, active, horiz, reverse, dir }) {
    let x = 1, y = 1;

    if (horiz === true) {
      if (reverse === true) { x = -1; }
      if (pos === 'bottom') { y = -1; }
      return { transform: `translate3d(${ x * (p - 100) }%,${ active ? 0 : y * -200 }%,0)` }
    }

    if (reverse === true) { y = -1; }
    if (pos === 'right') { x = -1; }
    return { transform: `translate3d(${ active ? 0 : dir * x * -200 }%,${ y * (p - 100) }%,0)` }
  }

  function inc (p, amount) {
    if (typeof amount !== 'number') {
      if (p < 25) {
        amount = Math.random() * 3 + 3;
      }
      else if (p < 65) {
        amount = Math.random() * 3;
      }
      else if (p < 85) {
        amount = Math.random() * 2;
      }
      else if (p < 99) {
        amount = 0.6;
      }
      else {
        amount = 0;
      }
    }
    return between(p + amount, 0, 100)
  }

  function highjackAjax (stackEntry) {
    highjackCount++;

    stack.push(stackEntry);

    if (highjackCount > 1) { return }

    xhr.prototype.open = function (_, url) {
      const stopStack = [];

      const loadStart = () => {
        stack.forEach(entry => {
          if (
            entry.hijackFilter.value === null
            || (entry.hijackFilter.value(url) === true)
          ) {
            entry.start();
            stopStack.push(entry.stop);
          }
        });
      };

      const loadEnd = () => {
        stopStack.forEach(stop => { stop(); });
      };

      this.addEventListener('loadstart', loadStart, { once: true });
      this.addEventListener('loadend', loadEnd, { once: true });

      open.apply(this, arguments);
    };
  }

  function restoreAjax (start) {
    stack = stack.filter(entry => entry.start !== start);

    highjackCount = Math.max(0, highjackCount - 1);
    if (highjackCount === 0) {
      xhr.prototype.open = open;
    }
  }

  var QAjaxBar = createComponent({
    name: 'QAjaxBar',

    props: {
      position: {
        type: String,
        default: 'top',
        validator: val => positionValues.includes(val)
      },

      size: {
        type: String,
        default: '2px'
      },

      color: String,
      skipHijack: Boolean,
      reverse: Boolean,

      hijackFilter: Function
    },

    emits: [ 'start', 'stop' ],

    setup (props, { emit }) {
      const { proxy } = vue.getCurrentInstance();

      const progress = vue.ref(0);
      const onScreen = vue.ref(false);
      const animate = vue.ref(true);

      let sessions = 0, timer = null, speed;

      const classes = vue.computed(() =>
        `q-loading-bar q-loading-bar--${ props.position }`
        + (props.color !== void 0 ? ` bg-${ props.color }` : '')
        + (animate.value === true ? '' : ' no-transition')
      );

      const horizontal = vue.computed(() => props.position === 'top' || props.position === 'bottom');
      const sizeProp = vue.computed(() => (horizontal.value === true ? 'height' : 'width'));

      const style = vue.computed(() => {
        const active = onScreen.value;

        const obj = translate({
          p: progress.value,
          pos: props.position,
          active,
          horiz: horizontal.value,
          reverse: proxy.$q.lang.rtl === true && [ 'top', 'bottom' ].includes(props.position)
            ? props.reverse === false
            : props.reverse,
          dir: proxy.$q.lang.rtl === true ? -1 : 1
        });

        obj[ sizeProp.value ] = props.size;
        obj.opacity = active ? 1 : 0;

        return obj
      });

      const attributes = vue.computed(() => (
        onScreen.value === true
          ? {
              role: 'progressbar',
              'aria-valuemin': 0,
              'aria-valuemax': 100,
              'aria-valuenow': progress.value
            }
          : { 'aria-hidden': 'true' }
      ));

      function start (newSpeed = 300) {
        const oldSpeed = speed;
        speed = Math.max(0, newSpeed) || 0;

        sessions++;

        if (sessions > 1) {
          if (oldSpeed === 0 && newSpeed > 0) {
            planNextStep();
          }
          else if (timer !== null && oldSpeed > 0 && newSpeed <= 0) {
            clearTimeout(timer);
            timer = null;
          }

          return sessions
        }

        timer !== null && clearTimeout(timer);
        emit('start');

        progress.value = 0;

        timer = setTimeout(() => {
          timer = null;
          animate.value = true;
          newSpeed > 0 && planNextStep();
        }, onScreen.value === true ? 500 : 1);

        if (onScreen.value !== true) {
          onScreen.value = true;
          animate.value = false;
        }

        return sessions
      }

      function increment (amount) {
        if (sessions > 0) {
          progress.value = inc(progress.value, amount);
        }

        return sessions
      }

      function stop () {
        sessions = Math.max(0, sessions - 1);
        if (sessions > 0) {
          return sessions
        }

        if (timer !== null) {
          clearTimeout(timer);
          timer = null;
        }

        emit('stop');

        const end = () => {
          animate.value = true;
          progress.value = 100;
          timer = setTimeout(() => {
            timer = null;
            onScreen.value = false;
          }, 1000);
        };

        if (progress.value === 0) {
          timer = setTimeout(end, 1);
        }
        else {
          end();
        }

        return sessions
      }

      function planNextStep () {
        if (progress.value < 100) {
          timer = setTimeout(() => {
            timer = null;
            increment();
            planNextStep();
          }, speed);
        }
      }

      let hijacked;

      vue.onMounted(() => {
        if (props.skipHijack !== true) {
          hijacked = true;
          highjackAjax({
            start,
            stop,
            hijackFilter: vue.computed(() => props.hijackFilter || null)
          });
        }
      });

      vue.onBeforeUnmount(() => {
        timer !== null && clearTimeout(timer);
        hijacked === true && restoreAjax(start);
      });

      // expose public methods
      Object.assign(proxy, { start, stop, increment });

      return () => vue.h('div', {
        class: classes.value,
        style: style.value,
        ...attributes.value
      })
    }
  });

  const useSizeDefaults = {
    xs: 18,
    sm: 24,
    md: 32,
    lg: 38,
    xl: 46
  };

  const useSizeProps = {
    size: String
  };

  function useSize (props, sizes = useSizeDefaults) {
    // return sizeStyle
    return vue.computed(() => (
      props.size !== void 0
        ? { fontSize: props.size in sizes ? `${ sizes[ props.size ] }px` : props.size }
        : null
    ))
  }

  function hSlot (slot, otherwise) {
    return slot !== void 0
      ? slot() || otherwise
      : otherwise
  }

  function hUniqueSlot (slot, otherwise) {
    if (slot !== void 0) {
      const vnode = slot();
      if (vnode !== void 0 && vnode !== null) {
        return vnode.slice()
      }
    }

    return otherwise
  }

  /**
   * Source definitely exists,
   * so it's merged with the possible slot
   */
  function hMergeSlot (slot, source) {
    return slot !== void 0
      ? source.concat(slot())
      : source
  }

  /**
   * Merge with possible slot,
   * even if source might not exist
   */
  function hMergeSlotSafely (slot, source) {
    if (slot === void 0) {
      return source
    }

    return source !== void 0
      ? source.concat(slot())
      : slot()
  }

  /*
   * (String)  key       - unique vnode key
   * (Boolean) condition - should change ONLY when adding/removing directive
   */
  function hDir (
    tag,
    data,
    children,
    key,
    condition,
    getDirsFn
  ) {
    data.key = key + condition;

    const vnode = vue.h(tag, data, children);

    return condition === true
      ? vue.withDirectives(vnode, getDirsFn())
      : vnode
  }

  const defaultViewBox = '0 0 24 24';

  const sameFn = i => i;
  const ionFn = i => `ionicons ${ i }`;

  const libMap = {
    'mdi-': i => `mdi ${ i }`,
    'icon-': sameFn, // fontawesome equiv
    'bt-': i => `bt ${ i }`,
    'eva-': i => `eva ${ i }`,
    'ion-md': ionFn,
    'ion-ios': ionFn,
    'ion-logo': ionFn,
    'iconfont ': sameFn,
    'ti-': i => `themify-icon ${ i }`,
    'bi-': i => `bootstrap-icons ${ i }`
  };

  const matMap = {
    o_: '-outlined',
    r_: '-round',
    s_: '-sharp'
  };

  const symMap = {
    sym_o_: '-outlined',
    sym_r_: '-rounded',
    sym_s_: '-sharp'
  };

  const libRE = new RegExp('^(' + Object.keys(libMap).join('|') + ')');
  const matRE = new RegExp('^(' + Object.keys(matMap).join('|') + ')');
  const symRE = new RegExp('^(' + Object.keys(symMap).join('|') + ')');
  const mRE = /^[Mm]\s?[-+]?\.?\d/;
  const imgRE = /^img:/;
  const svgUseRE = /^svguse:/;
  const ionRE = /^ion-/;
  const faRE = /^(fa-(solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /;

  var QIcon = createComponent({
    name: 'QIcon',

    props: {
      ...useSizeProps,

      tag: {
        type: String,
        default: 'i'
      },

      name: String,
      color: String,
      left: Boolean,
      right: Boolean
    },

    setup (props, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const sizeStyle = useSize(props);

      const classes = vue.computed(() =>
        'q-icon'
        + (props.left === true ? ' on-left' : '') // TODO Qv3: drop this
        + (props.right === true ? ' on-right' : '')
        + (props.color !== void 0 ? ` text-${ props.color }` : '')
      );

      const type = vue.computed(() => {
        let cls;
        let icon = props.name;

        if (icon === 'none' || !icon) {
          return { none: true }
        }

        if ($q.iconMapFn !== null) {
          const res = $q.iconMapFn(icon);
          if (res !== void 0) {
            if (res.icon !== void 0) {
              icon = res.icon;
              if (icon === 'none' || !icon) {
                return { none: true }
              }
            }
            else {
              return {
                cls: res.cls,
                content: res.content !== void 0
                  ? res.content
                  : ' '
              }
            }
          }
        }

        if (mRE.test(icon) === true) {
          const [ def, viewBox = defaultViewBox ] = icon.split('|');

          return {
            svg: true,
            viewBox,
            nodes: def.split('&&').map(path => {
              const [ d, style, transform ] = path.split('@@');
              return vue.h('path', { style, d, transform })
            })
          }
        }

        if (imgRE.test(icon) === true) {
          return {
            img: true,
            src: icon.substring(4)
          }
        }

        if (svgUseRE.test(icon) === true) {
          const [ def, viewBox = defaultViewBox ] = icon.split('|');

          return {
            svguse: true,
            src: def.substring(7),
            viewBox
          }
        }

        let content = ' ';
        const matches = icon.match(libRE);

        if (matches !== null) {
          cls = libMap[ matches[ 1 ] ](icon);
        }
        else if (faRE.test(icon) === true) {
          cls = icon;
        }
        else if (ionRE.test(icon) === true) {
          cls = `ionicons ion-${ $q.platform.is.ios === true ? 'ios' : 'md' }${ icon.substring(3) }`;
        }
        else if (symRE.test(icon) === true) {
          // "notranslate" class is for Google Translate
          // to avoid tampering with Material Symbols ligature font
          //
          // Caution: To be able to add suffix to the class name,
          // keep the 'material-symbols' at the end of the string.
          cls = 'notranslate material-symbols';

          const matches = icon.match(symRE);
          if (matches !== null) {
            icon = icon.substring(6);
            cls += symMap[ matches[ 1 ] ];
          }

          content = icon;
        }
        else {
          // "notranslate" class is for Google Translate
          // to avoid tampering with Material Icons ligature font
          //
          // Caution: To be able to add suffix to the class name,
          // keep the 'material-icons' at the end of the string.
          cls = 'notranslate material-icons';

          const matches = icon.match(matRE);
          if (matches !== null) {
            icon = icon.substring(2);
            cls += matMap[ matches[ 1 ] ];
          }

          content = icon;
        }

        return {
          cls,
          content
        }
      });

      return () => {
        const data = {
          class: classes.value,
          style: sizeStyle.value,
          'aria-hidden': 'true',
          role: 'presentation'
        };

        if (type.value.none === true) {
          return vue.h(props.tag, data, hSlot(slots.default))
        }

        if (type.value.img === true) {
          return vue.h('span', data, hMergeSlot(slots.default, [
            vue.h('img', { src: type.value.src })
          ]))
        }

        if (type.value.svg === true) {
          return vue.h('span', data, hMergeSlot(slots.default, [
            vue.h('svg', {
              viewBox: type.value.viewBox || '0 0 24 24'
            }, type.value.nodes)
          ]))
        }

        if (type.value.svguse === true) {
          return vue.h('span', data, hMergeSlot(slots.default, [
            vue.h('svg', {
              viewBox: type.value.viewBox
            }, [
              vue.h('use', { 'xlink:href': type.value.src })
            ])
          ]))
        }

        if (type.value.cls !== void 0) {
          data.class += ' ' + type.value.cls;
        }

        return vue.h(props.tag, data, hMergeSlot(slots.default, [
          type.value.content
        ]))
      }
    }
  });

  var QAvatar = createComponent({
    name: 'QAvatar',

    props: {
      ...useSizeProps,

      fontSize: String,

      color: String,
      textColor: String,

      icon: String,
      square: Boolean,
      rounded: Boolean
    },

    setup (props, { slots }) {
      const sizeStyle = useSize(props);

      const classes = vue.computed(() =>
        'q-avatar'
        + (props.color ? ` bg-${ props.color }` : '')
        + (props.textColor ? ` text-${ props.textColor } q-chip--colored` : '')
        + (
          props.square === true
            ? ' q-avatar--square'
            : (props.rounded === true ? ' rounded-borders' : '')
        )
      );

      const contentStyle = vue.computed(() => (
        props.fontSize
          ? { fontSize: props.fontSize }
          : null
      ));

      return () => {
        const icon = props.icon !== void 0
          ? [ vue.h(QIcon, { name: props.icon }) ]
          : void 0;

        return vue.h('div', {
          class: classes.value,
          style: sizeStyle.value
        }, [
          vue.h('div', {
            class: 'q-avatar__content row flex-center overflow-hidden',
            style: contentStyle.value
          }, hMergeSlotSafely(slots.default, icon))
        ])
      }
    }
  });

  const alignValues$3 = [ 'top', 'middle', 'bottom' ];

  var QBadge = createComponent({
    name: 'QBadge',

    props: {
      color: String,
      textColor: String,

      floating: Boolean,
      transparent: Boolean,
      multiLine: Boolean,
      outline: Boolean,
      rounded: Boolean,

      label: [ Number, String ],

      align: {
        type: String,
        validator: v => alignValues$3.includes(v)
      }
    },

    setup (props, { slots }) {
      const style = vue.computed(() => {
        return props.align !== void 0
          ? { verticalAlign: props.align }
          : null
      });

      const classes = vue.computed(() => {
        const text = props.outline === true
          ? props.color || props.textColor
          : props.textColor;

        return 'q-badge flex inline items-center no-wrap'
          + ` q-badge--${ props.multiLine === true ? 'multi' : 'single' }-line`
          + (props.outline === true
            ? ' q-badge--outline'
            : (props.color !== void 0 ? ` bg-${ props.color }` : '')
          )
          + (text !== void 0 ? ` text-${ text }` : '')
          + (props.floating === true ? ' q-badge--floating' : '')
          + (props.rounded === true ? ' q-badge--rounded' : '')
          + (props.transparent === true ? ' q-badge--transparent' : '')
      });

      return () => vue.h('div', {
        class: classes.value,
        style: style.value,
        role: 'status',
        'aria-label': props.label
      }, hMergeSlot(slots.default, props.label !== void 0 ? [ props.label ] : []))
    }
  });

  const useDarkProps = {
    dark: {
      type: Boolean,
      default: null
    }
  };

  function useDark (props, $q) {
    // return isDark
    return vue.computed(() => (
      props.dark === null
        ? $q.dark.isActive
        : props.dark
    ))
  }

  var QBanner = createComponent({
    name: 'QBanner',

    props: {
      ...useDarkProps,

      inlineActions: Boolean,
      dense: Boolean,
      rounded: Boolean
    },

    setup (props, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const isDark = useDark(props, $q);

      const classes = vue.computed(() =>
        'q-banner row items-center'
        + (props.dense === true ? ' q-banner--dense' : '')
        + (isDark.value === true ? ' q-banner--dark q-dark' : '')
        + (props.rounded === true ? ' rounded-borders' : '')
      );

      const actionClass = vue.computed(() =>
        'q-banner__actions row items-center justify-end'
        + ` col-${ props.inlineActions === true ? 'auto' : 'all' }`
      );

      return () => {
        const child = [
          vue.h('div', {
            class: 'q-banner__avatar col-auto row items-center self-start'
          }, hSlot(slots.avatar)),

          vue.h('div', {
            class: 'q-banner__content col text-body2'
          }, hSlot(slots.default))
        ];

        const actions = hSlot(slots.action);
        actions !== void 0 && child.push(
          vue.h('div', { class: actionClass.value }, actions)
        );

        return vue.h('div', {
          class: classes.value
            + (props.inlineActions === false && actions !== void 0 ? ' q-banner--top-padding' : ''),
          role: 'alert'
        }, child)
      }
    }
  });

  var QBar = createComponent({
    name: 'QBar',

    props: {
      ...useDarkProps,
      dense: Boolean
    },

    setup (props, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const isDark = useDark(props, $q);

      const classes = vue.computed(() =>
        'q-bar row no-wrap items-center'
        + ` q-bar--${ props.dense === true ? 'dense' : 'standard' } `
        + ` q-bar--${ isDark.value === true ? 'dark' : 'light' }`
      );

      return () => vue.h('div', {
        class: classes.value,
        role: 'toolbar'
      }, hSlot(slots.default))
    }
  });

  const alignMap = {
    left: 'start',
    center: 'center',
    right: 'end',
    between: 'between',
    around: 'around',
    evenly: 'evenly',
    stretch: 'stretch'
  };

  const alignValues$2 = Object.keys(alignMap);

  const useAlignProps = {
    align: {
      type: String,
      validator: v => alignValues$2.includes(v)
    }
  };

  function useAlign (props) {
    // return alignClass
    return vue.computed(() => {
      const align = props.align === void 0
        ? props.vertical === true ? 'stretch' : 'left'
        : props.align;

      return `${ props.vertical === true ? 'items' : 'justify' }-${ alignMap[ align ] }`
    })
  }

  // copied to docs too
  function getParentProxy (proxy) {
    if (Object(proxy.$parent) === proxy.$parent) {
      return proxy.$parent
    }

    let { parent } = proxy.$;

    while (Object(parent) === parent) {
      if (Object(parent.proxy) === parent.proxy) {
        return parent.proxy
      }

      parent = parent.parent;
    }
  }

  function fillNormalizedVNodes (children, vnode) {
    if (typeof vnode.type === 'symbol') {
      if (Array.isArray(vnode.children) === true) {
        vnode.children.forEach(child => {
          fillNormalizedVNodes(children, child);
        });
      }
    }
    else {
      children.add(vnode);
    }
  }

  // vnodes from rendered in advanced slots
  function getNormalizedVNodes (vnodes) {
    const children = new Set();

    vnodes.forEach(vnode => {
      fillNormalizedVNodes(children, vnode);
    });

    return Array.from(children)
  }

  function vmHasRouter (vm) {
    return vm.appContext.config.globalProperties.$router !== void 0
  }

  function vmIsDestroyed (vm) {
    return vm.isUnmounted === true || vm.isDeactivated === true
  }

  const disabledValues = [ '', true ];

  var QBreadcrumbs = createComponent({
    name: 'QBreadcrumbs',

    props: {
      ...useAlignProps,

      separator: {
        type: String,
        default: '/'
      },
      separatorColor: String,

      activeColor: {
        type: String,
        default: 'primary'
      },

      gutter: {
        type: String,
        validator: v => [ 'none', 'xs', 'sm', 'md', 'lg', 'xl' ].includes(v),
        default: 'sm'
      }
    },

    setup (props, { slots }) {
      const alignClass = useAlign(props);

      const classes = vue.computed(() =>
        `flex items-center ${ alignClass.value }${ props.gutter === 'none' ? '' : ` q-gutter-${ props.gutter }` }`
      );

      const sepClass = vue.computed(() => (props.separatorColor ? ` text-${ props.separatorColor }` : ''));
      const activeClass = vue.computed(() => ` text-${ props.activeColor }`);

      return () => {
        const vnodes = getNormalizedVNodes(
          hSlot(slots.default)
        );

        if (vnodes.length === 0) { return }

        let els = 1;

        const
          child = [],
          len = vnodes.filter(c => c.type !== void 0 && c.type.name === 'QBreadcrumbsEl').length,
          separator = slots.separator !== void 0
            ? slots.separator
            : () => props.separator;

        vnodes.forEach(comp => {
          if (comp.type !== void 0 && comp.type.name === 'QBreadcrumbsEl') {
            const middle = els < len;
            const disabled = comp.props !== null && disabledValues.includes(comp.props.disable);
            const cls = (middle === true ? '' : ' q-breadcrumbs--last')
              + (disabled !== true && middle === true ? activeClass.value : '');

            els++;

            child.push(
              vue.h('div', {
                class: `flex items-center${ cls }`
              }, [ comp ])
            );

            if (middle === true) {
              child.push(
                vue.h('div', {
                  class: 'q-breadcrumbs__separator' + sepClass.value
                }, separator())
              );
            }
          }
          else {
            child.push(comp);
          }
        });

        return vue.h('div', {
          class: 'q-breadcrumbs'
        }, [
          vue.h('div', { class: classes.value }, child)
        ])
      }
    }
  });

  /*
   * Inspired by RouterLink from Vue Router
   *  --> API should match!
   */

  // Get the original path value of a record by following its aliasOf
  function getOriginalPath (record) {
    return record
      ? (
          record.aliasOf
            ? record.aliasOf.path
            : record.path
        ) : ''
  }

  function isSameRouteRecord (a, b) {
    // since the original record has an undefined value for aliasOf
    // but all aliases point to the original record, this will always compare
    // the original record
    return (a.aliasOf || a) === (b.aliasOf || b)
  }

  function includesParams (outer, inner) {
    for (const key in inner) {
      const
        innerValue = inner[ key ],
        outerValue = outer[ key ];

      if (typeof innerValue === 'string') {
        if (innerValue !== outerValue) {
          return false
        }
      }
      else if (
        Array.isArray(outerValue) === false
        || outerValue.length !== innerValue.length
        || innerValue.some((value, i) => value !== outerValue[ i ])
      ) {
        return false
      }
    }

    return true
  }

  function isEquivalentArray (a, b) {
    return Array.isArray(b) === true
      ? a.length === b.length && a.every((value, i) => value === b[ i ])
      : a.length === 1 && a[ 0 ] === b
  }

  function isSameRouteLocationParamsValue (a, b) {
    return Array.isArray(a) === true
      ? isEquivalentArray(a, b)
      : (
          Array.isArray(b) === true
            ? isEquivalentArray(b, a)
            : a === b
        )
  }

  function isSameRouteLocationParams (a, b) {
    if (Object.keys(a).length !== Object.keys(b).length) {
      return false
    }

    for (const key in a) {
      if (isSameRouteLocationParamsValue(a[ key ], b[ key ]) === false) {
        return false
      }
    }

    return true
  }

  const useRouterLinkProps = {
    // router-link
    to: [ String, Object ],
    replace: Boolean,
    exact: Boolean,
    activeClass: {
      type: String,
      default: 'q-router-link--active'
    },
    exactActiveClass: {
      type: String,
      default: 'q-router-link--exact-active'
    },

    // regular <a> link
    href: String,
    target: String,

    // state
    disable: Boolean
  };

  // external props: type, tag

  function useRouterLink ({ fallbackTag, useDisableForRouterLinkProps = true } = {}) {
    const vm = vue.getCurrentInstance();
    const { props, proxy, emit } = vm;

    const hasRouter = vmHasRouter(vm);
    const hasHrefLink = vue.computed(() => props.disable !== true && props.href !== void 0);

    // for perf reasons, we use minimum amount of runtime work
    const hasRouterLinkProps = useDisableForRouterLinkProps === true
      ? vue.computed(() =>
        hasRouter === true
        && props.disable !== true
        && hasHrefLink.value !== true
        && props.to !== void 0 && props.to !== null && props.to !== ''
      )
      : vue.computed(() =>
        hasRouter === true
        && hasHrefLink.value !== true
        && props.to !== void 0 && props.to !== null && props.to !== ''
      );

    const resolvedLink = vue.computed(() => (
      hasRouterLinkProps.value === true
        ? getLink(props.to)
        : null
    ));

    const hasRouterLink = vue.computed(() => resolvedLink.value !== null);
    const hasLink = vue.computed(() => hasHrefLink.value === true || hasRouterLink.value === true);

    const linkTag = vue.computed(() => (
      props.type === 'a' || hasLink.value === true
        ? 'a'
        : (props.tag || fallbackTag || 'div')
    ));

    const linkAttrs = vue.computed(() => (
      hasHrefLink.value === true
        ? {
            href: props.href,
            target: props.target
          }
        : (
            hasRouterLink.value === true
              ? {
                  href: resolvedLink.value.href,
                  target: props.target
                }
              : {}
          )
    ));

    const linkActiveIndex = vue.computed(() => {
      if (hasRouterLink.value === false) {
        return -1
      }

      const
        { matched } = resolvedLink.value,
        { length } = matched,
        routeMatched = matched[ length - 1 ];

      if (routeMatched === void 0) {
        return -1
      }

      const currentMatched = proxy.$route.matched;

      if (currentMatched.length === 0) {
        return -1
      }

      const index = currentMatched.findIndex(
        isSameRouteRecord.bind(null, routeMatched)
      );

      if (index > -1) {
        return index
      }

      // possible parent record
      const parentRecordPath = getOriginalPath(matched[ length - 2 ]);

      return (
        // we are dealing with nested routes
        length > 1
        // if the parent and matched route have the same path, this link is
        // referring to the empty child. Or we currently are on a different
        // child of the same parent
        && getOriginalPath(routeMatched) === parentRecordPath
        // avoid comparing the child with its parent
        && currentMatched[ currentMatched.length - 1 ].path !== parentRecordPath
          ? currentMatched.findIndex(
            isSameRouteRecord.bind(null, matched[ length - 2 ])
          )
          : index
      )
    });

    const linkIsActive = vue.computed(() =>
      hasRouterLink.value === true
      && linkActiveIndex.value !== -1
      && includesParams(proxy.$route.params, resolvedLink.value.params)
    );

    const linkIsExactActive = vue.computed(() =>
      linkIsActive.value === true
        && linkActiveIndex.value === proxy.$route.matched.length - 1
        && isSameRouteLocationParams(proxy.$route.params, resolvedLink.value.params)
    );

    const linkClass = vue.computed(() => (
      hasRouterLink.value === true
        ? (
            linkIsExactActive.value === true
              ? ` ${ props.exactActiveClass } ${ props.activeClass }`
              : (
                  props.exact === true
                    ? ''
                    : (linkIsActive.value === true ? ` ${ props.activeClass }` : '')
                )
          )
        : ''
    ));

    function getLink (to) {
      try { return proxy.$router.resolve(to) }
      catch (_) {}

      return null
    }

    /**
     * @returns Promise<RouterError | false | undefined>
     */
    function navigateToRouterLink (
      e,
      { returnRouterError, to = props.to, replace = props.replace } = {}
    ) {
      if (props.disable === true) {
        // ensure native navigation is prevented in all cases,
        // like when useDisableForRouterLinkProps === false (QRouteTab)
        e.preventDefault();
        return Promise.resolve(false)
      }

      if (
        // don't redirect with control keys;
        // should match RouterLink from Vue Router
        e.metaKey || e.altKey || e.ctrlKey || e.shiftKey

        // don't redirect on right click
        || (e.button !== void 0 && e.button !== 0)

        // don't redirect if it should open in a new window
        || props.target === '_blank'
      ) {
        return Promise.resolve(false)
      }

      // hinder the native navigation
      e.preventDefault();

      // then() can also return a "soft" router error (Vue Router behavior)
      const promise = proxy.$router[ replace === true ? 'replace' : 'push' ](to);

      return returnRouterError === true
        ? promise
        // else catching hard errors and also "soft" ones - then(err => ...)
        : promise.then(() => {}).catch(() => {})
    }

    // warning! ensure that the component using it has 'click' included in its 'emits' definition prop
    function navigateOnClick (e) {
      if (hasRouterLink.value === true) {
        const go = opts => navigateToRouterLink(e, opts);

        emit('click', e, go);
        e.defaultPrevented !== true && go();
      }
      else {
        emit('click', e);
      }
    }

    return {
      hasRouterLink,
      hasHrefLink,
      hasLink,

      linkTag,
      resolvedLink,
      linkIsActive,
      linkIsExactActive,
      linkClass,
      linkAttrs,

      getLink,
      navigateToRouterLink,
      navigateOnClick
    }
  }

  var QBreadcrumbsEl = createComponent({
    name: 'QBreadcrumbsEl',

    props: {
      ...useRouterLinkProps,

      label: String,
      icon: String,

      tag: {
        type: String,
        default: 'span'
      }
    },

    emits: [ 'click' ],

    setup (props, { slots }) {
      const { linkTag, linkAttrs, linkClass, navigateOnClick } = useRouterLink();

      const data = vue.computed(() => {
        return {
          class: 'q-breadcrumbs__el q-link '
            + 'flex inline items-center relative-position '
            + (props.disable !== true ? 'q-link--focusable' + linkClass.value : 'q-breadcrumbs__el--disable'),
          ...linkAttrs.value,
          onClick: navigateOnClick
        }
      });

      const iconClass = vue.computed(() =>
        'q-breadcrumbs__el-icon'
        + (props.label !== void 0 ? ' q-breadcrumbs__el-icon--with-label' : '')
      );

      return () => {
        const child = [];

        props.icon !== void 0 && child.push(
          vue.h(QIcon, {
            class: iconClass.value,
            name: props.icon
          })
        );

        props.label !== void 0 && child.push(props.label);

        return vue.h(
          linkTag.value,
          { ...data.value },
          hMergeSlot(slots.default, child)
        )
      }
    }
  });

  const useSpinnerProps = {
    size: {
      type: [ Number, String ],
      default: '1em'
    },
    color: String
  };

  function useSpinner (props) {
    return {
      cSize: vue.computed(() => (
        props.size in useSizeDefaults
          ? `${ useSizeDefaults[ props.size ] }px`
          : props.size
      )),

      classes: vue.computed(() =>
        'q-spinner' + (props.color ? ` text-${ props.color }` : '')
      )
    }
  }

  var QSpinner = createComponent({
    name: 'QSpinner',

    props: {
      ...useSpinnerProps,

      thickness: {
        type: Number,
        default: 5
      }
    },

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value + ' q-spinner-mat',
        width: cSize.value,
        height: cSize.value,
        viewBox: '25 25 50 50'
      }, [
        vue.h('circle', {
          class: 'path',
          cx: '50',
          cy: '50',
          r: '20',
          fill: 'none',
          stroke: 'currentColor',
          'stroke-width': props.thickness,
          'stroke-miterlimit': '10'
        })
      ])
    }
  });

  function offset (el) {
    if (el === window) {
      return { top: 0, left: 0 }
    }
    const { top, left } = el.getBoundingClientRect();
    return { top, left }
  }

  function style (el, property) {
    return window.getComputedStyle(el).getPropertyValue(property)
  }

  function height (el) {
    return el === window
      ? window.innerHeight
      : el.getBoundingClientRect().height
  }

  function width$1 (el) {
    return el === window
      ? window.innerWidth
      : el.getBoundingClientRect().width
  }

  function css (element, css) {
    const style = element.style;

    for (const prop in css) {
      style[ prop ] = css[ prop ];
    }
  }

  function cssBatch (elements, style) {
    elements.forEach(el => css(el, style));
  }

  function ready (fn) {
    if (typeof fn !== 'function') {
      return
    }

    if (document.readyState !== 'loading') {
      return fn()
    }

    document.addEventListener('DOMContentLoaded', fn, false);
  }

  // internal
  function getElement$1 (el) {
    if (el === void 0 || el === null) {
      return void 0
    }

    if (typeof el === 'string') {
      try {
        return document.querySelector(el) || void 0
      }
      catch (err) {
        return void 0
      }
    }

    const target = vue.unref(el);
    if (target) {
      return target.$el || target
    }
  }

  // internal
  function childHasFocus (el, focusedEl) {
    if (el === void 0 || el === null || el.contains(focusedEl) === true) {
      return true
    }

    for (let next = el.nextElementSibling; next !== null; next = next.nextElementSibling) {
      if (next.contains(focusedEl)) {
        return true
      }
    }

    return false
  }

  var dom = {
    offset,
    style,
    height,
    width: width$1,
    css,
    cssBatch,
    ready
  };

  function throttle (fn, limit = 250) {
    let wait = false, result;

    return function (/* ...args */) {
      if (wait === false) {
        wait = true;
        setTimeout(() => { wait = false; }, limit);
        result = fn.apply(this, arguments);
      }

      return result
    }
  }

  function showRipple (evt, el, ctx, forceCenter) {
    ctx.modifiers.stop === true && stop(evt);

    const color = ctx.modifiers.color;
    let center = ctx.modifiers.center;
    center = center === true || forceCenter === true;

    const
      node = document.createElement('span'),
      innerNode = document.createElement('span'),
      pos = position(evt),
      { left, top, width, height } = el.getBoundingClientRect(),
      diameter = Math.sqrt(width * width + height * height),
      radius = diameter / 2,
      centerX = `${ (width - diameter) / 2 }px`,
      x = center ? centerX : `${ pos.left - left - radius }px`,
      centerY = `${ (height - diameter) / 2 }px`,
      y = center ? centerY : `${ pos.top - top - radius }px`;

    innerNode.className = 'q-ripple__inner';
    css(innerNode, {
      height: `${ diameter }px`,
      width: `${ diameter }px`,
      transform: `translate3d(${ x },${ y },0) scale3d(.2,.2,1)`,
      opacity: 0
    });

    node.className = `q-ripple${ color ? ' text-' + color : '' }`;
    node.setAttribute('dir', 'ltr');
    node.appendChild(innerNode);
    el.appendChild(node);

    const abort = () => {
      node.remove();
      clearTimeout(timer);
    };
    ctx.abort.push(abort);

    let timer = setTimeout(() => {
      innerNode.classList.add('q-ripple__inner--enter');
      innerNode.style.transform = `translate3d(${ centerX },${ centerY },0) scale3d(1,1,1)`;
      innerNode.style.opacity = 0.2;

      timer = setTimeout(() => {
        innerNode.classList.remove('q-ripple__inner--enter');
        innerNode.classList.add('q-ripple__inner--leave');
        innerNode.style.opacity = 0;

        timer = setTimeout(() => {
          node.remove();
          ctx.abort.splice(ctx.abort.indexOf(abort), 1);
        }, 275);
      }, 250);
    }, 50);
  }

  function updateModifiers$1 (ctx, { modifiers, value, arg }) {
    const cfg = Object.assign({}, ctx.cfg.ripple, modifiers, value);
    ctx.modifiers = {
      early: cfg.early === true,
      stop: cfg.stop === true,
      center: cfg.center === true,
      color: cfg.color || arg,
      keyCodes: [].concat(cfg.keyCodes || 13)
    };
  }

  var Ripple = createDirective({
        name: 'ripple',

        beforeMount (el, binding) {
          const cfg = binding.instance.$.appContext.config.globalProperties.$q.config || {};

          if (cfg.ripple === false) {
            return
          }

          const ctx = {
            cfg,
            enabled: binding.value !== false,
            modifiers: {},
            abort: [],

            start (evt) {
              if (
                ctx.enabled === true
                && evt.qSkipRipple !== true
                && evt.type === (ctx.modifiers.early === true ? 'pointerdown' : 'click')
              ) {
                showRipple(evt, el, ctx, evt.qKeyEvent === true);
              }
            },

            keystart: throttle(evt => {
              if (
                ctx.enabled === true
                && evt.qSkipRipple !== true
                && isKeyCode(evt, ctx.modifiers.keyCodes) === true
                && evt.type === `key${ ctx.modifiers.early === true ? 'down' : 'up' }`
              ) {
                showRipple(evt, el, ctx, true);
              }
            }, 300)
          };

          updateModifiers$1(ctx, binding);

          el.__qripple = ctx;

          addEvt(ctx, 'main', [
            [ el, 'pointerdown', 'start', 'passive' ],
            [ el, 'click', 'start', 'passive' ],
            [ el, 'keydown', 'keystart', 'passive' ],
            [ el, 'keyup', 'keystart', 'passive' ]
          ]);
        },

        updated (el, binding) {
          if (binding.oldValue !== binding.value) {
            const ctx = el.__qripple;
            if (ctx !== void 0) {
              ctx.enabled = binding.value !== false;

              if (ctx.enabled === true && Object(binding.value) === binding.value) {
                updateModifiers$1(ctx, binding);
              }
            }
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qripple;
          if (ctx !== void 0) {
            ctx.abort.forEach(fn => { fn(); });
            cleanEvt(ctx, 'main');
            delete el._qripple;
          }
        }
      }
  );

  const btnPadding = {
    none: 0,
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32
  };

  const defaultSizes$2 = {
    xs: 8,
    sm: 10,
    md: 14,
    lg: 20,
    xl: 24
  };

  const formTypes = [ 'button', 'submit', 'reset' ];
  const mediaTypeRE = /[^\s]\/[^\s]/;

  const btnDesignOptions = [ 'flat', 'outline', 'push', 'unelevated' ];
  const getBtnDesign = (props, defaultValue) => {
    if (props.flat === true) return 'flat'
    if (props.outline === true) return 'outline'
    if (props.push === true) return 'push'
    if (props.unelevated === true) return 'unelevated'
    return defaultValue
  };
  const getBtnDesignAttr = props => {
    const design = getBtnDesign(props);
    return design !== void 0
      ? { [ design ]: true }
      : {}
  };

  const useBtnProps = {
    ...useSizeProps,
    ...useRouterLinkProps,

    type: {
      type: String,
      default: 'button'
    },

    label: [ Number, String ],
    icon: String,
    iconRight: String,

    ...btnDesignOptions.reduce(
      (acc, val) => (acc[ val ] = Boolean) && acc,
      {}
    ),

    square: Boolean,
    round: Boolean,
    rounded: Boolean,
    glossy: Boolean,

    size: String,
    fab: Boolean,
    fabMini: Boolean,
    padding: String,

    color: String,
    textColor: String,
    noCaps: Boolean,
    noWrap: Boolean,
    dense: Boolean,

    tabindex: [ Number, String ],

    ripple: {
      type: [ Boolean, Object ],
      default: true
    },

    align: {
      ...useAlignProps.align,
      default: 'center'
    },
    stack: Boolean,
    stretch: Boolean,
    loading: {
      type: Boolean,
      default: null
    },
    disable: Boolean
  };

  function useBtn (props) {
    const sizeStyle = useSize(props, defaultSizes$2);
    const alignClass = useAlign(props);
    const { hasRouterLink, hasLink, linkTag, linkAttrs, navigateOnClick } = useRouterLink({
      fallbackTag: 'button'
    });

    const style = vue.computed(() => {
      const obj = props.fab === false && props.fabMini === false
        ? sizeStyle.value
        : {};

      return props.padding !== void 0
        ? Object.assign({}, obj, {
          padding: props.padding
            .split(/\s+/)
            .map(v => (v in btnPadding ? btnPadding[ v ] + 'px' : v))
            .join(' '),
          minWidth: '0',
          minHeight: '0'
        })
        : obj
    });

    const isRounded = vue.computed(() =>
      props.rounded === true || props.fab === true || props.fabMini === true
    );

    const isActionable = vue.computed(() =>
      props.disable !== true && props.loading !== true
    );

    const tabIndex = vue.computed(() => (
      isActionable.value === true ? props.tabindex || 0 : -1
    ));

    const design = vue.computed(() => getBtnDesign(props, 'standard'));

    const attributes = vue.computed(() => {
      const acc = { tabindex: tabIndex.value };

      if (hasLink.value === true) {
        Object.assign(acc, linkAttrs.value);
      }
      else if (formTypes.includes(props.type) === true) {
        acc.type = props.type;
      }

      if (linkTag.value === 'a') {
        if (props.disable === true) {
          acc[ 'aria-disabled' ] = 'true';
        }
        else if (acc.href === void 0) {
          acc.role = 'button';
        }

        if (hasRouterLink.value !== true && mediaTypeRE.test(props.type) === true) {
          acc.type = props.type;
        }
      }
      else if (props.disable === true) {
        acc.disabled = '';
        acc[ 'aria-disabled' ] = 'true';
      }

      if (props.loading === true && props.percentage !== void 0) {
        Object.assign(acc, {
          role: 'progressbar',
          'aria-valuemin': 0,
          'aria-valuemax': 100,
          'aria-valuenow': props.percentage
        });
      }

      return acc
    });

    const classes = vue.computed(() => {
      let colors;

      if (props.color !== void 0) {
        if (props.flat === true || props.outline === true) {
          colors = `text-${ props.textColor || props.color }`;
        }
        else {
          colors = `bg-${ props.color } text-${ props.textColor || 'white' }`;
        }
      }
      else if (props.textColor) {
        colors = `text-${ props.textColor }`;
      }

      const shape = props.round === true
        ? 'round'
        : `rectangle${ isRounded.value === true ? ' q-btn--rounded' : (props.square === true ? ' q-btn--square' : '') }`;

      return `q-btn--${ design.value } q-btn--${ shape }`
        + (colors !== void 0 ? ' ' + colors : '')
        + (isActionable.value === true ? ' q-btn--actionable q-focusable q-hoverable' : (props.disable === true ? ' disabled' : ''))
        + (props.fab === true ? ' q-btn--fab' : (props.fabMini === true ? ' q-btn--fab-mini' : ''))
        + (props.noCaps === true ? ' q-btn--no-uppercase' : '')
        + (props.dense === true ? ' q-btn--dense' : '')
        + (props.stretch === true ? ' no-border-radius self-stretch' : '')
        + (props.glossy === true ? ' glossy' : '')
        + (props.square ? ' q-btn--square' : '')
    });

    const innerClasses = vue.computed(() =>
      alignClass.value + (props.stack === true ? ' column' : ' row')
      + (props.noWrap === true ? ' no-wrap text-no-wrap' : '')
      + (props.loading === true ? ' q-btn__content--hidden' : '')
    );

    return {
      classes,
      style,
      innerClasses,
      attributes,
      hasLink,
      linkTag,
      navigateOnClick,
      isActionable
    }
  }

  const { passiveCapture } = listenOpts;

  let
    touchTarget = null,
    keyboardTarget = null,
    mouseTarget = null;

  var QBtn = createComponent({
    name: 'QBtn',

    props: {
      ...useBtnProps,

      percentage: Number,
      darkPercentage: Boolean,

      onTouchstart: [ Function, Array ]
    },

    emits: [ 'click', 'keydown', 'mousedown', 'keyup' ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();

      const {
        classes, style, innerClasses,
        attributes,
        hasLink, linkTag, navigateOnClick,
        isActionable
      } = useBtn(props);

      const rootRef = vue.ref(null);
      const blurTargetRef = vue.ref(null);

      let localTouchTargetEl = null, avoidMouseRipple, mouseTimer = null;

      const hasLabel = vue.computed(() =>
        props.label !== void 0 && props.label !== null && props.label !== ''
      );

      const ripple = vue.computed(() => (
        props.disable === true || props.ripple === false
          ? false
          : {
              keyCodes: hasLink.value === true ? [ 13, 32 ] : [ 13 ],
              ...(props.ripple === true ? {} : props.ripple)
            }
      ));

      const rippleProps = vue.computed(() => ({ center: props.round }));

      const percentageStyle = vue.computed(() => {
        const val = Math.max(0, Math.min(100, props.percentage));
        return val > 0
          ? { transition: 'transform 0.6s', transform: `translateX(${ val - 100 }%)` }
          : {}
      });

      const onEvents = vue.computed(() => {
        if (props.loading === true) {
          return {
            onMousedown: onLoadingEvt,
            onTouchstart: onLoadingEvt,
            onClick: onLoadingEvt,
            onKeydown: onLoadingEvt,
            onKeyup: onLoadingEvt
          }
        }

        if (isActionable.value === true) {
          const acc = {
            onClick,
            onKeydown,
            onMousedown
          };

          if (proxy.$q.platform.has.touch === true) {
            const suffix = props.onTouchstart !== void 0
              ? ''
              : 'Passive';

            acc[ `onTouchstart${ suffix }` ] = onTouchstart;
          }

          return acc
        }

        return {
          // needed; especially for disabled <a> tags
          onClick: stopAndPrevent
        }
      });

      const nodeProps = vue.computed(() => ({
        ref: rootRef,
        class: 'q-btn q-btn-item non-selectable no-outline ' + classes.value,
        style: style.value,
        ...attributes.value,
        ...onEvents.value
      }));

      function onClick (e) {
        // is it already destroyed?
        if (rootRef.value === null) { return }

        if (e !== void 0) {
          if (e.defaultPrevented === true) {
            return
          }

          const el = document.activeElement;
          // focus button if it came from ENTER on form
          // prevent the new submit (already done)
          if (
            props.type === 'submit'
            && el !== document.body
            && rootRef.value.contains(el) === false
            // required for iOS and desktop Safari
            && el.contains(rootRef.value) === false
          ) {
            rootRef.value.focus();

            const onClickCleanup = () => {
              document.removeEventListener('keydown', stopAndPrevent, true);
              document.removeEventListener('keyup', onClickCleanup, passiveCapture);
              rootRef.value !== null && rootRef.value.removeEventListener('blur', onClickCleanup, passiveCapture);
            };

            document.addEventListener('keydown', stopAndPrevent, true);
            document.addEventListener('keyup', onClickCleanup, passiveCapture);
            rootRef.value.addEventListener('blur', onClickCleanup, passiveCapture);
          }
        }

        navigateOnClick(e);
      }

      function onKeydown (e) {
        // is it already destroyed?
        if (rootRef.value === null) { return }

        emit('keydown', e);

        if (isKeyCode(e, [ 13, 32 ]) === true && keyboardTarget !== rootRef.value) {
          keyboardTarget !== null && cleanup();

          if (e.defaultPrevented !== true) {
            // focus external button if the focus helper was focused before
            rootRef.value.focus();

            keyboardTarget = rootRef.value;
            rootRef.value.classList.add('q-btn--active');
            document.addEventListener('keyup', onPressEnd, true);
            rootRef.value.addEventListener('blur', onPressEnd, passiveCapture);
          }

          stopAndPrevent(e);
        }
      }

      function onTouchstart (e) {
        // is it already destroyed?
        if (rootRef.value === null) { return }

        emit('touchstart', e);

        if (e.defaultPrevented === true) { return }

        if (touchTarget !== rootRef.value) {
          touchTarget !== null && cleanup();
          touchTarget = rootRef.value;

          localTouchTargetEl = e.target;
          localTouchTargetEl.addEventListener('touchcancel', onPressEnd, passiveCapture);
          localTouchTargetEl.addEventListener('touchend', onPressEnd, passiveCapture);
        }

        // avoid duplicated mousedown event
        // triggering another early ripple
        avoidMouseRipple = true;
        mouseTimer !== null && clearTimeout(mouseTimer);
        mouseTimer = setTimeout(() => {
          mouseTimer = null;
          avoidMouseRipple = false;
        }, 200);
      }

      function onMousedown (e) {
        // is it already destroyed?
        if (rootRef.value === null) { return }

        e.qSkipRipple = avoidMouseRipple === true;
        emit('mousedown', e);

        if (e.defaultPrevented !== true && mouseTarget !== rootRef.value) {
          mouseTarget !== null && cleanup();
          mouseTarget = rootRef.value;
          rootRef.value.classList.add('q-btn--active');
          document.addEventListener('mouseup', onPressEnd, passiveCapture);
        }
      }

      function onPressEnd (e) {
        // is it already destroyed?
        if (rootRef.value === null) { return }

        // needed for IE (because it emits blur when focusing button from focus helper)
        if (e !== void 0 && e.type === 'blur' && document.activeElement === rootRef.value) {
          return
        }

        if (e !== void 0 && e.type === 'keyup') {
          if (keyboardTarget === rootRef.value && isKeyCode(e, [ 13, 32 ]) === true) {
            // for click trigger
            const evt = new MouseEvent('click', e);
            evt.qKeyEvent = true;
            e.defaultPrevented === true && prevent(evt);
            e.cancelBubble === true && stop(evt);
            rootRef.value.dispatchEvent(evt);

            stopAndPrevent(e);

            // for ripple
            e.qKeyEvent = true;
          }

          emit('keyup', e);
        }

        cleanup();
      }

      function cleanup (destroying) {
        const blurTarget = blurTargetRef.value;

        if (
          destroying !== true
          && (touchTarget === rootRef.value || mouseTarget === rootRef.value)
          && blurTarget !== null
          && blurTarget !== document.activeElement
        ) {
          blurTarget.setAttribute('tabindex', -1);
          blurTarget.focus();
        }

        if (touchTarget === rootRef.value) {
          if (localTouchTargetEl !== null) {
            localTouchTargetEl.removeEventListener('touchcancel', onPressEnd, passiveCapture);
            localTouchTargetEl.removeEventListener('touchend', onPressEnd, passiveCapture);
          }
          touchTarget = localTouchTargetEl = null;
        }

        if (mouseTarget === rootRef.value) {
          document.removeEventListener('mouseup', onPressEnd, passiveCapture);
          mouseTarget = null;
        }

        if (keyboardTarget === rootRef.value) {
          document.removeEventListener('keyup', onPressEnd, true);
          rootRef.value !== null && rootRef.value.removeEventListener('blur', onPressEnd, passiveCapture);
          keyboardTarget = null;
        }

        rootRef.value !== null && rootRef.value.classList.remove('q-btn--active');
      }

      function onLoadingEvt (evt) {
        stopAndPrevent(evt);
        evt.qSkipRipple = true;
      }

      vue.onBeforeUnmount(() => {
        cleanup(true);
      });

      // expose public methods
      Object.assign(proxy, { click: onClick });

      return () => {
        let inner = [];

        props.icon !== void 0 && inner.push(
          vue.h(QIcon, {
            name: props.icon,
            left: props.stack === false && hasLabel.value === true,
            role: 'img',
            'aria-hidden': 'true'
          })
        );

        hasLabel.value === true && inner.push(
          vue.h('span', { class: 'block' }, [ props.label ])
        );

        inner = hMergeSlot(slots.default, inner);

        if (props.iconRight !== void 0 && props.round === false) {
          inner.push(
            vue.h(QIcon, {
              name: props.iconRight,
              right: props.stack === false && hasLabel.value === true,
              role: 'img',
              'aria-hidden': 'true'
            })
          );
        }

        const child = [
          vue.h('span', {
            class: 'q-focus-helper',
            ref: blurTargetRef
          })
        ];

        if (props.loading === true && props.percentage !== void 0) {
          child.push(
            vue.h('span', {
              class: 'q-btn__progress absolute-full overflow-hidden' + (props.darkPercentage === true ? ' q-btn__progress--dark' : '')
            }, [
              vue.h('span', {
                class: 'q-btn__progress-indicator fit block',
                style: percentageStyle.value
              })
            ])
          );
        }

        child.push(
          vue.h('span', {
            class: 'q-btn__content text-center col items-center q-anchor--skip ' + innerClasses.value
          }, inner)
        );

        props.loading !== null && child.push(
          vue.h(vue.Transition, {
            name: 'q-transition--fade'
          }, () => (
            props.loading === true
              ? [
                  vue.h('span', {
                    key: 'loading',
                    class: 'absolute-full flex flex-center'
                  }, slots.loading !== void 0 ? slots.loading() : [ vue.h(QSpinner) ])
                ]
              : null
          ))
        );

        return vue.withDirectives(
          vue.h(
            linkTag.value,
            nodeProps.value,
            child
          ),
          [ [
            Ripple,
            ripple.value,
            void 0,
            rippleProps.value
          ] ]
        )
      }
    }
  });

  var QBtnGroup = createComponent({
    name: 'QBtnGroup',

    props: {
      unelevated: Boolean,
      outline: Boolean,
      flat: Boolean,
      rounded: Boolean,
      square: Boolean,
      push: Boolean,
      stretch: Boolean,
      glossy: Boolean,
      spread: Boolean
    },

    setup (props, { slots }) {
      const classes = vue.computed(() => {
        const cls = [ 'unelevated', 'outline', 'flat', 'rounded', 'square', 'push', 'stretch', 'glossy' ]
          .filter(t => props[ t ] === true)
          .map(t => `q-btn-group--${ t }`).join(' ');

        return `q-btn-group row no-wrap${ cls.length > 0 ? ' ' + cls : '' }`
          + (props.spread === true ? ' q-btn-group--spread' : ' inline')
      });

      return () => vue.h('div', { class: classes.value }, hSlot(slots.default))
    }
  });

  function clearSelection () {
    if (window.getSelection !== void 0) {
      const selection = window.getSelection();
      if (selection.empty !== void 0) {
        selection.empty();
      }
      else if (selection.removeAllRanges !== void 0) {
        selection.removeAllRanges();
        Platform.is.mobile !== true && selection.addRange(document.createRange());
      }
    }
    else if (document.selection !== void 0) {
      document.selection.empty();
    }
  }

  const useAnchorProps = {
    target: {
      default: true
    },
    noParentEvent: Boolean,
    contextMenu: Boolean
  };

  function useAnchor ({
    showing,
    avoidEmit, // required for QPopupProxy (true)
    configureAnchorEl // optional
  }) {
    const { props, proxy, emit } = vue.getCurrentInstance();

    const anchorEl = vue.ref(null);

    let touchTimer = null;

    function canShow (evt) {
      // abort with no parent configured or on multi-touch
      return anchorEl.value === null
        ? false
        : (evt === void 0 || evt.touches === void 0 || evt.touches.length <= 1)
    }

    const anchorEvents = {};

    if (configureAnchorEl === void 0) {
      // default configureAnchorEl is designed for
      // QMenu & QPopupProxy (which is why it's handled here)

      Object.assign(anchorEvents, {
        hide (evt) {
          proxy.hide(evt);
        },

        toggle (evt) {
          proxy.toggle(evt);
          evt.qAnchorHandled = true;
        },

        toggleKey (evt) {
          isKeyCode(evt, 13) === true && anchorEvents.toggle(evt);
        },

        contextClick (evt) {
          proxy.hide(evt);
          prevent(evt);
          vue.nextTick(() => {
            proxy.show(evt);
            evt.qAnchorHandled = true;
          });
        },

        prevent,

        mobileTouch (evt) {
          anchorEvents.mobileCleanup(evt);

          if (canShow(evt) !== true) {
            return
          }

          proxy.hide(evt);
          anchorEl.value.classList.add('non-selectable');

          const target = evt.target;
          addEvt(anchorEvents, 'anchor', [
            [ target, 'touchmove', 'mobileCleanup', 'passive' ],
            [ target, 'touchend', 'mobileCleanup', 'passive' ],
            [ target, 'touchcancel', 'mobileCleanup', 'passive' ],
            [ anchorEl.value, 'contextmenu', 'prevent', 'notPassive' ]
          ]);

          touchTimer = setTimeout(() => {
            touchTimer = null;
            proxy.show(evt);
            evt.qAnchorHandled = true;
          }, 300);
        },

        mobileCleanup (evt) {
          anchorEl.value.classList.remove('non-selectable');

          if (touchTimer !== null) {
            clearTimeout(touchTimer);
            touchTimer = null;
          }

          if (showing.value === true && evt !== void 0) {
            clearSelection();
          }
        }
      });

      configureAnchorEl = function (context = props.contextMenu) {
        if (props.noParentEvent === true || anchorEl.value === null) { return }

        let evts;

        if (context === true) {
          if (proxy.$q.platform.is.mobile === true) {
            evts = [
              [ anchorEl.value, 'touchstart', 'mobileTouch', 'passive' ]
            ];
          }
          else {
            evts = [
              [ anchorEl.value, 'mousedown', 'hide', 'passive' ],
              [ anchorEl.value, 'contextmenu', 'contextClick', 'notPassive' ]
            ];
          }
        }
        else {
          evts = [
            [ anchorEl.value, 'click', 'toggle', 'passive' ],
            [ anchorEl.value, 'keyup', 'toggleKey', 'passive' ]
          ];
        }

        addEvt(anchorEvents, 'anchor', evts);
      };
    }

    function unconfigureAnchorEl () {
      cleanEvt(anchorEvents, 'anchor');
    }

    function setAnchorEl (el) {
      anchorEl.value = el;
      while (anchorEl.value.classList.contains('q-anchor--skip')) {
        anchorEl.value = anchorEl.value.parentNode;
      }
      configureAnchorEl();
    }

    function pickAnchorEl () {
      if (props.target === false || props.target === '' || proxy.$el.parentNode === null) {
        anchorEl.value = null;
      }
      else if (props.target === true) {
        setAnchorEl(proxy.$el.parentNode);
      }
      else {
        let el = props.target;

        if (typeof props.target === 'string') {
          try {
            el = document.querySelector(props.target);
          }
          catch (err) {
            el = void 0;
          }
        }

        if (el !== void 0 && el !== null) {
          anchorEl.value = el.$el || el;
          configureAnchorEl();
        }
        else {
          anchorEl.value = null;
          console.error(`Anchor: target "${ props.target }" not found`);
        }
      }
    }

    vue.watch(() => props.contextMenu, val => {
      if (anchorEl.value !== null) {
        unconfigureAnchorEl();
        configureAnchorEl(val);
      }
    });

    vue.watch(() => props.target, () => {
      if (anchorEl.value !== null) {
        unconfigureAnchorEl();
      }

      pickAnchorEl();
    });

    vue.watch(() => props.noParentEvent, val => {
      if (anchorEl.value !== null) {
        if (val === true) {
          unconfigureAnchorEl();
        }
        else {
          configureAnchorEl();
        }
      }
    });

    vue.onMounted(() => {
      pickAnchorEl();

      if (avoidEmit !== true && props.modelValue === true && anchorEl.value === null) {
        emit('update:modelValue', false);
      }
    });

    vue.onBeforeUnmount(() => {
      touchTimer !== null && clearTimeout(touchTimer);
      unconfigureAnchorEl();
    });

    return {
      anchorEl,
      canShow,
      anchorEvents
    }
  }

  function useScrollTarget (
    props,
    configureScrollTarget
  ) {
    const localScrollTarget = vue.ref(null);
    let scrollFn;

    function changeScrollEvent (scrollTarget, fn) {
      const fnProp = `${ fn !== void 0 ? 'add' : 'remove' }EventListener`;
      const fnHandler = fn !== void 0 ? fn : scrollFn;

      if (scrollTarget !== window) {
        scrollTarget[ fnProp ]('scroll', fnHandler, listenOpts.passive);
      }

      window[ fnProp ]('scroll', fnHandler, listenOpts.passive);

      scrollFn = fn;
    }

    function unconfigureScrollTarget () {
      if (localScrollTarget.value !== null) {
        changeScrollEvent(localScrollTarget.value);
        localScrollTarget.value = null;
      }
    }

    const noParentEventWatcher = vue.watch(() => props.noParentEvent, () => {
      if (localScrollTarget.value !== null) {
        unconfigureScrollTarget();
        configureScrollTarget();
      }
    });

    vue.onBeforeUnmount(noParentEventWatcher);

    return {
      localScrollTarget,
      unconfigureScrollTarget,
      changeScrollEvent
    }
  }

  const useModelToggleProps = {
    modelValue: {
      type: Boolean,
      default: null
    },

    'onUpdate:modelValue': [ Function, Array ]
  };

  const useModelToggleEmits = [
    'beforeShow', 'show', 'beforeHide', 'hide'
  ];

  // handleShow/handleHide -> removeTick(), self (& emit show)

  function useModelToggle ({
    showing,
    canShow, // optional
    hideOnRouteChange, // optional
    handleShow, // optional
    handleHide, // optional
    processOnMount // optional
  }) {
    const vm = vue.getCurrentInstance();
    const { props, emit, proxy } = vm;

    let payload;

    function toggle (evt) {
      if (showing.value === true) {
        hide(evt);
      }
      else {
        show(evt);
      }
    }

    function show (evt) {
      if (
        props.disable === true
        || (evt !== void 0 && evt.qAnchorHandled === true)
        || (canShow !== void 0 && canShow(evt) !== true)
      ) {
        return
      }

      const listener = props[ 'onUpdate:modelValue' ] !== void 0;

      if (listener === true && false !== true) {
        emit('update:modelValue', true);
        payload = evt;
        vue.nextTick(() => {
          if (payload === evt) {
            payload = void 0;
          }
        });
      }

      if (props.modelValue === null || listener === false || false) {
        processShow(evt);
      }
    }

    function processShow (evt) {
      if (showing.value === true) {
        return
      }

      showing.value = true;

      emit('beforeShow', evt);

      if (handleShow !== void 0) {
        handleShow(evt);
      }
      else {
        emit('show', evt);
      }
    }

    function hide (evt) {
      if (props.disable === true) {
        return
      }

      const listener = props[ 'onUpdate:modelValue' ] !== void 0;

      if (listener === true && false !== true) {
        emit('update:modelValue', false);
        payload = evt;
        vue.nextTick(() => {
          if (payload === evt) {
            payload = void 0;
          }
        });
      }

      if (props.modelValue === null || listener === false || false) {
        processHide(evt);
      }
    }

    function processHide (evt) {
      if (showing.value === false) {
        return
      }

      showing.value = false;

      emit('beforeHide', evt);

      if (handleHide !== void 0) {
        handleHide(evt);
      }
      else {
        emit('hide', evt);
      }
    }

    function processModelChange (val) {
      if (props.disable === true && val === true) {
        if (props[ 'onUpdate:modelValue' ] !== void 0) {
          emit('update:modelValue', false);
        }
      }
      else if ((val === true) !== showing.value) {
        const fn = val === true ? processShow : processHide;
        fn(payload);
      }
    }

    vue.watch(() => props.modelValue, processModelChange);

    if (hideOnRouteChange !== void 0 && vmHasRouter(vm) === true) {
      vue.watch(() => proxy.$route.fullPath, () => {
        if (hideOnRouteChange.value === true && showing.value === true) {
          hide();
        }
      });
    }

    processOnMount === true && vue.onMounted(() => {
      processModelChange(props.modelValue);
    });

    // expose public methods
    const publicMethods = { show, hide, toggle };
    Object.assign(proxy, publicMethods);

    return publicMethods
  }

  let queue = [];
  let waitFlags = [];

  function clearFlag (flag) {
    waitFlags = waitFlags.filter(entry => entry !== flag);
  }

  function addFocusWaitFlag (flag) {
    clearFlag(flag);
    waitFlags.push(flag);
  }

  function removeFocusWaitFlag (flag) {
    clearFlag(flag);

    if (waitFlags.length === 0 && queue.length > 0) {
      // only call last focus handler (can't focus multiple things at once)
      queue[ queue.length - 1 ]();
      queue = [];
    }
  }

  function addFocusFn (fn) {
    if (waitFlags.length === 0) {
      fn();
    }
    else {
      queue.push(fn);
    }
  }

  function removeFocusFn (fn) {
    queue = queue.filter(entry => entry !== fn);
  }

  const nodesList = [];
  const portalTypeList = [];

  let portalIndex = 1;
  let target = document.body;

  function createGlobalNode (id, portalType) {
    const el = document.createElement('div');

    el.id = portalType !== void 0
      ? `q-portal--${ portalType }--${ portalIndex++ }`
      : id;

    if (globalConfig.globalNodes !== void 0) {
      const cls = globalConfig.globalNodes.class;
      if (cls !== void 0) {
        el.className = cls;
      }
    }

    target.appendChild(el);
    nodesList.push(el);
    portalTypeList.push(portalType);

    return el
  }

  function removeGlobalNode (el) {
    const nodeIndex = nodesList.indexOf(el);

    nodesList.splice(nodeIndex, 1);
    portalTypeList.splice(nodeIndex, 1);

    el.remove();
  }

  function changeGlobalNodesTarget (newTarget) {
    if (newTarget === target) {
      return
    }

    target = newTarget;

    if (
      target === document.body
      // or we have less than 2 dialogs:
      || portalTypeList.reduce((acc, type) => (type === 'dialog' ? acc + 1 : acc), 0) < 2
    ) {
      nodesList.forEach(node => {
        if (node.contains(target) === false) {
          target.appendChild(node);
        }
      });

      return
    }

    const lastDialogIndex = portalTypeList.lastIndexOf('dialog');

    for (let i = 0; i < nodesList.length; i++) {
      const el = nodesList[ i ];

      if (
        (i === lastDialogIndex || portalTypeList[ i ] !== 'dialog')
        && el.contains(target) === false
      ) {
        target.appendChild(el);
      }
    }
  }

  const portalProxyList = [];

  function getPortalProxy (el) {
    return portalProxyList.find(proxy =>
      proxy.contentEl !== null
      && proxy.contentEl.contains(el)
    )
  }

  function closePortalMenus (proxy, evt) {
    do {
      if (proxy.$options.name === 'QMenu') {
        proxy.hide(evt);

        // is this a point of separation?
        if (proxy.$props.separateClosePopup === true) {
          return getParentProxy(proxy)
        }
      }
      else if (proxy.__qPortal === true) {
        // treat it as point of separation if parent is QPopupProxy
        // (so mobile matches desktop behavior)
        // and hide it too
        const parent = getParentProxy(proxy);

        if (parent !== void 0 && parent.$options.name === 'QPopupProxy') {
          proxy.hide(evt);
          return parent
        }
        else {
          return proxy
        }
      }

      proxy = getParentProxy(proxy);
    } while (proxy !== void 0 && proxy !== null)
  }

  function closePortals (proxy, evt, depth) {
    while (depth !== 0 && proxy !== void 0 && proxy !== null) {
      if (proxy.__qPortal === true) {
        depth--;

        if (proxy.$options.name === 'QMenu') {
          proxy = closePortalMenus(proxy, evt);
          continue
        }

        proxy.hide(evt);
      }

      proxy = getParentProxy(proxy);
    }
  }

  function isOnGlobalDialog (vm) {
    vm = vm.parent;

    while (vm !== void 0 && vm !== null) {
      if (vm.type.name === 'QGlobalDialog') {
        return true
      }
      if (vm.type.name === 'QDialog' || vm.type.name === 'QMenu') {
        return false
      }

      vm = vm.parent;
    }

    return false
  }

  // Warning!
  // You MUST specify "inheritAttrs: false" in your component

  function usePortal (vm, innerRef, renderPortalContent, type) {
    // showing, including while in show/hide transition
    const portalIsActive = vue.ref(false);

    // showing & not in any show/hide transition
    const portalIsAccessible = vue.ref(false);

    let portalEl = null;
    const focusObj = {};
    const onGlobalDialog = type === 'dialog' && isOnGlobalDialog(vm);

    function showPortal (isReady) {
      if (isReady === true) {
        removeFocusWaitFlag(focusObj);
        portalIsAccessible.value = true;
        return
      }

      portalIsAccessible.value = false;

      if (portalIsActive.value === false) {
        if (onGlobalDialog === false && portalEl === null) {
          portalEl = createGlobalNode(false, type);
        }

        portalIsActive.value = true;

        // register portal
        portalProxyList.push(vm.proxy);

        addFocusWaitFlag(focusObj);
      }
    }

    function hidePortal (isReady) {
      portalIsAccessible.value = false;

      if (isReady !== true) { return }

      removeFocusWaitFlag(focusObj);
      portalIsActive.value = false;

      // unregister portal
      const index = portalProxyList.indexOf(vm.proxy);
      if (index !== -1) {
        portalProxyList.splice(index, 1);
      }

      if (portalEl !== null) {
        removeGlobalNode(portalEl);
        portalEl = null;
      }
    }

    vue.onUnmounted(() => { hidePortal(true); });

    // needed for portal vm detection
    vm.proxy.__qPortal = true;

    // public way of accessing the rendered content
    injectProp(vm.proxy, 'contentEl', () => innerRef.value);

    return {
      showPortal,
      hidePortal,

      portalIsActive,
      portalIsAccessible,

      renderPortal: () => (
        onGlobalDialog === true
          ? renderPortalContent()
          : (
              portalIsActive.value === true
                ? [ vue.h(vue.Teleport, { to: portalEl }, renderPortalContent()) ]
                : void 0
            )
      )
    }
  }

  const useTransitionProps = {
    transitionShow: {
      type: String,
      default: 'fade'
    },

    transitionHide: {
      type: String,
      default: 'fade'
    },

    transitionDuration: {
      type: [ String, Number ],
      default: 300
    }
  };

  function useTransition (props, defaultShowFn = () => {}, defaultHideFn = () => {}) {
    return {
      transitionProps: vue.computed(() => {
        const show = `q-transition--${ props.transitionShow || defaultShowFn() }`;
        const hide = `q-transition--${ props.transitionHide || defaultHideFn() }`;

        return {
          appear: true,

          enterFromClass: `${ show }-enter-from`,
          enterActiveClass: `${ show }-enter-active`,
          enterToClass: `${ show }-enter-to`,

          leaveFromClass: `${ hide }-leave-from`,
          leaveActiveClass: `${ hide }-leave-active`,
          leaveToClass: `${ hide }-leave-to`
        }
      }),

      transitionStyle: vue.computed(() => `--q-transition-duration: ${ props.transitionDuration }ms`)
    }
  }

  /*
   * Usage:
   *    registerTick(fn)
   *    removeTick()
   */

  function useTick () {
    let tickFn;
    const vm = vue.getCurrentInstance();

    function removeTick () {
      tickFn = void 0;
    }

    vue.onDeactivated(removeTick);
    vue.onBeforeUnmount(removeTick);

    return {
      removeTick,

      registerTick (fn) {
        tickFn = fn;

        vue.nextTick(() => {
          if (tickFn === fn) {
            // we also check if VM is destroyed, since if it
            // got to trigger one nextTick() we cannot stop it
            vmIsDestroyed(vm) === false && tickFn();
            tickFn = void 0;
          }
        });
      }
    }
  }

  /*
   * Usage:
   *    registerTimeout(fn[, delay])
   *    removeTimeout()
   */

  function useTimeout () {
    let timer = null;
    const vm = vue.getCurrentInstance();

    function removeTimeout () {
      if (timer !== null) {
        clearTimeout(timer);
        timer = null;
      }
    }

    vue.onDeactivated(removeTimeout);
    vue.onBeforeUnmount(removeTimeout);

    return {
      removeTimeout,

      registerTimeout (fn, delay) {
        removeTimeout();

        if (vmIsDestroyed(vm) === false) {
          timer = setTimeout(fn, delay);
        }
      }
    }
  }

  const scrollTargets = [ null, document, document.body, document.scrollingElement, document.documentElement ];

  function getScrollTarget (el, targetEl) {
    let target = getElement$1(targetEl);

    if (target === void 0) {
      if (el === void 0 || el === null) {
        return window
      }

      target = el.closest('.scroll,.scroll-y,.overflow-auto');
    }

    return scrollTargets.includes(target)
      ? window
      : target
  }

  function getScrollHeight (el) {
    return (el === window ? document.body : el).scrollHeight
  }

  function getScrollWidth (el) {
    return (el === window ? document.body : el).scrollWidth
  }

  function getVerticalScrollPosition (scrollTarget) {
    return scrollTarget === window
      ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0
      : scrollTarget.scrollTop
  }

  function getHorizontalScrollPosition (scrollTarget) {
    return scrollTarget === window
      ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0
      : scrollTarget.scrollLeft
  }

  function animVerticalScrollTo (el, to, duration = 0 /* , prevTime */) {
    const prevTime = arguments[ 3 ] === void 0 ? performance.now() : arguments[ 3 ];
    const pos = getVerticalScrollPosition(el);

    if (duration <= 0) {
      if (pos !== to) {
        setScroll$1(el, to);
      }
      return
    }

    requestAnimationFrame(nowTime => {
      const frameTime = nowTime - prevTime;
      const newPos = pos + (to - pos) / Math.max(frameTime, duration) * frameTime;
      setScroll$1(el, newPos);
      if (newPos !== to) {
        animVerticalScrollTo(el, to, duration - frameTime, nowTime);
      }
    });
  }

  function animHorizontalScrollTo (el, to, duration = 0 /* , prevTime */) {
    const prevTime = arguments[ 3 ] === void 0 ? performance.now() : arguments[ 3 ];
    const pos = getHorizontalScrollPosition(el);

    if (duration <= 0) {
      if (pos !== to) {
        setHorizontalScroll(el, to);
      }
      return
    }

    requestAnimationFrame(nowTime => {
      const frameTime = nowTime - prevTime;
      const newPos = pos + (to - pos) / Math.max(frameTime, duration) * frameTime;
      setHorizontalScroll(el, newPos);
      if (newPos !== to) {
        animHorizontalScrollTo(el, to, duration - frameTime, nowTime);
      }
    });
  }

  function setScroll$1 (scrollTarget, offset) {
    if (scrollTarget === window) {
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, offset);
      return
    }
    scrollTarget.scrollTop = offset;
  }

  function setHorizontalScroll (scrollTarget, offset) {
    if (scrollTarget === window) {
      window.scrollTo(offset, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
      return
    }
    scrollTarget.scrollLeft = offset;
  }

  function setVerticalScrollPosition (scrollTarget, offset, duration) {
    if (duration) {
      animVerticalScrollTo(scrollTarget, offset, duration);
      return
    }
    setScroll$1(scrollTarget, offset);
  }

  function setHorizontalScrollPosition (scrollTarget, offset, duration) {
    if (duration) {
      animHorizontalScrollTo(scrollTarget, offset, duration);
      return
    }
    setHorizontalScroll(scrollTarget, offset);
  }

  let size;
  function getScrollbarWidth () {
    if (size !== undefined) {
      return size
    }

    const
      inner = document.createElement('p'),
      outer = document.createElement('div');

    css(inner, {
      width: '100%',
      height: '200px'
    });
    css(outer, {
      position: 'absolute',
      top: '0px',
      left: '0px',
      visibility: 'hidden',
      width: '200px',
      height: '150px',
      overflow: 'hidden'
    });

    outer.appendChild(inner);

    document.body.appendChild(outer);

    const w1 = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    let w2 = inner.offsetWidth;

    if (w1 === w2) {
      w2 = outer.clientWidth;
    }

    outer.remove();
    size = w1 - w2;

    return size
  }

  function hasScrollbar (el, onY = true) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE) {
      return false
    }

    return onY
      ? (
          el.scrollHeight > el.clientHeight && (
            el.classList.contains('scroll')
            || el.classList.contains('overflow-auto')
            || [ 'auto', 'scroll' ].includes(window.getComputedStyle(el)[ 'overflow-y' ])
          )
        )
      : (
          el.scrollWidth > el.clientWidth && (
            el.classList.contains('scroll')
            || el.classList.contains('overflow-auto')
            || [ 'auto', 'scroll' ].includes(window.getComputedStyle(el)[ 'overflow-x' ])
          )
        )
  }

  var scroll = {
    getScrollTarget,

    getScrollHeight,
    getScrollWidth,

    getVerticalScrollPosition,
    getHorizontalScrollPosition,

    animVerticalScrollTo,
    animHorizontalScrollTo,

    setVerticalScrollPosition,
    setHorizontalScrollPosition,

    getScrollbarWidth,
    hasScrollbar
  };

  const handlers$1 = [];
  let escDown;

  function onKeydown (evt) {
    escDown = evt.keyCode === 27;
  }

  function onBlur () {
    if (escDown === true) {
      escDown = false;
    }
  }

  function onKeyup (evt) {
    if (escDown === true) {
      escDown = false;

      if (isKeyCode(evt, 27) === true) {
        handlers$1[ handlers$1.length - 1 ](evt);
      }
    }
  }

  function update$4 (action) {
    window[ action ]('keydown', onKeydown);
    window[ action ]('blur', onBlur);
    window[ action ]('keyup', onKeyup);
    escDown = false;
  }

  function addEscapeKey (fn) {
    if (client.is.desktop === true) {
      handlers$1.push(fn);

      if (handlers$1.length === 1) {
        update$4('addEventListener');
      }
    }
  }

  function removeEscapeKey (fn) {
    const index = handlers$1.indexOf(fn);
    if (index > -1) {
      handlers$1.splice(index, 1);

      if (handlers$1.length === 0) {
        update$4('removeEventListener');
      }
    }
  }

  const handlers = [];

  function trigger$1 (e) {
    handlers[ handlers.length - 1 ](e);
  }

  function addFocusout (fn) {
    if (client.is.desktop === true) {
      handlers.push(fn);

      if (handlers.length === 1) {
        document.body.addEventListener('focusin', trigger$1);
      }
    }
  }

  function removeFocusout (fn) {
    const index = handlers.indexOf(fn);
    if (index > -1) {
      handlers.splice(index, 1);

      if (handlers.length === 0) {
        document.body.removeEventListener('focusin', trigger$1);
      }
    }
  }

  const
    { notPassiveCapture } = listenOpts,
    registeredList = [];

  function globalHandler (evt) {

    const target = evt.target;

    if (
      target === void 0
      || target.nodeType === 8
      || target.classList.contains('no-pointer-events') === true
    ) {
      return
    }

    // check last portal vm if it's
    // a QDialog and not in seamless mode
    let portalIndex = portalProxyList.length - 1;

    while (portalIndex >= 0) {
      const proxy = portalProxyList[ portalIndex ].$;

      if (proxy.type.name !== 'QDialog') {
        break
      }

      if (proxy.props.seamless !== true) {
        return
      }

      portalIndex--;
    }

    for (let i = registeredList.length - 1; i >= 0; i--) {
      const state = registeredList[ i ];

      if (
        (
          state.anchorEl.value === null
          || state.anchorEl.value.contains(target) === false
        )
        && (
          target === document.body
          || (
            state.innerRef.value !== null
            && state.innerRef.value.contains(target) === false
          )
        )
      ) {
        // mark the event as being processed by clickOutside
        // used to prevent refocus after menu close
        evt.qClickOutside = true;
        state.onClickOutside(evt);
      }
      else {
        return
      }
    }
  }

  function addClickOutside (clickOutsideProps) {
    registeredList.push(clickOutsideProps);

    if (registeredList.length === 1) {
      document.addEventListener('mousedown', globalHandler, notPassiveCapture);
      document.addEventListener('touchstart', globalHandler, notPassiveCapture);
    }
  }

  function removeClickOutside (clickOutsideProps) {
    const index = registeredList.findIndex(h => h === clickOutsideProps);

    if (index > -1) {
      registeredList.splice(index, 1);

      if (registeredList.length === 0) {

        document.removeEventListener('mousedown', globalHandler, notPassiveCapture);
        document.removeEventListener('touchstart', globalHandler, notPassiveCapture);
      }
    }
  }

  let vpLeft, vpTop;

  function validatePosition (pos) {
    const parts = pos.split(' ');
    if (parts.length !== 2) {
      return false
    }
    if ([ 'top', 'center', 'bottom' ].includes(parts[ 0 ]) !== true) {
      console.error('Anchor/Self position must start with one of top/center/bottom');
      return false
    }
    if ([ 'left', 'middle', 'right', 'start', 'end' ].includes(parts[ 1 ]) !== true) {
      console.error('Anchor/Self position must end with one of left/middle/right/start/end');
      return false
    }
    return true
  }

  function validateOffset (val) {
    if (!val) { return true }
    if (val.length !== 2) { return false }
    if (typeof val[ 0 ] !== 'number' || typeof val[ 1 ] !== 'number') {
      return false
    }
    return true
  }

  const horizontalPos = {
    'start#ltr': 'left',
    'start#rtl': 'right',
    'end#ltr': 'right',
    'end#rtl': 'left'
  }

  ;[ 'left', 'middle', 'right' ].forEach(pos => {
    horizontalPos[ `${ pos }#ltr` ] = pos;
    horizontalPos[ `${ pos }#rtl` ] = pos;
  });

  function parsePosition (pos, rtl) {
    const parts = pos.split(' ');
    return {
      vertical: parts[ 0 ],
      horizontal: horizontalPos[ `${ parts[ 1 ] }#${ rtl === true ? 'rtl' : 'ltr' }` ]
    }
  }

  function getAnchorProps (el, offset) {
    let { top, left, right, bottom, width, height } = el.getBoundingClientRect();

    if (offset !== void 0) {
      top -= offset[ 1 ];
      left -= offset[ 0 ];
      bottom += offset[ 1 ];
      right += offset[ 0 ];

      width += offset[ 0 ];
      height += offset[ 1 ];
    }

    return {
      top, bottom, height,
      left, right, width,
      middle: left + (right - left) / 2,
      center: top + (bottom - top) / 2
    }
  }

  function getAbsoluteAnchorProps (el, absoluteOffset, offset) {
    let { top, left } = el.getBoundingClientRect();

    top += absoluteOffset.top;
    left += absoluteOffset.left;

    if (offset !== void 0) {
      top += offset[ 1 ];
      left += offset[ 0 ];
    }

    return {
      top, bottom: top + 1, height: 1,
      left, right: left + 1, width: 1,
      middle: left,
      center: top
    }
  }

  function getTargetProps (el) {
    return {
      top: 0,
      center: el.offsetHeight / 2,
      bottom: el.offsetHeight,
      left: 0,
      middle: el.offsetWidth / 2,
      right: el.offsetWidth
    }
  }

  function getTopLeftProps (anchorProps, targetProps, cfg) {
    return {
      top: anchorProps[ cfg.anchorOrigin.vertical ] - targetProps[ cfg.selfOrigin.vertical ],
      left: anchorProps[ cfg.anchorOrigin.horizontal ] - targetProps[ cfg.selfOrigin.horizontal ]
    }
  }

  // cfg: { el, anchorEl, anchorOrigin, selfOrigin, offset, absoluteOffset, cover, fit, maxHeight, maxWidth }
  function setPosition (cfg) {
    if (client.is.ios === true && window.visualViewport !== void 0) {
      // uses the q-position-engine CSS class

      const el = document.body.style;
      const { offsetLeft: left, offsetTop: top } = window.visualViewport;

      if (left !== vpLeft) {
        el.setProperty('--q-pe-left', left + 'px');
        vpLeft = left;
      }
      if (top !== vpTop) {
        el.setProperty('--q-pe-top', top + 'px');
        vpTop = top;
      }
    }

    // scroll position might change
    // if max-height/-width changes, so we
    // need to restore it after we calculate
    // the new positioning
    const { scrollLeft, scrollTop } = cfg.el;

    const anchorProps = cfg.absoluteOffset === void 0
      ? getAnchorProps(cfg.anchorEl, cfg.cover === true ? [ 0, 0 ] : cfg.offset)
      : getAbsoluteAnchorProps(cfg.anchorEl, cfg.absoluteOffset, cfg.offset);

    let elStyle = {
      maxHeight: cfg.maxHeight,
      maxWidth: cfg.maxWidth,
      visibility: 'visible'
    };

    if (cfg.fit === true || cfg.cover === true) {
      elStyle.minWidth = anchorProps.width + 'px';
      if (cfg.cover === true) {
        elStyle.minHeight = anchorProps.height + 'px';
      }
    }

    Object.assign(cfg.el.style, elStyle);

    const targetProps = getTargetProps(cfg.el);
    let props = getTopLeftProps(anchorProps, targetProps, cfg);

    if (cfg.absoluteOffset === void 0 || cfg.offset === void 0) {
      applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);
    }
    else { // we have touch position or context menu with offset
      const { top, left } = props; // cache initial values

      // apply initial boundaries
      applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);

      let hasChanged = false;

      // did it flip vertically?
      if (props.top !== top) {
        hasChanged = true;
        const offsetY = 2 * cfg.offset[ 1 ];
        anchorProps.center = anchorProps.top -= offsetY;
        anchorProps.bottom -= offsetY + 2;
      }

      // did it flip horizontally?
      if (props.left !== left) {
        hasChanged = true;
        const offsetX = 2 * cfg.offset[ 0 ];
        anchorProps.middle = anchorProps.left -= offsetX;
        anchorProps.right -= offsetX + 2;
      }

      if (hasChanged === true) {
        // re-calculate props with the new anchor
        props = getTopLeftProps(anchorProps, targetProps, cfg);

        // and re-apply boundaries
        applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);
      }
    }

    elStyle = {
      top: props.top + 'px',
      left: props.left + 'px'
    };

    if (props.maxHeight !== void 0) {
      elStyle.maxHeight = props.maxHeight + 'px';

      if (anchorProps.height > props.maxHeight) {
        elStyle.minHeight = elStyle.maxHeight;
      }
    }
    if (props.maxWidth !== void 0) {
      elStyle.maxWidth = props.maxWidth + 'px';

      if (anchorProps.width > props.maxWidth) {
        elStyle.minWidth = elStyle.maxWidth;
      }
    }

    Object.assign(cfg.el.style, elStyle);

    // restore scroll position
    if (cfg.el.scrollTop !== scrollTop) {
      cfg.el.scrollTop = scrollTop;
    }
    if (cfg.el.scrollLeft !== scrollLeft) {
      cfg.el.scrollLeft = scrollLeft;
    }
  }

  function applyBoundaries (props, anchorProps, targetProps, anchorOrigin, selfOrigin) {
    const
      currentHeight = targetProps.bottom,
      currentWidth = targetProps.right,
      margin = getScrollbarWidth(),
      innerHeight = window.innerHeight - margin,
      innerWidth = document.body.clientWidth;

    if (props.top < 0 || props.top + currentHeight > innerHeight) {
      if (selfOrigin.vertical === 'center') {
        props.top = anchorProps[ anchorOrigin.vertical ] > innerHeight / 2
          ? Math.max(0, innerHeight - currentHeight)
          : 0;
        props.maxHeight = Math.min(currentHeight, innerHeight);
      }
      else if (anchorProps[ anchorOrigin.vertical ] > innerHeight / 2) {
        const anchorY = Math.min(
          innerHeight,
          anchorOrigin.vertical === 'center'
            ? anchorProps.center
            : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top)
        );
        props.maxHeight = Math.min(currentHeight, anchorY);
        props.top = Math.max(0, anchorY - currentHeight);
      }
      else {
        props.top = Math.max(0, anchorOrigin.vertical === 'center'
          ? anchorProps.center
          : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom)
        );
        props.maxHeight = Math.min(currentHeight, innerHeight - props.top);
      }
    }

    if (props.left < 0 || props.left + currentWidth > innerWidth) {
      props.maxWidth = Math.min(currentWidth, innerWidth);
      if (selfOrigin.horizontal === 'middle') {
        props.left = anchorProps[ anchorOrigin.horizontal ] > innerWidth / 2
          ? Math.max(0, innerWidth - currentWidth)
          : 0;
      }
      else if (anchorProps[ anchorOrigin.horizontal ] > innerWidth / 2) {
        const anchorX = Math.min(
          innerWidth,
          anchorOrigin.horizontal === 'middle'
            ? anchorProps.middle
            : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left)
        );
        props.maxWidth = Math.min(currentWidth, anchorX);
        props.left = Math.max(0, anchorX - props.maxWidth);
      }
      else {
        props.left = Math.max(0, anchorOrigin.horizontal === 'middle'
          ? anchorProps.middle
          : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right)
        );
        props.maxWidth = Math.min(currentWidth, innerWidth - props.left);
      }
    }
  }

  var QMenu = createComponent({
    name: 'QMenu',

    inheritAttrs: false,

    props: {
      ...useAnchorProps,
      ...useModelToggleProps,
      ...useDarkProps,
      ...useTransitionProps,

      persistent: Boolean,
      autoClose: Boolean,
      separateClosePopup: Boolean,

      noRouteDismiss: Boolean,
      noRefocus: Boolean,
      noFocus: Boolean,

      fit: Boolean,
      cover: Boolean,

      square: Boolean,

      anchor: {
        type: String,
        validator: validatePosition
      },
      self: {
        type: String,
        validator: validatePosition
      },
      offset: {
        type: Array,
        validator: validateOffset
      },

      scrollTarget: {
        default: void 0
      },

      touchPosition: Boolean,

      maxHeight: {
        type: String,
        default: null
      },
      maxWidth: {
        type: String,
        default: null
      }
    },

    emits: [
      ...useModelToggleEmits,
      'click', 'escapeKey'
    ],

    setup (props, { slots, emit, attrs }) {
      let refocusTarget = null, absoluteOffset, unwatchPosition, avoidAutoClose;

      const vm = vue.getCurrentInstance();
      const { proxy } = vm;
      const { $q } = proxy;

      const innerRef = vue.ref(null);
      const showing = vue.ref(false);

      const hideOnRouteChange = vue.computed(() =>
        props.persistent !== true
        && props.noRouteDismiss !== true
      );

      const isDark = useDark(props, $q);
      const { registerTick, removeTick } = useTick();
      const { registerTimeout } = useTimeout();
      const { transitionProps, transitionStyle } = useTransition(props);
      const { localScrollTarget, changeScrollEvent, unconfigureScrollTarget } = useScrollTarget(props, configureScrollTarget);

      const { anchorEl, canShow } = useAnchor({ showing });

      const { hide } = useModelToggle({
        showing, canShow, handleShow, handleHide,
        hideOnRouteChange,
        processOnMount: true
      });

      const { showPortal, hidePortal, renderPortal } = usePortal(vm, innerRef, renderPortalContent, 'menu');

      const clickOutsideProps = {
        anchorEl,
        innerRef,
        onClickOutside (e) {
          if (props.persistent !== true && showing.value === true) {
            hide(e);

            if (
              // always prevent touch event
              e.type === 'touchstart'
              // prevent click if it's on a dialog backdrop
              || e.target.classList.contains('q-dialog__backdrop')
            ) {
              stopAndPrevent(e);
            }

            return true
          }
        }
      };

      const anchorOrigin = vue.computed(() =>
        parsePosition(
          props.anchor || (
            props.cover === true ? 'center middle' : 'bottom start'
          ),
          $q.lang.rtl
        )
      );

      const selfOrigin = vue.computed(() => (
        props.cover === true
          ? anchorOrigin.value
          : parsePosition(props.self || 'top start', $q.lang.rtl)
      ));

      const menuClass = vue.computed(() =>
        (props.square === true ? ' q-menu--square' : '')
        + (isDark.value === true ? ' q-menu--dark q-dark' : '')
      );

      const onEvents = vue.computed(() => (
        props.autoClose === true
          ? { onClick: onAutoClose }
          : {}
      ));

      const handlesFocus = vue.computed(() =>
        showing.value === true && props.persistent !== true
      );

      vue.watch(handlesFocus, val => {
        if (val === true) {
          addEscapeKey(onEscapeKey);
          addClickOutside(clickOutsideProps);
        }
        else {
          removeEscapeKey(onEscapeKey);
          removeClickOutside(clickOutsideProps);
        }
      });

      function focus () {
        addFocusFn(() => {
          let node = innerRef.value;

          if (node && node.contains(document.activeElement) !== true) {
            node = node.querySelector('[autofocus][tabindex], [data-autofocus][tabindex]')
              || node.querySelector('[autofocus] [tabindex], [data-autofocus] [tabindex]')
              || node.querySelector('[autofocus], [data-autofocus]')
              || node;
            node.focus({ preventScroll: true });
          }
        });
      }

      function handleShow (evt) {
        refocusTarget = props.noRefocus === false
          ? document.activeElement
          : null;

        addFocusout(onFocusout);

        showPortal();
        configureScrollTarget();

        absoluteOffset = void 0;

        if (evt !== void 0 && (props.touchPosition || props.contextMenu)) {
          const pos = position(evt);

          if (pos.left !== void 0) {
            const { top, left } = anchorEl.value.getBoundingClientRect();
            absoluteOffset = { left: pos.left - left, top: pos.top - top };
          }
        }

        if (unwatchPosition === void 0) {
          unwatchPosition = vue.watch(
            () => $q.screen.width + '|' + $q.screen.height + '|' + props.self + '|' + props.anchor + '|' + $q.lang.rtl,
            updatePosition
          );
        }

        if (props.noFocus !== true) {
          document.activeElement.blur();
        }

        // should removeTick() if this gets removed
        registerTick(() => {
          updatePosition();
          props.noFocus !== true && focus();
        });

        // should removeTimeout() if this gets removed
        registerTimeout(() => {
          // required in order to avoid the "double-tap needed" issue
          if ($q.platform.is.ios === true) {
            // if auto-close, then this click should
            // not close the menu
            avoidAutoClose = props.autoClose;
            innerRef.value.click();
          }

          updatePosition();
          showPortal(true); // done showing portal
          emit('show', evt);
        }, props.transitionDuration);
      }

      function handleHide (evt) {
        removeTick();
        hidePortal();

        anchorCleanup(true);

        if (
          refocusTarget !== null
          && (
            // menu was hidden from code or ESC plugin
            evt === void 0
            // menu was not closed from a mouse or touch clickOutside
            || evt.qClickOutside !== true
          )
        ) {
          ((evt && evt.type.indexOf('key') === 0
            ? refocusTarget.closest('[tabindex]:not([tabindex^="-"])')
            : void 0
          ) || refocusTarget).focus();
          refocusTarget = null;
        }

        // should removeTimeout() if this gets removed
        registerTimeout(() => {
          hidePortal(true); // done hiding, now destroy
          emit('hide', evt);
        }, props.transitionDuration);
      }

      function anchorCleanup (hiding) {
        absoluteOffset = void 0;

        if (unwatchPosition !== void 0) {
          unwatchPosition();
          unwatchPosition = void 0;
        }

        if (hiding === true || showing.value === true) {
          removeFocusout(onFocusout);
          unconfigureScrollTarget();
          removeClickOutside(clickOutsideProps);
          removeEscapeKey(onEscapeKey);
        }

        if (hiding !== true) {
          refocusTarget = null;
        }
      }

      function configureScrollTarget () {
        if (anchorEl.value !== null || props.scrollTarget !== void 0) {
          localScrollTarget.value = getScrollTarget(anchorEl.value, props.scrollTarget);
          changeScrollEvent(localScrollTarget.value, updatePosition);
        }
      }

      function onAutoClose (e) {
        // if auto-close, then the ios double-tap fix which
        // issues a click should not close the menu
        if (avoidAutoClose !== true) {
          closePortalMenus(proxy, e);
          emit('click', e);
        }
        else {
          avoidAutoClose = false;
        }
      }

      function onFocusout (evt) {
        // the focus is not in a vue child component
        if (
          handlesFocus.value === true
          && props.noFocus !== true
          && childHasFocus(innerRef.value, evt.target) !== true
        ) {
          focus();
        }
      }

      function onEscapeKey (evt) {
        emit('escapeKey');
        hide(evt);
      }

      function updatePosition () {
        const el = innerRef.value;

        if (el === null || anchorEl.value === null) {
          return
        }

        setPosition({
          el,
          offset: props.offset,
          anchorEl: anchorEl.value,
          anchorOrigin: anchorOrigin.value,
          selfOrigin: selfOrigin.value,
          absoluteOffset,
          fit: props.fit,
          cover: props.cover,
          maxHeight: props.maxHeight,
          maxWidth: props.maxWidth
        });
      }

      function renderPortalContent () {
        return vue.h(
          vue.Transition,
          transitionProps.value,
          () => (
            showing.value === true
              ? vue.h('div', {
                role: 'menu',
                ...attrs,
                ref: innerRef,
                tabindex: -1,
                class: [
                  'q-menu q-position-engine scroll' + menuClass.value,
                  attrs.class
                ],
                style: [
                  attrs.style,
                  transitionStyle.value
                ],
                ...onEvents.value
              }, hSlot(slots.default))
              : null
          )
        )
      }

      vue.onBeforeUnmount(anchorCleanup);

      // expose public methods
      Object.assign(proxy, { focus, updatePosition });

      return renderPortal
    }
  });

  /**
   * Based on the work of https://github.com/jchook/uuid-random
   */

  let
    buf,
    bufIdx = 0;
  const hexBytes = new Array(256);

  // Pre-calculate toString(16) for speed
  for (let i = 0; i < 256; i++) {
    hexBytes[ i ] = (i + 0x100).toString(16).substring(1);
  }

  // Use best available PRNG
  const randomBytes = (() => {
    // Node & Browser support
    const lib = typeof crypto !== 'undefined'
      ? crypto
      : (
          typeof window !== 'undefined'
            ? window.crypto || window.msCrypto
            : void 0
        );

    if (lib !== void 0) {
      if (lib.randomBytes !== void 0) {
        return lib.randomBytes
      }
      if (lib.getRandomValues !== void 0) {
        return n => {
          const bytes = new Uint8Array(n);
          lib.getRandomValues(bytes);
          return bytes
        }
      }
    }

    return n => {
      const r = [];
      for (let i = n; i > 0; i--) {
        r.push(Math.floor(Math.random() * 256));
      }
      return r
    }
  })();

  // Buffer random numbers for speed
  // Reduce memory usage by decreasing this number (min 16)
  // or improve speed by increasing this number (try 16384)
  const BUFFER_SIZE = 4096;

  function uid$3 () {
    // Buffer some random bytes for speed
    if (buf === void 0 || (bufIdx + 16 > BUFFER_SIZE)) {
      bufIdx = 0;
      buf = randomBytes(BUFFER_SIZE);
    }

    const b = Array.prototype.slice.call(buf, bufIdx, (bufIdx += 16));
    b[ 6 ] = (b[ 6 ] & 0x0f) | 0x40;
    b[ 8 ] = (b[ 8 ] & 0x3f) | 0x80;

    return hexBytes[ b[ 0 ] ] + hexBytes[ b[ 1 ] ]
      + hexBytes[ b[ 2 ] ] + hexBytes[ b[ 3 ] ] + '-'
      + hexBytes[ b[ 4 ] ] + hexBytes[ b[ 5 ] ] + '-'
      + hexBytes[ b[ 6 ] ] + hexBytes[ b[ 7 ] ] + '-'
      + hexBytes[ b[ 8 ] ] + hexBytes[ b[ 9 ] ] + '-'
      + hexBytes[ b[ 10 ] ] + hexBytes[ b[ 11 ] ]
      + hexBytes[ b[ 12 ] ] + hexBytes[ b[ 13 ] ]
      + hexBytes[ b[ 14 ] ] + hexBytes[ b[ 15 ] ]
  }

  const btnPropsList = Object.keys(useBtnProps);

  const passBtnProps = props => btnPropsList.reduce(
    (acc, key) => {
      const val = props[ key ];
      if (val !== void 0) {
        acc[ key ] = val;
      }
      return acc
    },
    {}
  );

  var QBtnDropdown = createComponent({
    name: 'QBtnDropdown',

    props: {
      ...useBtnProps,
      ...useTransitionProps,

      modelValue: Boolean,
      split: Boolean,
      dropdownIcon: String,

      contentClass: [ Array, String, Object ],
      contentStyle: [ Array, String, Object ],

      cover: Boolean,
      persistent: Boolean,
      noRouteDismiss: Boolean,
      autoClose: Boolean,

      menuAnchor: {
        type: String,
        default: 'bottom end'
      },
      menuSelf: {
        type: String,
        default: 'top end'
      },
      menuOffset: Array,

      disableMainBtn: Boolean,
      disableDropdown: Boolean,

      noIconAnimation: Boolean,

      toggleAriaLabel: String
    },

    emits: [ 'update:modelValue', 'click', 'beforeShow', 'show', 'beforeHide', 'hide' ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();

      const showing = vue.ref(props.modelValue);
      const menuRef = vue.ref(null);
      const targetUid = uid$3();

      const ariaAttrs = vue.computed(() => {
        const acc = {
          'aria-expanded': showing.value === true ? 'true' : 'false',
          'aria-haspopup': 'true',
          'aria-controls': targetUid,
          'aria-label': props.toggleAriaLabel || proxy.$q.lang.label[ showing.value === true ? 'collapse' : 'expand' ](props.label)
        };

        if (
          props.disable === true
          || (
            (props.split === false && props.disableMainBtn === true)
            || props.disableDropdown === true
          )
        ) {
          acc[ 'aria-disabled' ] = 'true';
        }

        return acc
      });

      const iconClass = vue.computed(() =>
        'q-btn-dropdown__arrow'
        + (showing.value === true && props.noIconAnimation === false ? ' rotate-180' : '')
        + (props.split === false ? ' q-btn-dropdown__arrow-container' : '')
      );

      const btnDesignAttr = vue.computed(() => getBtnDesignAttr(props));
      const btnProps = vue.computed(() => passBtnProps(props));

      vue.watch(() => props.modelValue, val => {
        menuRef.value !== null && menuRef.value[ val ? 'show' : 'hide' ]();
      });

      vue.watch(() => props.split, hide);

      function onBeforeShow (e) {
        showing.value = true;
        emit('beforeShow', e);
      }

      function onShow (e) {
        emit('show', e);
        emit('update:modelValue', true);
      }

      function onBeforeHide (e) {
        showing.value = false;
        emit('beforeHide', e);
      }

      function onHide (e) {
        emit('hide', e);
        emit('update:modelValue', false);
      }

      function onClick (e) {
        emit('click', e);
      }

      function onClickHide (e) {
        stop(e);
        hide();
        emit('click', e);
      }

      function toggle (evt) {
        menuRef.value !== null && menuRef.value.toggle(evt);
      }

      function show (evt) {
        menuRef.value !== null && menuRef.value.show(evt);
      }

      function hide (evt) {
        menuRef.value !== null && menuRef.value.hide(evt);
      }

      // expose public methods
      Object.assign(proxy, {
        show, hide, toggle
      });

      vue.onMounted(() => {
        props.modelValue === true && show();
      });

      return () => {
        const Arrow = [
          vue.h(QIcon, {
            class: iconClass.value,
            name: props.dropdownIcon || proxy.$q.iconSet.arrow.dropdown
          })
        ];

        props.disableDropdown !== true && Arrow.push(
          vue.h(QMenu, {
            ref: menuRef,
            id: targetUid,
            class: props.contentClass,
            style: props.contentStyle,
            cover: props.cover,
            fit: true,
            persistent: props.persistent,
            noRouteDismiss: props.noRouteDismiss,
            autoClose: props.autoClose,
            anchor: props.menuAnchor,
            self: props.menuSelf,
            offset: props.menuOffset,
            separateClosePopup: true,
            transitionShow: props.transitionShow,
            transitionHide: props.transitionHide,
            transitionDuration: props.transitionDuration,
            onBeforeShow,
            onShow,
            onBeforeHide,
            onHide
          }, slots.default)
        );

        if (props.split === false) {
          return vue.h(QBtn, {
            class: 'q-btn-dropdown q-btn-dropdown--simple',
            ...btnProps.value,
            ...ariaAttrs.value,
            disable: props.disable === true || props.disableMainBtn === true,
            noWrap: true,
            round: false,
            onClick
          }, {
            default: () => hSlot(slots.label, []).concat(Arrow),
            loading: slots.loading
          })
        }

        return vue.h(QBtnGroup, {
          class: 'q-btn-dropdown q-btn-dropdown--split no-wrap q-btn-item',
          rounded: props.rounded,
          square: props.square,
          ...btnDesignAttr.value,
          glossy: props.glossy,
          stretch: props.stretch
        }, () => [
          vue.h(QBtn, {
            class: 'q-btn-dropdown--current',
            ...btnProps.value,
            disable: props.disable === true || props.disableMainBtn === true,
            noWrap: true,
            round: false,
            onClick: onClickHide
          }, {
            default: slots.label,
            loading: slots.loading
          }),

          vue.h(QBtn, {
            class: 'q-btn-dropdown__arrow-container q-anchor--skip',
            ...ariaAttrs.value,
            ...btnDesignAttr.value,
            disable: props.disable === true || props.disableDropdown === true,
            rounded: props.rounded,
            color: props.color,
            textColor: props.textColor,
            dense: props.dense,
            size: props.size,
            padding: props.padding,
            ripple: props.ripple
          }, () => Arrow)
        ])
      }
    }
  });

  const useFormProps = {
    name: String
  };

  function useFormAttrs (props) {
    return vue.computed(() => ({
      type: 'hidden',
      name: props.name,
      value: props.modelValue
    }))
  }

  function useFormInject (formAttrs = {}) {
    return (child, action, className) => {
      child[ action ](
        vue.h('input', {
          class: 'hidden' + (className || ''),
          ...formAttrs.value
        })
      );
    }
  }

  function useFormInputNameAttr (props) {
    return vue.computed(() => props.name || props.for)
  }

  var QBtnToggle = createComponent({
    name: 'QBtnToggle',

    props: {
      ...useFormProps,

      modelValue: {
        required: true
      },

      options: {
        type: Array,
        required: true,
        validator: v => v.every(
          opt => ('label' in opt || 'icon' in opt || 'slot' in opt) && 'value' in opt
        )
      },

      // To avoid seeing the active raise shadow through
      // the transparent button, give it a color (even white)
      color: String,
      textColor: String,
      toggleColor: {
        type: String,
        default: 'primary'
      },
      toggleTextColor: String,

      outline: Boolean,
      flat: Boolean,
      unelevated: Boolean,
      rounded: Boolean,
      push: Boolean,
      glossy: Boolean,

      size: String,
      padding: String,

      noCaps: Boolean,
      noWrap: Boolean,
      dense: Boolean,
      readonly: Boolean,
      disable: Boolean,

      stack: Boolean,
      stretch: Boolean,

      spread: Boolean,

      clearable: Boolean,

      ripple: {
        type: [ Boolean, Object ],
        default: true
      }
    },

    emits: [ 'update:modelValue', 'clear', 'click' ],

    setup (props, { slots, emit }) {
      const hasActiveValue = vue.computed(() =>
        props.options.find(opt => opt.value === props.modelValue) !== void 0
      );

      const formAttrs = vue.computed(() => ({
        type: 'hidden',
        name: props.name,
        value: props.modelValue
      }));

      const injectFormInput = useFormInject(formAttrs);

      const btnDesignAttr = vue.computed(() => getBtnDesignAttr(props));

      const btnOptionDesign = vue.computed(() => ({
        rounded: props.rounded,
        dense: props.dense,
        ...btnDesignAttr.value
      }));

      const btnOptions = vue.computed(() => props.options.map((item, i) => {
        const { attrs, value, slot, ...opt } = item;

        return {
          slot,
          props: {
            key: i,

            'aria-pressed': value === props.modelValue ? 'true' : 'false',
            ...attrs,
            ...opt,
            ...btnOptionDesign.value,

            disable: props.disable === true || opt.disable === true,

            // Options that come from the button specific options first, then from general props
            color: value === props.modelValue
              ? mergeOpt(opt, 'toggleColor')
              : mergeOpt(opt, 'color'),
            textColor: value === props.modelValue
              ? mergeOpt(opt, 'toggleTextColor')
              : mergeOpt(opt, 'textColor'),
            noCaps: mergeOpt(opt, 'noCaps') === true,
            noWrap: mergeOpt(opt, 'noWrap') === true,

            size: mergeOpt(opt, 'size'),
            padding: mergeOpt(opt, 'padding'),
            ripple: mergeOpt(opt, 'ripple'),
            stack: mergeOpt(opt, 'stack') === true,
            stretch: mergeOpt(opt, 'stretch') === true,

            onClick (e) { set(value, item, e); }
          }
        }
      }));

      function set (value, opt, e) {
        if (props.readonly !== true) {
          if (props.modelValue === value) {
            if (props.clearable === true) {
              emit('update:modelValue', null, null);
              emit('clear');
            }
          }
          else {
            emit('update:modelValue', value, opt);
          }

          emit('click', e);
        }
      }

      function mergeOpt (opt, key) {
        return opt[ key ] === void 0 ? props[ key ] : opt[ key ]
      }

      function getContent () {
        const child = btnOptions.value.map(opt => {
          return vue.h(QBtn, opt.props, opt.slot !== void 0 ? slots[ opt.slot ] : void 0)
        });

        if (props.name !== void 0 && props.disable !== true && hasActiveValue.value === true) {
          injectFormInput(child, 'push');
        }

        return hMergeSlot(slots.default, child)
      }

      return () => vue.h(QBtnGroup, {
        class: 'q-btn-toggle',
        ...btnDesignAttr.value,
        rounded: props.rounded,
        stretch: props.stretch,
        glossy: props.glossy,
        spread: props.spread
      }, getContent)
    }
  });

  var QCard = createComponent({
    name: 'QCard',

    props: {
      ...useDarkProps,

      tag: {
        type: String,
        default: 'div'
      },

      square: Boolean,
      flat: Boolean,
      bordered: Boolean
    },

    setup (props, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const isDark = useDark(props, $q);

      const classes = vue.computed(() =>
        'q-card'
        + (isDark.value === true ? ' q-card--dark q-dark' : '')
        + (props.bordered === true ? ' q-card--bordered' : '')
        + (props.square === true ? ' q-card--square no-border-radius' : '')
        + (props.flat === true ? ' q-card--flat no-shadow' : '')
      );

      return () => vue.h(props.tag, { class: classes.value }, hSlot(slots.default))
    }
  });

  var QCardSection = createComponent({
    name: 'QCardSection',

    props: {
      tag: {
        type: String,
        default: 'div'
      },

      horizontal: Boolean
    },

    setup (props, { slots }) {
      const classes = vue.computed(() =>
        'q-card__section'
        + ` q-card__section--${ props.horizontal === true ? 'horiz row no-wrap' : 'vert' }`
      );

      return () => vue.h(props.tag, { class: classes.value }, hSlot(slots.default))
    }
  });

  var QCardActions = createComponent({
    name: 'QCardActions',

    props: {
      ...useAlignProps,
      vertical: Boolean
    },

    setup (props, { slots }) {
      const alignClass = useAlign(props);

      const classes = vue.computed(() =>
        `q-card__actions ${ alignClass.value }`
        + ` q-card__actions--${ props.vertical === true ? 'vert column' : 'horiz row' }`
      );

      return () => vue.h('div', { class: classes.value }, hSlot(slots.default))
    }
  });

  const modifiersAll = {
    left: true,
    right: true,
    up: true,
    down: true,
    horizontal: true,
    vertical: true
  };

  const directionList = Object.keys(modifiersAll);

  modifiersAll.all = true;

  function getModifierDirections (mod) {
    const dir = {};

    for (const direction of directionList) {
      if (mod[ direction ] === true) {
        dir[ direction ] = true;
      }
    }

    if (Object.keys(dir).length === 0) {
      return modifiersAll
    }

    if (dir.horizontal === true) {
      dir.left = dir.right = true;
    }
    else if (dir.left === true && dir.right === true) {
      dir.horizontal = true;
    }

    if (dir.vertical === true) {
      dir.up = dir.down = true;
    }
    else if (dir.up === true && dir.down === true) {
      dir.vertical = true;
    }

    if (dir.horizontal === true && dir.vertical === true) {
      dir.all = true;
    }

    return dir
  }

  function shouldStart (evt, ctx) {
    return ctx.event === void 0
      && evt.target !== void 0
      && evt.target.draggable !== true
      && typeof ctx.handler === 'function'
      && evt.target.nodeName.toUpperCase() !== 'INPUT'
      && (evt.qClonedBy === void 0 || evt.qClonedBy.indexOf(ctx.uid) === -1)
  }

  function parseArg (arg) {
    // delta (min velocity -- dist / time)
    // mobile min distance on first move
    // desktop min distance until deciding if it's a swipe or not
    const data = [ 0.06, 6, 50 ];

    if (typeof arg === 'string' && arg.length) {
      arg.split(':').forEach((val, index) => {
        const v = parseFloat(val);
        v && (data[ index ] = v);
      });
    }

    return data
  }

  var TouchSwipe = createDirective({
        name: 'touch-swipe',

        beforeMount (el, { value, arg, modifiers }) {
          // early return, we don't need to do anything
          if (modifiers.mouse !== true && client.has.touch !== true) {
            return
          }

          const mouseCapture = modifiers.mouseCapture === true ? 'Capture' : '';

          const ctx = {
            handler: value,
            sensitivity: parseArg(arg),
            direction: getModifierDirections(modifiers),

            noop,

            mouseStart (evt) {
              if (shouldStart(evt, ctx) && leftClick(evt)) {
                addEvt(ctx, 'temp', [
                  [ document, 'mousemove', 'move', `notPassive${ mouseCapture }` ],
                  [ document, 'mouseup', 'end', 'notPassiveCapture' ]
                ]);
                ctx.start(evt, true);
              }
            },

            touchStart (evt) {
              if (shouldStart(evt, ctx)) {
                const target = evt.target;
                addEvt(ctx, 'temp', [
                  [ target, 'touchmove', 'move', 'notPassiveCapture' ],
                  [ target, 'touchcancel', 'end', 'notPassiveCapture' ],
                  [ target, 'touchend', 'end', 'notPassiveCapture' ]
                ]);
                ctx.start(evt);
              }
            },

            start (evt, mouseEvent) {
              client.is.firefox === true && preventDraggable(el, true);

              const pos = position(evt);

              ctx.event = {
                x: pos.left,
                y: pos.top,
                time: Date.now(),
                mouse: mouseEvent === true,
                dir: false
              };
            },

            move (evt) {
              if (ctx.event === void 0) {
                return
              }

              if (ctx.event.dir !== false) {
                stopAndPrevent(evt);
                return
              }

              const time = Date.now() - ctx.event.time;

              if (time === 0) {
                return
              }

              const
                pos = position(evt),
                distX = pos.left - ctx.event.x,
                absX = Math.abs(distX),
                distY = pos.top - ctx.event.y,
                absY = Math.abs(distY);

              if (ctx.event.mouse !== true) {
                if (absX < ctx.sensitivity[ 1 ] && absY < ctx.sensitivity[ 1 ]) {
                  ctx.end(evt);
                  return
                }
              }
              else if (absX < ctx.sensitivity[ 2 ] && absY < ctx.sensitivity[ 2 ]) {
                return
              }

              const
                velX = absX / time,
                velY = absY / time;

              if (
                ctx.direction.vertical === true
                && absX < absY
                && absX < 100
                && velY > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = distY < 0 ? 'up' : 'down';
              }

              if (
                ctx.direction.horizontal === true
                && absX > absY
                && absY < 100
                && velX > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = distX < 0 ? 'left' : 'right';
              }

              if (
                ctx.direction.up === true
                && absX < absY
                && distY < 0
                && absX < 100
                && velY > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = 'up';
              }

              if (
                ctx.direction.down === true
                && absX < absY
                && distY > 0
                && absX < 100
                && velY > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = 'down';
              }

              if (
                ctx.direction.left === true
                && absX > absY
                && distX < 0
                && absY < 100
                && velX > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = 'left';
              }

              if (
                ctx.direction.right === true
                && absX > absY
                && distX > 0
                && absY < 100
                && velX > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = 'right';
              }

              if (ctx.event.dir !== false) {
                stopAndPrevent(evt);

                if (ctx.event.mouse === true) {
                  document.body.classList.add('no-pointer-events--children');
                  document.body.classList.add('non-selectable');
                  clearSelection();

                  ctx.styleCleanup = withDelay => {
                    ctx.styleCleanup = void 0;

                    document.body.classList.remove('non-selectable');

                    const remove = () => {
                      document.body.classList.remove('no-pointer-events--children');
                    };

                    if (withDelay === true) { setTimeout(remove, 50); }
                    else { remove(); }
                  };
                }

                ctx.handler({
                  evt,
                  touch: ctx.event.mouse !== true,
                  mouse: ctx.event.mouse,
                  direction: ctx.event.dir,
                  duration: time,
                  distance: {
                    x: absX,
                    y: absY
                  }
                });
              }
              else {
                ctx.end(evt);
              }
            },

            end (evt) {
              if (ctx.event === void 0) {
                return
              }

              cleanEvt(ctx, 'temp');
              client.is.firefox === true && preventDraggable(el, false);
              ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);
              evt !== void 0 && ctx.event.dir !== false && stopAndPrevent(evt);

              ctx.event = void 0;
            }
          };

          el.__qtouchswipe = ctx;

          if (modifiers.mouse === true) {
            // account for UMD too where modifiers will be lowercased to work
            const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true
              ? 'Capture'
              : '';

            addEvt(ctx, 'main', [
              [ el, 'mousedown', 'mouseStart', `passive${ capture }` ]
            ]);
          }

          client.has.touch === true && addEvt(ctx, 'main', [
            [ el, 'touchstart', 'touchStart', `passive${ modifiers.capture === true ? 'Capture' : '' }` ],
            [ el, 'touchmove', 'noop', 'notPassiveCapture' ] // cannot be passive (ex: iOS scroll)
          ]);
        },

        updated (el, bindings) {
          const ctx = el.__qtouchswipe;

          if (ctx !== void 0) {
            if (bindings.oldValue !== bindings.value) {
              typeof bindings.value !== 'function' && ctx.end();
              ctx.handler = bindings.value;
            }

            ctx.direction = getModifierDirections(bindings.modifiers);
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qtouchswipe;

          if (ctx !== void 0) {
            cleanEvt(ctx, 'main');
            cleanEvt(ctx, 'temp');

            client.is.firefox === true && preventDraggable(el, false);
            ctx.styleCleanup !== void 0 && ctx.styleCleanup();

            delete el.__qtouchswipe;
          }
        }
      }
  );

  function useCache () {
    const cache = new Map();

    return {
      getCache: function (key, obj) {
          return cache[ key ] === void 0
            ? (cache[ key ] = obj)
            : cache[ key ]
        },

      getCacheWithFn: function (key, fn) {
          return cache[ key ] === void 0
            ? (cache[ key ] = fn())
            : cache[ key ]
        }
    }
  }

  const usePanelChildProps = {
    name: { required: true },
    disable: Boolean
  };

  const PanelWrapper$1 = {
    setup (_, { slots }) {
      return () => vue.h('div', {
        class: 'q-panel scroll',
        role: 'tabpanel'
      }, hSlot(slots.default))
    }
  };

  const usePanelProps = {
    modelValue: {
      required: true
    },

    animated: Boolean,
    infinite: Boolean,
    swipeable: Boolean,
    vertical: Boolean,

    transitionPrev: String,
    transitionNext: String,
    transitionDuration: {
      type: [ String, Number ],
      default: 300
    },

    keepAlive: Boolean,
    keepAliveInclude: [ String, Array, RegExp ],
    keepAliveExclude: [ String, Array, RegExp ],
    keepAliveMax: Number
  };

  const usePanelEmits = [ 'update:modelValue', 'beforeTransition', 'transition' ];

  function usePanel () {
    const { props, emit, proxy } = vue.getCurrentInstance();
    const { getCacheWithFn } = useCache();

    let panels, forcedPanelTransition;

    const panelIndex = vue.ref(null);
    const panelTransition = vue.ref(null);

    function onSwipe (evt) {
      const dir = props.vertical === true ? 'up' : 'left';
      goToPanelByOffset((proxy.$q.lang.rtl === true ? -1 : 1) * (evt.direction === dir ? 1 : -1));
    }

    const panelDirectives = vue.computed(() => {
      // if props.swipeable
      return [ [
        TouchSwipe,
        onSwipe,
        void 0,
        {
          horizontal: props.vertical !== true,
          vertical: props.vertical,
          mouse: true
        }
      ] ]
    });

    const transitionPrev = vue.computed(() =>
      props.transitionPrev || `slide-${ props.vertical === true ? 'down' : 'right' }`
    );

    const transitionNext = vue.computed(() =>
      props.transitionNext || `slide-${ props.vertical === true ? 'up' : 'left' }`
    );

    const transitionStyle = vue.computed(
      () => `--q-transition-duration: ${ props.transitionDuration }ms`
    );

    const contentKey = vue.computed(() => (
      typeof props.modelValue === 'string' || typeof props.modelValue === 'number'
        ? props.modelValue
        : String(props.modelValue)
    ));

    const keepAliveProps = vue.computed(() => ({
      include: props.keepAliveInclude,
      exclude: props.keepAliveExclude,
      max: props.keepAliveMax
    }));

    const needsUniqueKeepAliveWrapper = vue.computed(() =>
      props.keepAliveInclude !== void 0
      || props.keepAliveExclude !== void 0
    );

    vue.watch(() => props.modelValue, (newVal, oldVal) => {
      const index = isValidPanelName(newVal) === true
        ? getPanelIndex(newVal)
        : -1;

      if (forcedPanelTransition !== true) {
        updatePanelTransition(
          index === -1 ? 0 : (index < getPanelIndex(oldVal) ? -1 : 1)
        );
      }

      if (panelIndex.value !== index) {
        panelIndex.value = index;
        emit('beforeTransition', newVal, oldVal);
        vue.nextTick(() => {
          emit('transition', newVal, oldVal);
        });
      }
    });

    function nextPanel () { goToPanelByOffset(1); }
    function previousPanel () { goToPanelByOffset(-1); }

    function goToPanel (name) {
      emit('update:modelValue', name);
    }

    function isValidPanelName (name) {
      return name !== void 0 && name !== null && name !== ''
    }

    function getPanelIndex (name) {
      return panels.findIndex(panel => {
        return panel.props.name === name
          && panel.props.disable !== ''
          && panel.props.disable !== true
      })
    }

    function getEnabledPanels () {
      return panels.filter(panel => {
        return panel.props.disable !== ''
          && panel.props.disable !== true
      })
    }

    function updatePanelTransition (direction) {
      const val = direction !== 0 && props.animated === true && panelIndex.value !== -1
        ? 'q-transition--' + (direction === -1 ? transitionPrev.value : transitionNext.value)
        : null;

      if (panelTransition.value !== val) {
        panelTransition.value = val;
      }
    }

    function goToPanelByOffset (direction, startIndex = panelIndex.value) {
      let index = startIndex + direction;

      while (index > -1 && index < panels.length) {
        const opt = panels[ index ];

        if (
          opt !== void 0
          && opt.props.disable !== ''
          && opt.props.disable !== true
        ) {
          updatePanelTransition(direction);
          forcedPanelTransition = true;
          emit('update:modelValue', opt.props.name);
          setTimeout(() => {
            forcedPanelTransition = false;
          });
          return
        }

        index += direction;
      }

      if (props.infinite === true && panels.length > 0 && startIndex !== -1 && startIndex !== panels.length) {
        goToPanelByOffset(direction, direction === -1 ? panels.length : -1);
      }
    }

    function updatePanelIndex () {
      const index = getPanelIndex(props.modelValue);

      if (panelIndex.value !== index) {
        panelIndex.value = index;
      }

      return true
    }

    function getPanelContentChild () {
      const panel = isValidPanelName(props.modelValue) === true
        && updatePanelIndex()
        && panels[ panelIndex.value ];

      return props.keepAlive === true
        ? [
            vue.h(vue.KeepAlive, keepAliveProps.value, [
              vue.h(
                needsUniqueKeepAliveWrapper.value === true
                  ? getCacheWithFn(contentKey.value, () => ({ ...PanelWrapper$1, name: contentKey.value }))
                  : PanelWrapper$1,
                { key: contentKey.value, style: transitionStyle.value },
                () => panel
              )
            ])
          ]
        : [
            vue.h('div', {
              class: 'q-panel scroll',
              style: transitionStyle.value,
              key: contentKey.value,
              role: 'tabpanel'
            }, [ panel ])
          ]
    }

    function getPanelContent () {
      if (panels.length === 0) {
        return
      }

      return props.animated === true
        ? [ vue.h(vue.Transition, { name: panelTransition.value }, getPanelContentChild) ]
        : getPanelContentChild()
    }

    function updatePanelsList (slots) {
      panels = getNormalizedVNodes(
        hSlot(slots.default, [])
      ).filter(
        panel => panel.props !== null
          && panel.props.slot === void 0
          && isValidPanelName(panel.props.name) === true
      );

      return panels.length
    }

    function getPanels () {
      return panels
    }

    // expose public methods
    Object.assign(proxy, {
      next: nextPanel,
      previous: previousPanel,
      goTo: goToPanel
    });

    return {
      panelIndex,
      panelDirectives,

      updatePanelsList,
      updatePanelIndex,

      getPanelContent,
      getEnabledPanels,
      getPanels,

      isValidPanelName,

      keepAliveProps,
      needsUniqueKeepAliveWrapper,

      goToPanelByOffset,
      goToPanel,

      nextPanel,
      previousPanel
    }
  }

  let counter = 0;

  const useFullscreenProps = {
    fullscreen: Boolean,
    noRouteFullscreenExit: Boolean
  };

  const useFullscreenEmits = [ 'update:fullscreen', 'fullscreen' ];

  function useFullscreen () {
    const vm = vue.getCurrentInstance();
    const { props, emit, proxy } = vm;

    let historyEntry, fullscreenFillerNode, container;
    const inFullscreen = vue.ref(false);

    vmHasRouter(vm) === true && vue.watch(() => proxy.$route.fullPath, () => {
      props.noRouteFullscreenExit !== true && exitFullscreen();
    });

    vue.watch(() => props.fullscreen, v => {
      if (inFullscreen.value !== v) {
        toggleFullscreen();
      }
    });

    vue.watch(inFullscreen, v => {
      emit('update:fullscreen', v);
      emit('fullscreen', v);
    });

    function toggleFullscreen () {
      if (inFullscreen.value === true) {
        exitFullscreen();
      }
      else {
        setFullscreen();
      }
    }

    function setFullscreen () {
      if (inFullscreen.value === true) {
        return
      }

      inFullscreen.value = true;
      container = proxy.$el.parentNode;
      container.replaceChild(fullscreenFillerNode, proxy.$el);
      document.body.appendChild(proxy.$el);

      counter++;
      if (counter === 1) {
        document.body.classList.add('q-body--fullscreen-mixin');
      }

      historyEntry = {
        handler: exitFullscreen
      };
      History.add(historyEntry);
    }

    function exitFullscreen () {
      if (inFullscreen.value !== true) {
        return
      }

      if (historyEntry !== void 0) {
        History.remove(historyEntry);
        historyEntry = void 0;
      }

      container.replaceChild(proxy.$el, fullscreenFillerNode);
      inFullscreen.value = false;

      counter = Math.max(0, counter - 1);

      if (counter === 0) {
        document.body.classList.remove('q-body--fullscreen-mixin');

        if (proxy.$el.scrollIntoView !== void 0) {
          setTimeout(() => { proxy.$el.scrollIntoView(); });
        }
      }
    }

    vue.onBeforeMount(() => {
      fullscreenFillerNode = document.createElement('span');
    });

    vue.onMounted(() => {
      props.fullscreen === true && setFullscreen();
    });

    vue.onBeforeUnmount(exitFullscreen);

    // expose public methods
    Object.assign(proxy, {
      toggleFullscreen,
      setFullscreen,
      exitFullscreen
    });

    return {
      inFullscreen,
      toggleFullscreen
    }
  }

  const navigationPositionOptions = [ 'top', 'right', 'bottom', 'left' ];
  const controlTypeOptions = [ 'regular', 'flat', 'outline', 'push', 'unelevated' ];

  var QCarousel = createComponent({
    name: 'QCarousel',

    props: {
      ...useDarkProps,
      ...usePanelProps,
      ...useFullscreenProps,

      transitionPrev: { // usePanelParentProps override
        type: String,
        default: 'fade'
      },
      transitionNext: { // usePanelParentProps override
        type: String,
        default: 'fade'
      },

      height: String,
      padding: Boolean,

      controlColor: String,
      controlTextColor: String,
      controlType: {
        type: String,
        validator: v => controlTypeOptions.includes(v),
        default: 'flat'
      },

      autoplay: [ Number, Boolean ],

      arrows: Boolean,
      prevIcon: String,
      nextIcon: String,

      navigation: Boolean,
      navigationPosition: {
        type: String,
        validator: v => navigationPositionOptions.includes(v)
      },
      navigationIcon: String,
      navigationActiveIcon: String,

      thumbnails: Boolean
    },

    emits: [
      ...useFullscreenEmits,
      ...usePanelEmits
    ],

    setup (props, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const isDark = useDark(props, $q);

      let timer = null, panelsLen;

      const {
        updatePanelsList, getPanelContent,
        panelDirectives, goToPanel,
        previousPanel, nextPanel, getEnabledPanels,
        panelIndex
      } = usePanel();

      const { inFullscreen } = useFullscreen();

      const style = vue.computed(() => (
        inFullscreen.value !== true && props.height !== void 0
          ? { height: props.height }
          : {}
      ));

      const direction = vue.computed(() => (props.vertical === true ? 'vertical' : 'horizontal'));

      const classes = vue.computed(() =>
        `q-carousel q-panel-parent q-carousel--with${ props.padding === true ? '' : 'out' }-padding`
        + (inFullscreen.value === true ? ' fullscreen' : '')
        + (isDark.value === true ? ' q-carousel--dark q-dark' : '')
        + (props.arrows === true ? ` q-carousel--arrows-${ direction.value }` : '')
        + (props.navigation === true ? ` q-carousel--navigation-${ navigationPosition.value }` : '')
      );

      const arrowIcons = vue.computed(() => {
        const ico = [
          props.prevIcon || $q.iconSet.carousel[ props.vertical === true ? 'up' : 'left' ],
          props.nextIcon || $q.iconSet.carousel[ props.vertical === true ? 'down' : 'right' ]
        ];

        return props.vertical === false && $q.lang.rtl === true
          ? ico.reverse()
          : ico
      });

      const navIcon = vue.computed(() => props.navigationIcon || $q.iconSet.carousel.navigationIcon);
      const navActiveIcon = vue.computed(() => props.navigationActiveIcon || navIcon.value);
      const navigationPosition = vue.computed(() => props.navigationPosition
        || (props.vertical === true ? 'right' : 'bottom')
      );

      const controlProps = vue.computed(() => ({
        color: props.controlColor,
        textColor: props.controlTextColor,
        round: true,
        [ props.controlType ]: true,
        dense: true
      }));

      vue.watch(() => props.modelValue, () => {
        if (props.autoplay) {
          startTimer();
        }
      });

      vue.watch(() => props.autoplay, val => {
        if (val) {
          startTimer();
        }
        else if (timer !== null) {
          clearTimeout(timer);
          timer = null;
        }
      });

      function startTimer () {
        const duration = isNumber(props.autoplay) === true
          ? Math.abs(props.autoplay)
          : 5000;

        timer !== null && clearTimeout(timer);
        timer = setTimeout(() => {
          timer = null;

          if (duration >= 0) {
            nextPanel();
          }
          else {
            previousPanel();
          }
        }, duration);
      }

      vue.onMounted(() => {
        props.autoplay && startTimer();
      });

      vue.onBeforeUnmount(() => {
        timer !== null && clearTimeout(timer);
      });

      function getNavigationContainer (type, mapping) {
        return vue.h('div', {
          class: 'q-carousel__control q-carousel__navigation no-wrap absolute flex'
            + ` q-carousel__navigation--${ type } q-carousel__navigation--${ navigationPosition.value }`
            + (props.controlColor !== void 0 ? ` text-${ props.controlColor }` : '')
        }, [
          vue.h('div', {
            class: 'q-carousel__navigation-inner flex flex-center no-wrap'
          }, getEnabledPanels().map(mapping))
        ])
      }

      function getContent () {
        const node = [];

        if (props.navigation === true) {
          const fn = slots[ 'navigation-icon' ] !== void 0
            ? slots[ 'navigation-icon' ]
            : opts => vue.h(QBtn, {
              key: 'nav' + opts.name,
              class: `q-carousel__navigation-icon q-carousel__navigation-icon--${ opts.active === true ? '' : 'in' }active`,
              ...opts.btnProps,
              onClick: opts.onClick
            });

          const maxIndex = panelsLen - 1;
          node.push(
            getNavigationContainer('buttons', (panel, index) => {
              const name = panel.props.name;
              const active = panelIndex.value === index;

              return fn({
                index,
                maxIndex,
                name,
                active,
                btnProps: {
                  icon: active === true ? navActiveIcon.value : navIcon.value,
                  size: 'sm',
                  ...controlProps.value
                },
                onClick: () => { goToPanel(name); }
              })
            })
          );
        }
        else if (props.thumbnails === true) {
          const color = props.controlColor !== void 0
            ? ` text-${ props.controlColor }`
            : '';

          node.push(getNavigationContainer('thumbnails', panel => {
            const slide = panel.props;

            return vue.h('img', {
              key: 'tmb#' + slide.name,
              class: `q-carousel__thumbnail q-carousel__thumbnail--${ slide.name === props.modelValue ? '' : 'in' }active` + color,
              src: slide.imgSrc || slide[ 'img-src' ],
              onClick: () => { goToPanel(slide.name); }
            })
          }));
        }

        if (props.arrows === true && panelIndex.value >= 0) {
          if (props.infinite === true || panelIndex.value > 0) {
            node.push(
              vue.h('div', {
                key: 'prev',
                class: `q-carousel__control q-carousel__arrow q-carousel__prev-arrow q-carousel__prev-arrow--${ direction.value } absolute flex flex-center`
              }, [
                vue.h(QBtn, {
                  icon: arrowIcons.value[ 0 ],
                  ...controlProps.value,
                  onClick: previousPanel
                })
              ])
            );
          }

          if (props.infinite === true || panelIndex.value < panelsLen - 1) {
            node.push(
              vue.h('div', {
                key: 'next',
                class: 'q-carousel__control q-carousel__arrow q-carousel__next-arrow'
                  + ` q-carousel__next-arrow--${ direction.value } absolute flex flex-center`
              }, [
                vue.h(QBtn, {
                  icon: arrowIcons.value[ 1 ],
                  ...controlProps.value,
                  onClick: nextPanel
                })
              ])
            );
          }
        }

        return hMergeSlot(slots.control, node)
      }

      return () => {
        panelsLen = updatePanelsList(slots);

        return vue.h('div', {
          class: classes.value,
          style: style.value
        }, [
          hDir(
            'div',
            { class: 'q-carousel__slides-container' },
            getPanelContent(),
            'sl-cont',
            props.swipeable,
            () => panelDirectives.value
          )
        ].concat(getContent()))
      }
    }
  });

  var QCarouselSlide = createComponent({
    name: 'QCarouselSlide',

    props: {
      ...usePanelChildProps,
      imgSrc: String
    },

    setup (props, { slots }) {
      const style = vue.computed(() => (
        props.imgSrc
          ? { backgroundImage: `url("${ props.imgSrc }")` }
          : {}
      ));

      return () => vue.h('div', {
        class: 'q-carousel__slide',
        style: style.value
      }, hSlot(slots.default))
    }
  });

  var QCarouselControl = createComponent({
    name: 'QCarouselControl',

    props: {
      position: {
        type: String,
        default: 'bottom-right',
        validator: v => [
          'top-right', 'top-left',
          'bottom-right', 'bottom-left',
          'top', 'right', 'bottom', 'left'
        ].includes(v)
      },
      offset: {
        type: Array,
        default: () => [ 18, 18 ],
        validator: v => v.length === 2
      }
    },

    setup (props, { slots }) {
      const classes = vue.computed(() => `q-carousel__control absolute absolute-${ props.position }`);
      const style = vue.computed(() => ({
        margin: `${ props.offset[ 1 ] }px ${ props.offset[ 0 ] }px`
      }));

      return () => vue.h('div', {
        class: classes.value,
        style: style.value
      }, hSlot(slots.default))
    }
  });

  var QChatMessage = createComponent({
    name: 'QChatMessage',

    props: {
      sent: Boolean,
      label: String,
      bgColor: String,
      textColor: String,
      name: String,
      avatar: String,
      text: Array,
      stamp: String,
      size: String,
      labelHtml: Boolean,
      nameHtml: Boolean,
      textHtml: Boolean,
      stampHtml: Boolean
    },

    setup (props, { slots }) {
      const op = vue.computed(() => (props.sent === true ? 'sent' : 'received'));

      const textClass = vue.computed(() =>
        `q-message-text-content q-message-text-content--${ op.value }`
        + (props.textColor !== void 0 ? ` text-${ props.textColor }` : '')
      );

      const messageClass = vue.computed(() =>
        `q-message-text q-message-text--${ op.value }`
        + (props.bgColor !== void 0 ? ` text-${ props.bgColor }` : '')
      );

      const containerClass = vue.computed(() =>
        'q-message-container row items-end no-wrap'
        + (props.sent === true ? ' reverse' : '')
      );

      const sizeClass = vue.computed(() => (props.size !== void 0 ? `col-${ props.size }` : ''));

      const domProps = vue.computed(() => ({
        msg: props.textHtml === true ? 'innerHTML' : 'textContent',
        stamp: props.stampHtml === true ? 'innerHTML' : 'textContent',
        name: props.nameHtml === true ? 'innerHTML' : 'textContent',
        label: props.labelHtml === true ? 'innerHTML' : 'textContent'
      }));

      function wrapStamp (node) {
        if (slots.stamp !== void 0) {
          return [ node, vue.h('div', { class: 'q-message-stamp' }, slots.stamp()) ]
        }

        if (props.stamp) {
          return [
            node,
            vue.h('div', {
              class: 'q-message-stamp',
              [ domProps.value.stamp ]: props.stamp
            })
          ]
        }

        return [ node ]
      }

      function getText (contentList, withSlots) {
        const content = withSlots === true
          ? (contentList.length > 1 ? text => text : text => vue.h('div', [ text ]))
          : text => vue.h('div', { [ domProps.value.msg ]: text });

        return contentList.map((msg, index) => vue.h('div', {
          key: index,
          class: messageClass.value
        }, [
          vue.h('div', { class: textClass.value }, wrapStamp(content(msg)))
        ]))
      }

      return () => {
        const container = [];

        if (slots.avatar !== void 0) {
          container.push(slots.avatar());
        }
        else if (props.avatar !== void 0) {
          container.push(
            vue.h('img', {
              class: `q-message-avatar q-message-avatar--${ op.value }`,
              src: props.avatar,
              'aria-hidden': 'true'
            })
          );
        }

        const msg = [];

        if (slots.name !== void 0) {
          msg.push(
            vue.h('div', { class: `q-message-name q-message-name--${ op.value }` }, slots.name())
          );
        }
        else if (props.name !== void 0) {
          msg.push(
            vue.h('div', {
              class: `q-message-name q-message-name--${ op.value }`,
              [ domProps.value.name ]: props.name
            })
          );
        }

        if (slots.default !== void 0) {
          msg.push(
            getText(
              getNormalizedVNodes(slots.default()),
              true
            )
          );
        }
        else if (props.text !== void 0) {
          msg.push(getText(props.text));
        }

        container.push(
          vue.h('div', { class: sizeClass.value }, msg)
        );

        const child = [];

        if (slots.label !== void 0) {
          child.push(
            vue.h('div', { class: 'q-message-label' }, slots.label())
          );
        }
        else if (props.label !== void 0) {
          child.push(
            vue.h('div', {
              class: 'q-message-label',
              [ domProps.value.label ]: props.label
            })
          );
        }

        child.push(
          vue.h('div', { class: containerClass.value }, container)
        );

        return vue.h('div', {
          class: `q-message q-message-${ op.value }`
        }, child)
      }
    }
  });

  function useRefocusTarget (props, rootRef) {
    const refocusRef = vue.ref(null);

    const refocusTargetEl = vue.computed(() => {
      if (props.disable === true) {
        return null
      }

      return vue.h('span', {
        ref: refocusRef,
        class: 'no-outline',
        tabindex: -1
      })
    });

    function refocusTarget (e) {
      const root = rootRef.value;

      if (e !== void 0 && e.type.indexOf('key') === 0) {
        if (
          root !== null
          && document.activeElement !== root
          && root.contains(document.activeElement) === true
        ) {
          root.focus();
        }
      }
      else if (
        refocusRef.value !== null
        && (e === void 0 || (root !== null && root.contains(e.target) === true))
      ) {
        refocusRef.value.focus();
      }
    }

    return {
      refocusTargetEl,
      refocusTarget
    }
  }

  var optionSizes = {
    xs: 30,
    sm: 35,
    md: 40,
    lg: 50,
    xl: 60
  };

  const useCheckboxProps = {
    ...useDarkProps,
    ...useSizeProps,
    ...useFormProps,

    modelValue: {
      required: true,
      default: null
    },
    val: {},

    trueValue: { default: true },
    falseValue: { default: false },
    indeterminateValue: { default: null },

    checkedIcon: String,
    uncheckedIcon: String,
    indeterminateIcon: String,

    toggleOrder: {
      type: String,
      validator: v => v === 'tf' || v === 'ft'
    },
    toggleIndeterminate: Boolean,

    label: String,
    leftLabel: Boolean,

    color: String,
    keepColor: Boolean,
    dense: Boolean,

    disable: Boolean,
    tabindex: [ String, Number ]
  };

  const useCheckboxEmits = [ 'update:modelValue' ];

  function useCheckbox (type, getInner) {
    const { props, slots, emit, proxy } = vue.getCurrentInstance();
    const { $q } = proxy;

    const isDark = useDark(props, $q);

    const rootRef = vue.ref(null);
    const { refocusTargetEl, refocusTarget } = useRefocusTarget(props, rootRef);
    const sizeStyle = useSize(props, optionSizes);

    const modelIsArray = vue.computed(() =>
      props.val !== void 0 && Array.isArray(props.modelValue)
    );

    const index = vue.computed(() => {
      const val = vue.toRaw(props.val);
      return modelIsArray.value === true
        ? props.modelValue.findIndex(opt => vue.toRaw(opt) === val)
        : -1
    });

    const isTrue = vue.computed(() => (
      modelIsArray.value === true
        ? index.value > -1
        : vue.toRaw(props.modelValue) === vue.toRaw(props.trueValue)
    ));

    const isFalse = vue.computed(() => (
      modelIsArray.value === true
        ? index.value === -1
        : vue.toRaw(props.modelValue) === vue.toRaw(props.falseValue)
    ));

    const isIndeterminate = vue.computed(() =>
      isTrue.value === false && isFalse.value === false
    );

    const tabindex = vue.computed(() => (
      props.disable === true ? -1 : props.tabindex || 0
    ));

    const classes = vue.computed(() =>
      `q-${ type } cursor-pointer no-outline row inline no-wrap items-center`
      + (props.disable === true ? ' disabled' : '')
      + (isDark.value === true ? ` q-${ type }--dark` : '')
      + (props.dense === true ? ` q-${ type }--dense` : '')
      + (props.leftLabel === true ? ' reverse' : '')
    );

    const innerClass = vue.computed(() => {
      const state = isTrue.value === true ? 'truthy' : (isFalse.value === true ? 'falsy' : 'indet');
      const color = props.color !== void 0 && (
        props.keepColor === true
        || (type === 'toggle' ? isTrue.value === true : isFalse.value !== true)
      )
        ? ` text-${ props.color }`
        : '';

      return `q-${ type }__inner relative-position non-selectable q-${ type }__inner--${ state }${ color }`
    });

    const formAttrs = vue.computed(() => {
      const prop = { type: 'checkbox' };

      props.name !== void 0 && Object.assign(prop, {
        // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
        '.checked': isTrue.value,
        '^checked': isTrue.value === true ? 'checked' : void 0,
        name: props.name,
        value: modelIsArray.value === true
          ? props.val
          : props.trueValue
      });

      return prop
    });

    const injectFormInput = useFormInject(formAttrs);

    const attributes = vue.computed(() => {
      const attrs = {
        tabindex: tabindex.value,
        role: type === 'toggle' ? 'switch' : 'checkbox',
        'aria-label': props.label,
        'aria-checked': isIndeterminate.value === true
          ? 'mixed'
          : (isTrue.value === true ? 'true' : 'false')
      };

      if (props.disable === true) {
        attrs[ 'aria-disabled' ] = 'true';
      }

      return attrs
    });

    function onClick (e) {
      if (e !== void 0) {
        stopAndPrevent(e);
        refocusTarget(e);
      }

      if (props.disable !== true) {
        emit('update:modelValue', getNextValue(), e);
      }
    }

    function getNextValue () {
      if (modelIsArray.value === true) {
        if (isTrue.value === true) {
          const val = props.modelValue.slice();
          val.splice(index.value, 1);
          return val
        }

        return props.modelValue.concat([ props.val ])
      }

      if (isTrue.value === true) {
        if (props.toggleOrder !== 'ft' || props.toggleIndeterminate === false) {
          return props.falseValue
        }
      }
      else if (isFalse.value === true) {
        if (props.toggleOrder === 'ft' || props.toggleIndeterminate === false) {
          return props.trueValue
        }
      }
      else {
        return props.toggleOrder !== 'ft'
          ? props.trueValue
          : props.falseValue
      }

      return props.indeterminateValue
    }

    function onKeydown (e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        stopAndPrevent(e);
      }
    }

    function onKeyup (e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        onClick(e);
      }
    }

    const getInnerContent = getInner(isTrue, isIndeterminate);

    // expose public methods
    Object.assign(proxy, { toggle: onClick });

    return () => {
      const inner = getInnerContent();

      props.disable !== true && injectFormInput(
        inner,
        'unshift',
        ` q-${ type }__native absolute q-ma-none q-pa-none`
      );

      const child = [
        vue.h('div', {
          class: innerClass.value,
          style: sizeStyle.value,
          'aria-hidden': 'true'
        }, inner)
      ];

      if (refocusTargetEl.value !== null) {
        child.push(refocusTargetEl.value);
      }

      const label = props.label !== void 0
        ? hMergeSlot(slots.default, [ props.label ])
        : hSlot(slots.default);

      label !== void 0 && child.push(
        vue.h('div', {
          class: `q-${ type }__label q-anchor--skip`
        }, label)
      );

      return vue.h('div', {
        ref: rootRef,
        class: classes.value,
        ...attributes.value,
        onClick,
        onKeydown,
        onKeyup
      }, child)
    }
  }

  const bgNode = vue.h('div', {
    key: 'svg',
    class: 'q-checkbox__bg absolute'
  }, [
    vue.h('svg', {
      class: 'q-checkbox__svg fit absolute-full',
      viewBox: '0 0 24 24'
    }, [
      vue.h('path', {
        class: 'q-checkbox__truthy',
        fill: 'none',
        d: 'M1.73,12.91 8.1,19.28 22.79,4.59'
      }),

      vue.h('path', {
        class: 'q-checkbox__indet',
        d: 'M4,14H20V10H4'
      })
    ])
  ]);

  var QCheckbox = createComponent({
    name: 'QCheckbox',

    props: useCheckboxProps,
    emits: useCheckboxEmits,

    setup (props) {
      function getInner (isTrue, isIndeterminate) {
        const icon = vue.computed(() =>
          (isTrue.value === true
            ? props.checkedIcon
            : (isIndeterminate.value === true
                ? props.indeterminateIcon
                : props.uncheckedIcon
              )
          ) || null
        );

        return () => (
          icon.value !== null
            ? [
                vue.h('div', {
                  key: 'icon',
                  class: 'q-checkbox__icon-container absolute-full flex flex-center no-wrap'
                }, [
                  vue.h(QIcon, {
                    class: 'q-checkbox__icon',
                    name: icon.value
                  })
                ])
              ]
            : [ bgNode ]
        )
      }

      return useCheckbox('checkbox', getInner)
    }
  });

  const defaultSizes$1 = {
    xs: 8,
    sm: 10,
    md: 14,
    lg: 20,
    xl: 24
  };

  var QChip = createComponent({
    name: 'QChip',

    props: {
      ...useDarkProps,
      ...useSizeProps,

      dense: Boolean,

      icon: String,
      iconRight: String,
      iconRemove: String,
      iconSelected: String,
      label: [ String, Number ],

      color: String,
      textColor: String,

      modelValue: {
        type: Boolean,
        default: true
      },
      selected: {
        type: Boolean,
        default: null
      },

      square: Boolean,
      outline: Boolean,
      clickable: Boolean,
      removable: Boolean,

      removeAriaLabel: String,

      tabindex: [ String, Number ],
      disable: Boolean,

      ripple: {
        type: [ Boolean, Object ],
        default: true
      }
    },

    emits: [ 'update:modelValue', 'update:selected', 'remove', 'click' ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const isDark = useDark(props, $q);
      const sizeStyle = useSize(props, defaultSizes$1);

      const hasLeftIcon = vue.computed(() => props.selected === true || props.icon !== void 0);

      const leftIcon = vue.computed(() => (
        props.selected === true
          ? props.iconSelected || $q.iconSet.chip.selected
          : props.icon
      ));

      const removeIcon = vue.computed(() => props.iconRemove || $q.iconSet.chip.remove);

      const isClickable = vue.computed(() =>
        props.disable === false
        && (props.clickable === true || props.selected !== null)
      );

      const classes = vue.computed(() => {
        const text = props.outline === true
          ? props.color || props.textColor
          : props.textColor;

        return 'q-chip row inline no-wrap items-center'
          + (props.outline === false && props.color !== void 0 ? ` bg-${ props.color }` : '')
          + (text ? ` text-${ text } q-chip--colored` : '')
          + (props.disable === true ? ' disabled' : '')
          + (props.dense === true ? ' q-chip--dense' : '')
          + (props.outline === true ? ' q-chip--outline' : '')
          + (props.selected === true ? ' q-chip--selected' : '')
          + (isClickable.value === true ? ' q-chip--clickable cursor-pointer non-selectable q-hoverable' : '')
          + (props.square === true ? ' q-chip--square' : '')
          + (isDark.value === true ? ' q-chip--dark q-dark' : '')
      });

      const attributes = vue.computed(() => {
        const chip = props.disable === true
          ? { tabindex: -1, 'aria-disabled': 'true' }
          : { tabindex: props.tabindex || 0 };
        const remove = {
          ...chip,
          role: 'button',
          'aria-hidden': 'false',
          'aria-label': props.removeAriaLabel || $q.lang.label.remove
        };

        return { chip, remove }
      });

      function onKeyup (e) {
        e.keyCode === 13 /* ENTER */ && onClick(e);
      }

      function onClick (e) {
        if (!props.disable) {
          emit('update:selected', !props.selected);
          emit('click', e);
        }
      }

      function onRemove (e) {
        if (e.keyCode === void 0 || e.keyCode === 13) {
          stopAndPrevent(e);
          if (props.disable === false) {
            emit('update:modelValue', false);
            emit('remove');
          }
        }
      }

      function getContent () {
        const child = [];

        isClickable.value === true && child.push(
          vue.h('div', { class: 'q-focus-helper' })
        );

        hasLeftIcon.value === true && child.push(
          vue.h(QIcon, {
            class: 'q-chip__icon q-chip__icon--left',
            name: leftIcon.value
          })
        );

        const label = props.label !== void 0
          ? [ vue.h('div', { class: 'ellipsis' }, [ props.label ]) ]
          : void 0;

        child.push(
          vue.h('div', {
            class: 'q-chip__content col row no-wrap items-center q-anchor--skip'
          }, hMergeSlotSafely(slots.default, label))
        );

        props.iconRight && child.push(
          vue.h(QIcon, {
            class: 'q-chip__icon q-chip__icon--right',
            name: props.iconRight
          })
        );

        props.removable === true && child.push(
          vue.h(QIcon, {
            class: 'q-chip__icon q-chip__icon--remove cursor-pointer',
            name: removeIcon.value,
            ...attributes.value.remove,
            onClick: onRemove,
            onKeyup: onRemove
          })
        );

        return child
      }

      return () => {
        if (props.modelValue === false) { return }

        const data = {
          class: classes.value,
          style: sizeStyle.value
        };

        isClickable.value === true && Object.assign(
          data,
          attributes.value.chip,
          { onClick, onKeyup }
        );

        return hDir(
          'div',
          data,
          getContent(),
          'ripple',
          props.ripple !== false && props.disable !== true,
          () => [ [ Ripple, props.ripple ] ]
        )
      }
    }
  });

  // also used by QKnob
  const useCircularCommonProps = {
    ...useSizeProps,

    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },

    color: String,
    centerColor: String,
    trackColor: String,

    fontSize: String,
    rounded: Boolean,

    // ratio
    thickness: {
      type: Number,
      default: 0.2,
      validator: v => v >= 0 && v <= 1
    },

    angle: {
      type: Number,
      default: 0
    },

    showValue: Boolean,
    reverse: Boolean,

    instantFeedback: Boolean
  };

  const
    radius = 50,
    diameter = 2 * radius,
    circumference = diameter * Math.PI,
    strokeDashArray = Math.round(circumference * 1000) / 1000;

  var QCircularProgress = createComponent({
    name: 'QCircularProgress',

    props: {
      ...useCircularCommonProps,

      value: {
        type: Number,
        default: 0
      },

      animationSpeed: {
        type: [ String, Number ],
        default: 600
      },

      indeterminate: Boolean
    },

    setup (props, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const sizeStyle = useSize(props);

      const svgStyle = vue.computed(() => {
        const angle = ($q.lang.rtl === true ? -1 : 1) * props.angle;

        return {
          transform: props.reverse !== ($q.lang.rtl === true)
            ? `scale3d(-1, 1, 1) rotate3d(0, 0, 1, ${ -90 - angle }deg)`
            : `rotate3d(0, 0, 1, ${ angle - 90 }deg)`
        }
      });

      const circleStyle = vue.computed(() => (
        props.instantFeedback !== true && props.indeterminate !== true
          ? { transition: `stroke-dashoffset ${ props.animationSpeed }ms ease 0s, stroke ${ props.animationSpeed }ms ease` }
          : ''
      ));

      const viewBox = vue.computed(() => diameter / (1 - props.thickness / 2));

      const viewBoxAttr = vue.computed(() =>
        `${ viewBox.value / 2 } ${ viewBox.value / 2 } ${ viewBox.value } ${ viewBox.value }`
      );

      const normalized = vue.computed(() => between(props.value, props.min, props.max));

      const strokeDashOffset = vue.computed(() => circumference * (
        1 - (normalized.value - props.min) / (props.max - props.min)
      ));

      const strokeWidth = vue.computed(() => props.thickness / 2 * viewBox.value);

      function getCircle ({ thickness, offset, color, cls, rounded }) {
        return vue.h('circle', {
          class: 'q-circular-progress__' + cls + (color !== void 0 ? ` text-${ color }` : ''),
          style: circleStyle.value,
          fill: 'transparent',
          stroke: 'currentColor',
          'stroke-width': thickness,
          'stroke-dasharray': strokeDashArray,
          'stroke-dashoffset': offset,
          'stroke-linecap': rounded,
          cx: viewBox.value,
          cy: viewBox.value,
          r: radius
        })
      }

      return () => {
        const svgChild = [];

        props.centerColor !== void 0 && props.centerColor !== 'transparent' && svgChild.push(
          vue.h('circle', {
            class: `q-circular-progress__center text-${ props.centerColor }`,
            fill: 'currentColor',
            r: radius - strokeWidth.value / 2,
            cx: viewBox.value,
            cy: viewBox.value
          })
        );

        props.trackColor !== void 0 && props.trackColor !== 'transparent' && svgChild.push(
          getCircle({
            cls: 'track',
            thickness: strokeWidth.value,
            offset: 0,
            color: props.trackColor
          })
        );

        svgChild.push(
          getCircle({
            cls: 'circle',
            thickness: strokeWidth.value,
            offset: strokeDashOffset.value,
            color: props.color,
            rounded: props.rounded === true ? 'round' : void 0
          })
        );

        const child = [
          vue.h('svg', {
            class: 'q-circular-progress__svg',
            style: svgStyle.value,
            viewBox: viewBoxAttr.value,
            'aria-hidden': 'true'
          }, svgChild)
        ];

        props.showValue === true && child.push(
          vue.h('div', {
            class: 'q-circular-progress__text absolute-full row flex-center content-center',
            style: { fontSize: props.fontSize }
          }, slots.default !== void 0 ? slots.default() : [ vue.h('div', normalized.value) ])
        );

        return vue.h('div', {
          class: `q-circular-progress q-circular-progress--${ props.indeterminate === true ? 'in' : '' }determinate`,
          style: sizeStyle.value,
          role: 'progressbar',
          'aria-valuemin': props.min,
          'aria-valuemax': props.max,
          'aria-valuenow': props.indeterminate === true ? void 0 : normalized.value
        }, hMergeSlotSafely(slots.internal, child)) // "internal" is used by QKnob
      }
    }
  });

  function getChanges (evt, ctx, isFinal) {
    const pos = position(evt);
    let
      dir,
      distX = pos.left - ctx.event.x,
      distY = pos.top - ctx.event.y,
      absX = Math.abs(distX),
      absY = Math.abs(distY);

    const direction = ctx.direction;

    if (direction.horizontal === true && direction.vertical !== true) {
      dir = distX < 0 ? 'left' : 'right';
    }
    else if (direction.horizontal !== true && direction.vertical === true) {
      dir = distY < 0 ? 'up' : 'down';
    }
    else if (direction.up === true && distY < 0) {
      dir = 'up';
      if (absX > absY) {
        if (direction.left === true && distX < 0) {
          dir = 'left';
        }
        else if (direction.right === true && distX > 0) {
          dir = 'right';
        }
      }
    }
    else if (direction.down === true && distY > 0) {
      dir = 'down';
      if (absX > absY) {
        if (direction.left === true && distX < 0) {
          dir = 'left';
        }
        else if (direction.right === true && distX > 0) {
          dir = 'right';
        }
      }
    }
    else if (direction.left === true && distX < 0) {
      dir = 'left';
      if (absX < absY) {
        if (direction.up === true && distY < 0) {
          dir = 'up';
        }
        else if (direction.down === true && distY > 0) {
          dir = 'down';
        }
      }
    }
    else if (direction.right === true && distX > 0) {
      dir = 'right';
      if (absX < absY) {
        if (direction.up === true && distY < 0) {
          dir = 'up';
        }
        else if (direction.down === true && distY > 0) {
          dir = 'down';
        }
      }
    }

    let synthetic = false;

    if (dir === void 0 && isFinal === false) {
      if (ctx.event.isFirst === true || ctx.event.lastDir === void 0) {
        return {}
      }

      dir = ctx.event.lastDir;
      synthetic = true;

      if (dir === 'left' || dir === 'right') {
        pos.left -= distX;
        absX = 0;
        distX = 0;
      }
      else {
        pos.top -= distY;
        absY = 0;
        distY = 0;
      }
    }

    return {
      synthetic,
      payload: {
        evt,
        touch: ctx.event.mouse !== true,
        mouse: ctx.event.mouse === true,
        position: pos,
        direction: dir,
        isFirst: ctx.event.isFirst,
        isFinal: isFinal === true,
        duration: Date.now() - ctx.event.time,
        distance: {
          x: absX,
          y: absY
        },
        offset: {
          x: distX,
          y: distY
        },
        delta: {
          x: pos.left - ctx.event.lastX,
          y: pos.top - ctx.event.lastY
        }
      }
    }
  }

  let uid$2 = 0;

  var TouchPan = createDirective({
        name: 'touch-pan',

        beforeMount (el, { value, modifiers }) {
          // early return, we don't need to do anything
          if (modifiers.mouse !== true && client.has.touch !== true) {
            return
          }

          function handleEvent (evt, mouseEvent) {
            if (modifiers.mouse === true && mouseEvent === true) {
              stopAndPrevent(evt);
            }
            else {
              modifiers.stop === true && stop(evt);
              modifiers.prevent === true && prevent(evt);
            }
          }

          const ctx = {
            uid: 'qvtp_' + (uid$2++),
            handler: value,
            modifiers,
            direction: getModifierDirections(modifiers),

            noop,

            mouseStart (evt) {
              if (shouldStart(evt, ctx) && leftClick(evt)) {
                addEvt(ctx, 'temp', [
                  [ document, 'mousemove', 'move', 'notPassiveCapture' ],
                  [ document, 'mouseup', 'end', 'passiveCapture' ]
                ]);

                ctx.start(evt, true);
              }
            },

            touchStart (evt) {
              if (shouldStart(evt, ctx)) {
                const target = evt.target;

                addEvt(ctx, 'temp', [
                  [ target, 'touchmove', 'move', 'notPassiveCapture' ],
                  [ target, 'touchcancel', 'end', 'passiveCapture' ],
                  [ target, 'touchend', 'end', 'passiveCapture' ]
                ]);

                ctx.start(evt);
              }
            },

            start (evt, mouseEvent) {
              client.is.firefox === true && preventDraggable(el, true);
              ctx.lastEvt = evt;

              /*
              * Stop propagation so possible upper v-touch-pan don't catch this as well;
              * If we're not the target (based on modifiers), we'll re-emit the event later
              */
              if (mouseEvent === true || modifiers.stop === true) {
                /*
                * are we directly switching to detected state?
                * clone event only otherwise
                */
                if (
                  ctx.direction.all !== true
                  // account for UMD too where modifiers will be lowercased to work
                  && (mouseEvent !== true || (ctx.modifiers.mouseAllDir !== true && ctx.modifiers.mousealldir !== true))
                ) {
                  const clone = evt.type.indexOf('mouse') > -1
                    ? new MouseEvent(evt.type, evt)
                    : new TouchEvent(evt.type, evt);

                  evt.defaultPrevented === true && prevent(clone);
                  evt.cancelBubble === true && stop(clone);

                  Object.assign(clone, {
                    qKeyEvent: evt.qKeyEvent,
                    qClickOutside: evt.qClickOutside,
                    qAnchorHandled: evt.qAnchorHandled,
                    qClonedBy: evt.qClonedBy === void 0
                      ? [ ctx.uid ]
                      : evt.qClonedBy.concat(ctx.uid)
                  });

                  ctx.initialEvent = {
                    target: evt.target,
                    event: clone
                  };
                }

                stop(evt);
              }

              const { left, top } = position(evt);

              ctx.event = {
                x: left,
                y: top,
                time: Date.now(),
                mouse: mouseEvent === true,
                detected: false,
                isFirst: true,
                isFinal: false,
                lastX: left,
                lastY: top
              };
            },

            move (evt) {
              if (ctx.event === void 0) {
                return
              }

              const
                pos = position(evt),
                distX = pos.left - ctx.event.x,
                distY = pos.top - ctx.event.y;

              // prevent buggy browser behavior (like Blink-based engine ones on Windows)
              // where the mousemove event occurs even if there's no movement after mousedown
              // https://bugs.chromium.org/p/chromium/issues/detail?id=161464
              // https://bugs.chromium.org/p/chromium/issues/detail?id=721341
              // https://github.com/quasarframework/quasar/issues/10721
              if (distX === 0 && distY === 0) {
                return
              }

              ctx.lastEvt = evt;

              const isMouseEvt = ctx.event.mouse === true;
              const start = () => {
                handleEvent(evt, isMouseEvt);

                let cursor;
                if (modifiers.preserveCursor !== true && modifiers.preservecursor !== true) {
                  cursor = document.documentElement.style.cursor || '';
                  document.documentElement.style.cursor = 'grabbing';
                }

                isMouseEvt === true && document.body.classList.add('no-pointer-events--children');
                document.body.classList.add('non-selectable');
                clearSelection();

                ctx.styleCleanup = withDelayedFn => {
                  ctx.styleCleanup = void 0;

                  if (cursor !== void 0) {
                    document.documentElement.style.cursor = cursor;
                  }

                  document.body.classList.remove('non-selectable');

                  if (isMouseEvt === true) {
                    const remove = () => {
                      document.body.classList.remove('no-pointer-events--children');
                    };

                    if (withDelayedFn !== void 0) {
                      setTimeout(() => {
                        remove();
                        withDelayedFn();
                      }, 50);
                    }
                    else { remove(); }
                  }
                  else if (withDelayedFn !== void 0) {
                    withDelayedFn();
                  }
                };
              };

              if (ctx.event.detected === true) {
                ctx.event.isFirst !== true && handleEvent(evt, ctx.event.mouse);

                const { payload, synthetic } = getChanges(evt, ctx, false);

                if (payload !== void 0) {
                  if (ctx.handler(payload) === false) {
                    ctx.end(evt);
                  }
                  else {
                    if (ctx.styleCleanup === void 0 && ctx.event.isFirst === true) {
                      start();
                    }

                    ctx.event.lastX = payload.position.left;
                    ctx.event.lastY = payload.position.top;
                    ctx.event.lastDir = synthetic === true ? void 0 : payload.direction;
                    ctx.event.isFirst = false;
                  }
                }

                return
              }

              if (
                ctx.direction.all === true
                // account for UMD too where modifiers will be lowercased to work
                || (isMouseEvt === true && (ctx.modifiers.mouseAllDir === true || ctx.modifiers.mousealldir === true))
              ) {
                start();
                ctx.event.detected = true;
                ctx.move(evt);
                return
              }

              const
                absX = Math.abs(distX),
                absY = Math.abs(distY);

              if (absX !== absY) {
                if (
                  (ctx.direction.horizontal === true && absX > absY)
                  || (ctx.direction.vertical === true && absX < absY)
                  || (ctx.direction.up === true && absX < absY && distY < 0)
                  || (ctx.direction.down === true && absX < absY && distY > 0)
                  || (ctx.direction.left === true && absX > absY && distX < 0)
                  || (ctx.direction.right === true && absX > absY && distX > 0)
                ) {
                  ctx.event.detected = true;
                  ctx.move(evt);
                }
                else {
                  ctx.end(evt, true);
                }
              }
            },

            end (evt, abort) {
              if (ctx.event === void 0) {
                return
              }

              cleanEvt(ctx, 'temp');
              client.is.firefox === true && preventDraggable(el, false);

              if (abort === true) {
                ctx.styleCleanup !== void 0 && ctx.styleCleanup();

                if (ctx.event.detected !== true && ctx.initialEvent !== void 0) {
                  ctx.initialEvent.target.dispatchEvent(ctx.initialEvent.event);
                }
              }
              else if (ctx.event.detected === true) {
                ctx.event.isFirst === true && ctx.handler(getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx).payload);

                const { payload } = getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx, true);
                const fn = () => { ctx.handler(payload); };

                if (ctx.styleCleanup !== void 0) {
                  ctx.styleCleanup(fn);
                }
                else {
                  fn();
                }
              }

              ctx.event = void 0;
              ctx.initialEvent = void 0;
              ctx.lastEvt = void 0;
            }
          };

          el.__qtouchpan = ctx;

          if (modifiers.mouse === true) {
            // account for UMD too where modifiers will be lowercased to work
            const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true
              ? 'Capture'
              : '';

            addEvt(ctx, 'main', [
              [ el, 'mousedown', 'mouseStart', `passive${ capture }` ]
            ]);
          }

          client.has.touch === true && addEvt(ctx, 'main', [
            [ el, 'touchstart', 'touchStart', `passive${ modifiers.capture === true ? 'Capture' : '' }` ],
            [ el, 'touchmove', 'noop', 'notPassiveCapture' ] // cannot be passive (ex: iOS scroll)
          ]);
        },

        updated (el, bindings) {
          const ctx = el.__qtouchpan;

          if (ctx !== void 0) {
            if (bindings.oldValue !== bindings.value) {
              typeof value !== 'function' && ctx.end();
              ctx.handler = bindings.value;
            }

            ctx.direction = getModifierDirections(bindings.modifiers);
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qtouchpan;

          if (ctx !== void 0) {
            // emit the end event when the directive is destroyed while active
            // this is only needed in TouchPan because the rest of the touch directives do not emit an end event
            // the condition is also checked in the start of function but we avoid the call
            ctx.event !== void 0 && ctx.end();

            cleanEvt(ctx, 'main');
            cleanEvt(ctx, 'temp');

            client.is.firefox === true && preventDraggable(el, false);
            ctx.styleCleanup !== void 0 && ctx.styleCleanup();

            delete el.__qtouchpan;
          }
        }
      }
  );

  const markerPrefixClass = 'q-slider__marker-labels';
  const defaultMarkerConvertFn = v => ({ value: v });
  const defaultMarkerLabelRenderFn = ({ marker }) => vue.h('div', {
    key: marker.value,
    style: marker.style,
    class: marker.classes
  }, marker.label);

  // PGDOWN, LEFT, DOWN, PGUP, RIGHT, UP
  const keyCodes$2 = [ 34, 37, 40, 33, 39, 38 ];

  const useSliderProps = {
    ...useDarkProps,
    ...useFormProps,

    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    innerMin: Number,
    innerMax: Number,

    step: {
      type: Number,
      default: 1,
      validator: v => v >= 0
    },

    snap: Boolean,

    vertical: Boolean,
    reverse: Boolean,

    hideSelection: Boolean,

    color: String,
    markerLabelsClass: String,

    label: Boolean,
    labelColor: String,
    labelTextColor: String,
    labelAlways: Boolean,
    switchLabelSide: Boolean,

    markers: [ Boolean, Number ],
    markerLabels: [ Boolean, Array, Object, Function ],
    switchMarkerLabelsSide: Boolean,

    trackImg: String,
    trackColor: String,
    innerTrackImg: String,
    innerTrackColor: String,
    selectionColor: String,
    selectionImg: String,

    thumbSize: {
      type: String,
      default: '20px'
    },
    trackSize: {
      type: String,
      default: '4px'
    },

    disable: Boolean,
    readonly: Boolean,
    dense: Boolean,

    tabindex: [ String, Number ],

    thumbColor: String,
    thumbPath: {
      type: String,
      default: 'M 4, 10 a 6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0'
    }
  };

  const useSliderEmits = [ 'pan', 'update:modelValue', 'change' ];

  function useSlider ({ updateValue, updatePosition, getDragging, formAttrs }) {
    const { props, emit, slots, proxy: { $q } } = vue.getCurrentInstance();
    const isDark = useDark(props, $q);

    const injectFormInput = useFormInject(formAttrs);

    const active = vue.ref(false);
    const preventFocus = vue.ref(false);
    const focus = vue.ref(false);
    const dragging = vue.ref(false);

    const axis = vue.computed(() => (props.vertical === true ? '--v' : '--h'));
    const labelSide = vue.computed(() => '-' + (props.switchLabelSide === true ? 'switched' : 'standard'));

    const isReversed = vue.computed(() => (
      props.vertical === true
        ? props.reverse === true
        : props.reverse !== ($q.lang.rtl === true)
    ));

    const innerMin = vue.computed(() => (
      isNaN(props.innerMin) === true || props.innerMin < props.min
        ? props.min
        : props.innerMin
    ));
    const innerMax = vue.computed(() => (
      isNaN(props.innerMax) === true || props.innerMax > props.max
        ? props.max
        : props.innerMax
    ));

    const editable = vue.computed(() => (
      props.disable !== true && props.readonly !== true
      && innerMin.value < innerMax.value
    ));

    const decimals = vue.computed(() => (String(props.step).trim().split('.')[ 1 ] || '').length);
    const step = vue.computed(() => (props.step === 0 ? 1 : props.step));
    const tabindex = vue.computed(() => (editable.value === true ? props.tabindex || 0 : -1));

    const trackLen = vue.computed(() => props.max - props.min);
    const innerBarLen = vue.computed(() => innerMax.value - innerMin.value);

    const innerMinRatio = vue.computed(() => convertModelToRatio(innerMin.value));
    const innerMaxRatio = vue.computed(() => convertModelToRatio(innerMax.value));

    const positionProp = vue.computed(() => (
      props.vertical === true
        ? (isReversed.value === true ? 'bottom' : 'top')
        : (isReversed.value === true ? 'right' : 'left')
    ));

    const sizeProp = vue.computed(() => (props.vertical === true ? 'height' : 'width'));
    const thicknessProp = vue.computed(() => (props.vertical === true ? 'width' : 'height'));
    const orientation = vue.computed(() => (props.vertical === true ? 'vertical' : 'horizontal'));

    const attributes = vue.computed(() => {
      const acc = {
        role: 'slider',
        'aria-valuemin': innerMin.value,
        'aria-valuemax': innerMax.value,
        'aria-orientation': orientation.value,
        'data-step': props.step
      };

      if (props.disable === true) {
        acc[ 'aria-disabled' ] = 'true';
      }
      else if (props.readonly === true) {
        acc[ 'aria-readonly' ] = 'true';
      }

      return acc
    });

    const classes = vue.computed(() =>
      `q-slider q-slider${ axis.value } q-slider--${ active.value === true ? '' : 'in' }active inline no-wrap `
      + (props.vertical === true ? 'row' : 'column')
      + (props.disable === true ? ' disabled' : ' q-slider--enabled' + (editable.value === true ? ' q-slider--editable' : ''))
      + (focus.value === 'both' ? ' q-slider--focus' : '')
      + (props.label || props.labelAlways === true ? ' q-slider--label' : '')
      + (props.labelAlways === true ? ' q-slider--label-always' : '')
      + (isDark.value === true ? ' q-slider--dark' : '')
      + (props.dense === true ? ' q-slider--dense q-slider--dense' + axis.value : '')
    );

    function getPositionClass (name) {
      const cls = 'q-slider__' + name;
      return `${ cls } ${ cls }${ axis.value } ${ cls }${ axis.value }${ labelSide.value }`
    }
    function getAxisClass (name) {
      const cls = 'q-slider__' + name;
      return `${ cls } ${ cls }${ axis.value }`
    }

    const selectionBarClass = vue.computed(() => {
      const color = props.selectionColor || props.color;
      return 'q-slider__selection absolute'
        + (color !== void 0 ? ` text-${ color }` : '')
    });
    const markerClass = vue.computed(() => getAxisClass('markers') + ' absolute overflow-hidden');
    const trackContainerClass = vue.computed(() => getAxisClass('track-container'));
    const pinClass = vue.computed(() => getPositionClass('pin'));
    const labelClass = vue.computed(() => getPositionClass('label'));
    const textContainerClass = vue.computed(() => getPositionClass('text-container'));
    const markerLabelsContainerClass = vue.computed(() =>
      getPositionClass('marker-labels-container')
      + (props.markerLabelsClass !== void 0 ? ` ${ props.markerLabelsClass }` : '')
    );

    const trackClass = vue.computed(() =>
      'q-slider__track relative-position no-outline'
      + (props.trackColor !== void 0 ? ` bg-${ props.trackColor }` : '')
    );
    const trackStyle = vue.computed(() => {
      const acc = { [ thicknessProp.value ]: props.trackSize };
      if (props.trackImg !== void 0) {
        acc.backgroundImage = `url(${ props.trackImg }) !important`;
      }
      return acc
    });

    const innerBarClass = vue.computed(() =>
      'q-slider__inner absolute'
      + (props.innerTrackColor !== void 0 ? ` bg-${ props.innerTrackColor }` : '')
    );
    const innerBarStyle = vue.computed(() => {
      const acc = {
        [ positionProp.value ]: `${ 100 * innerMinRatio.value }%`,
        [ sizeProp.value ]: `${ 100 * (innerMaxRatio.value - innerMinRatio.value) }%`
      };
      if (props.innerTrackImg !== void 0) {
        acc.backgroundImage = `url(${ props.innerTrackImg }) !important`;
      }
      return acc
    });

    function convertRatioToModel (ratio) {
      const { min, max, step } = props;
      let model = min + ratio * (max - min);

      if (step > 0) {
        const modulo = (model - min) % step;
        model += (Math.abs(modulo) >= step / 2 ? (modulo < 0 ? -1 : 1) * step : 0) - modulo;
      }

      if (decimals.value > 0) {
        model = parseFloat(model.toFixed(decimals.value));
      }

      return between(model, innerMin.value, innerMax.value)
    }

    function convertModelToRatio (model) {
      return trackLen.value === 0
        ? 0
        : (model - props.min) / trackLen.value
    }

    function getDraggingRatio (evt, dragging) {
      const
        pos = position(evt),
        val = props.vertical === true
          ? between((pos.top - dragging.top) / dragging.height, 0, 1)
          : between((pos.left - dragging.left) / dragging.width, 0, 1);

      return between(
        isReversed.value === true ? 1.0 - val : val,
        innerMinRatio.value,
        innerMaxRatio.value
      )
    }

    const markerStep = vue.computed(() => (
      isNumber(props.markers) === true ? props.markers : step.value)
    );

    const markerTicks = vue.computed(() => {
      const acc = [];
      const step = markerStep.value;
      const max = props.max;

      let value = props.min;
      do {
        acc.push(value);
        value += step;
      } while (value < max)

      acc.push(max);
      return acc
    });

    const markerLabelClass = vue.computed(() => {
      const prefix = ` ${ markerPrefixClass }${ axis.value }-`;
      return markerPrefixClass
        + `${ prefix }${ props.switchMarkerLabelsSide === true ? 'switched' : 'standard' }`
        + `${ prefix }${ isReversed.value === true ? 'rtl' : 'ltr' }`
    });

    const markerLabelsList = vue.computed(() => {
      if (props.markerLabels === false) { return null }

      return getMarkerList(props.markerLabels).map((entry, index) => ({
        index,
        value: entry.value,
        label: entry.label || entry.value,
        classes: markerLabelClass.value
          + (entry.classes !== void 0 ? ' ' + entry.classes : ''),
        style: {
          ...getMarkerLabelStyle(entry.value),
          ...(entry.style || {})
        }
      }))
    });

    const markerScope = vue.computed(() => ({
      markerList: markerLabelsList.value,
      markerMap: markerLabelsMap.value,
      classes: markerLabelClass.value, // TODO ts definition
      getStyle: getMarkerLabelStyle
    }));

    const markerStyle = vue.computed(() => {
      if (innerBarLen.value !== 0) {
        const size = 100 * markerStep.value / innerBarLen.value;

        return {
          ...innerBarStyle.value,
          backgroundSize: props.vertical === true
            ? `2px ${ size }%`
            : `${ size }% 2px`
        }
      }

      return null
    });

    function getMarkerList (def) {
      if (def === false) { return null }

      if (def === true) {
        return markerTicks.value.map(defaultMarkerConvertFn)
      }

      if (typeof def === 'function') {
        return markerTicks.value.map(value => {
          const item = def(value);
          return isObject(item) === true ? { ...item, value } : { value, label: item }
        })
      }

      const filterFn = ({ value }) => value >= props.min && value <= props.max;

      if (Array.isArray(def) === true) {
        return def
          .map(item => (isObject(item) === true ? item : { value: item }))
          .filter(filterFn)
      }

      return Object.keys(def).map(key => {
        const item = def[ key ];
        const value = Number(key);
        return isObject(item) === true ? { ...item, value } : { value, label: item }
      }).filter(filterFn)
    }

    function getMarkerLabelStyle (val) {
      return { [ positionProp.value ]: `${ 100 * (val - props.min) / trackLen.value }%` }
    }

    const markerLabelsMap = vue.computed(() => {
      if (props.markerLabels === false) { return null }

      const acc = {};
      markerLabelsList.value.forEach(entry => {
        acc[ entry.value ] = entry;
      });
      return acc
    });

    function getMarkerLabelsContent () {
      if (slots[ 'marker-label-group' ] !== void 0) {
        return slots[ 'marker-label-group' ](markerScope.value)
      }

      const fn = slots[ 'marker-label' ] || defaultMarkerLabelRenderFn;
      return markerLabelsList.value.map(marker => fn({
        marker,
        ...markerScope.value
      }))
    }

    const panDirective = vue.computed(() => {
      // if editable.value === true
      return [ [
        TouchPan,
        onPan,
        void 0,
        {
          [ orientation.value ]: true,
          prevent: true,
          stop: true,
          mouse: true,
          mouseAllDir: true
        }
      ] ]
    });

    function onPan (event) {
      if (event.isFinal === true) {
        if (dragging.value !== void 0) {
          updatePosition(event.evt);
          // only if touch, because we also have mousedown/up:
          event.touch === true && updateValue(true);
          dragging.value = void 0;
          emit('pan', 'end');
        }
        active.value = false;
        focus.value = false;
      }
      else if (event.isFirst === true) {
        dragging.value = getDragging(event.evt);
        updatePosition(event.evt);
        updateValue();
        active.value = true;
        emit('pan', 'start');
      }
      else {
        updatePosition(event.evt);
        updateValue();
      }
    }

    function onBlur () {
      focus.value = false;
    }

    function onActivate (evt) {
      updatePosition(evt, getDragging(evt));
      updateValue();

      preventFocus.value = true;
      active.value = true;

      document.addEventListener('mouseup', onDeactivate, true);
    }

    function onDeactivate () {
      preventFocus.value = false;
      active.value = false;

      updateValue(true);
      onBlur();

      document.removeEventListener('mouseup', onDeactivate, true);
    }

    function onMobileClick (evt) {
      updatePosition(evt, getDragging(evt));
      updateValue(true);
    }

    function onKeyup (evt) {
      if (keyCodes$2.includes(evt.keyCode)) {
        updateValue(true);
      }
    }

    function getTextContainerStyle (ratio) {
      if (props.vertical === true) { return null }

      const p = $q.lang.rtl !== props.reverse ? 1 - ratio : ratio;
      return {
        transform: `translateX(calc(${ 2 * p - 1 } * ${ props.thumbSize } / 2 + ${ 50 - 100 * p }%))`
      }
    }

    function getThumbRenderFn (thumb) {
      const focusClass = vue.computed(() => (
        preventFocus.value === false && (focus.value === thumb.focusValue || focus.value === 'both')
          ? ' q-slider--focus'
          : ''
      ));

      const classes = vue.computed(() =>
        `q-slider__thumb q-slider__thumb${ axis.value } q-slider__thumb${ axis.value }-${ isReversed.value === true ? 'rtl' : 'ltr' } absolute non-selectable`
        + focusClass.value
        + (thumb.thumbColor.value !== void 0 ? ` text-${ thumb.thumbColor.value }` : '')
      );

      const style = vue.computed(() => ({
        width: props.thumbSize,
        height: props.thumbSize,
        [ positionProp.value ]: `${ 100 * thumb.ratio.value }%`,
        zIndex: focus.value === thumb.focusValue ? 2 : void 0
      }));

      const pinColor = vue.computed(() => (
        thumb.labelColor.value !== void 0
          ? ` text-${ thumb.labelColor.value }`
          : ''
      ));

      const textContainerStyle = vue.computed(() => getTextContainerStyle(thumb.ratio.value));

      const textClass = vue.computed(() => (
        'q-slider__text'
        + (thumb.labelTextColor.value !== void 0 ? ` text-${ thumb.labelTextColor.value }` : '')
      ));

      return () => {
        const thumbContent = [
          vue.h('svg', {
            class: 'q-slider__thumb-shape absolute-full',
            viewBox: '0 0 20 20',
            'aria-hidden': 'true'
          }, [
            vue.h('path', { d: props.thumbPath })
          ]),

          vue.h('div', { class: 'q-slider__focus-ring fit' })
        ];

        if (props.label === true || props.labelAlways === true) {
          thumbContent.push(
            vue.h('div', {
              class: pinClass.value + ' absolute fit no-pointer-events' + pinColor.value
            }, [
              vue.h('div', {
                class: labelClass.value,
                style: { minWidth: props.thumbSize }
              }, [
                vue.h('div', {
                  class: textContainerClass.value,
                  style: textContainerStyle.value
                }, [
                  vue.h('span', { class: textClass.value }, thumb.label.value)
                ])
              ])
            ])
          );

          if (props.name !== void 0 && props.disable !== true) {
            injectFormInput(thumbContent, 'push');
          }
        }

        return vue.h('div', {
          class: classes.value,
          style: style.value,
          ...thumb.getNodeData()
        }, thumbContent)
      }
    }

    function getContent (selectionBarStyle, trackContainerTabindex, trackContainerEvents, injectThumb) {
      const trackContent = [];

      props.innerTrackColor !== 'transparent' && trackContent.push(
        vue.h('div', {
          key: 'inner',
          class: innerBarClass.value,
          style: innerBarStyle.value
        })
      );

      props.selectionColor !== 'transparent' && trackContent.push(
        vue.h('div', {
          key: 'selection',
          class: selectionBarClass.value,
          style: selectionBarStyle.value
        })
      );

      props.markers !== false && trackContent.push(
        vue.h('div', {
          key: 'marker',
          class: markerClass.value,
          style: markerStyle.value
        })
      );

      injectThumb(trackContent);

      const content = [
        hDir(
          'div',
          {
            key: 'trackC',
            class: trackContainerClass.value,
            tabindex: trackContainerTabindex.value,
            ...trackContainerEvents.value
          },
          [
            vue.h('div', {
              class: trackClass.value,
              style: trackStyle.value
            }, trackContent)
          ],
          'slide',
          editable.value, () => panDirective.value
        )
      ];

      if (props.markerLabels !== false) {
        const action = props.switchMarkerLabelsSide === true
          ? 'unshift'
          : 'push';

        content[ action ](
          vue.h('div', {
            key: 'markerL',
            class: markerLabelsContainerClass.value
          }, getMarkerLabelsContent())
        );
      }

      return content
    }

    vue.onBeforeUnmount(() => {
      document.removeEventListener('mouseup', onDeactivate, true);
    });

    return {
      state: {
        active,
        focus,
        preventFocus,
        dragging,

        editable,
        classes,
        tabindex,
        attributes,

        step,
        decimals,
        trackLen,
        innerMin,
        innerMinRatio,
        innerMax,
        innerMaxRatio,
        positionProp,
        sizeProp,
        isReversed
      },

      methods: {
        onActivate,
        onMobileClick,
        onBlur,
        onKeyup,
        getContent,
        getThumbRenderFn,
        convertRatioToModel,
        convertModelToRatio,
        getDraggingRatio
      }
    }
  }

  const getNodeData = () => ({});

  var QSlider = createComponent({
    name: 'QSlider',

    props: {
      ...useSliderProps,

      modelValue: {
        required: true,
        default: null,
        validator: v => typeof v === 'number' || v === null
      },

      labelValue: [ String, Number ]
    },

    emits: useSliderEmits,

    setup (props, { emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const { state, methods } = useSlider({
        updateValue, updatePosition, getDragging,
        formAttrs: useFormAttrs(props)
      });

      const rootRef = vue.ref(null);
      const curRatio = vue.ref(0);
      const model = vue.ref(0);

      function normalizeModel () {
        model.value = props.modelValue === null
          ? state.innerMin.value
          : between(props.modelValue, state.innerMin.value, state.innerMax.value);
      }

      vue.watch(
        () => `${ props.modelValue }|${ state.innerMin.value }|${ state.innerMax.value }`,
        normalizeModel
      );

      normalizeModel();

      const modelRatio = vue.computed(() => methods.convertModelToRatio(model.value));
      const ratio = vue.computed(() => (state.active.value === true ? curRatio.value : modelRatio.value));

      const selectionBarStyle = vue.computed(() => {
        const acc = {
          [ state.positionProp.value ]: `${ 100 * state.innerMinRatio.value }%`,
          [ state.sizeProp.value ]: `${ 100 * (ratio.value - state.innerMinRatio.value) }%`
        };
        if (props.selectionImg !== void 0) {
          acc.backgroundImage = `url(${ props.selectionImg }) !important`;
        }
        return acc
      });

      const getThumb = methods.getThumbRenderFn({
        focusValue: true,
        getNodeData,
        ratio,
        label: vue.computed(() => (
          props.labelValue !== void 0
            ? props.labelValue
            : model.value
        )),
        thumbColor: vue.computed(() => props.thumbColor || props.color),
        labelColor: vue.computed(() => props.labelColor),
        labelTextColor: vue.computed(() => props.labelTextColor)
      });

      const trackContainerEvents = vue.computed(() => {
        if (state.editable.value !== true) {
          return {}
        }

        return $q.platform.is.mobile === true
          ? { onClick: methods.onMobileClick }
          : {
              onMousedown: methods.onActivate,
              onFocus,
              onBlur: methods.onBlur,
              onKeydown,
              onKeyup: methods.onKeyup
            }
      });

      function updateValue (change) {
        if (model.value !== props.modelValue) {
          emit('update:modelValue', model.value);
        }
        change === true && emit('change', model.value);
      }

      function getDragging () {
        return rootRef.value.getBoundingClientRect()
      }

      function updatePosition (event, dragging = state.dragging.value) {
        const ratio = methods.getDraggingRatio(event, dragging);

        model.value = methods.convertRatioToModel(ratio);

        curRatio.value = props.snap !== true || props.step === 0
          ? ratio
          : methods.convertModelToRatio(model.value);
      }

      function onFocus () {
        state.focus.value = true;
      }

      function onKeydown (evt) {
        if (!keyCodes$2.includes(evt.keyCode)) {
          return
        }

        stopAndPrevent(evt);

        const
          stepVal = ([ 34, 33 ].includes(evt.keyCode) ? 10 : 1) * state.step.value,
          offset = (
            ([ 34, 37, 40 ].includes(evt.keyCode) ? -1 : 1)
            * (state.isReversed.value === true ? -1 : 1)
            * (props.vertical === true ? -1 : 1) * stepVal
          );

        model.value = between(
          parseFloat((model.value + offset).toFixed(state.decimals.value)),
          state.innerMin.value,
          state.innerMax.value
        );

        updateValue();
      }

      return () => {
        const content = methods.getContent(
          selectionBarStyle,
          state.tabindex,
          trackContainerEvents,
          node => { node.push(getThumb()); }
        );

        return vue.h('div', {
          ref: rootRef,
          class: state.classes.value + (props.modelValue === null ? ' q-slider--no-value' : ''),
          ...state.attributes.value,
          'aria-valuenow': props.modelValue
        }, content)
      }
    }
  });

  function useCanRender () {
    const canRender = vue.ref(!isRuntimeSsrPreHydration.value);

    if (canRender.value === false) {
      vue.onMounted(() => {
        canRender.value = true;
      });
    }

    return canRender
  }

  const hasObserver = typeof ResizeObserver !== 'undefined';
  const resizeProps = hasObserver === true
    ? {}
    : {
        style: 'display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;',
        url: 'about:blank'
      };

  var QResizeObserver = createComponent({
    name: 'QResizeObserver',

    props: {
      debounce: {
        type: [ String, Number ],
        default: 100
      }
    },

    emits: [ 'resize' ],

    setup (props, { emit }) {

      let timer = null, targetEl, size = { width: -1, height: -1 };

      function trigger (immediately) {
        if (immediately === true || props.debounce === 0 || props.debounce === '0') {
          emitEvent();
        }
        else if (timer === null) {
          timer = setTimeout(emitEvent, props.debounce);
        }
      }

      function emitEvent () {
        if (timer !== null) {
          clearTimeout(timer);
          timer = null;
        }

        if (targetEl) {
          const { offsetWidth: width, offsetHeight: height } = targetEl;

          if (width !== size.width || height !== size.height) {
            size = { width, height };
            emit('resize', size);
          }
        }
      }

      const { proxy } = vue.getCurrentInstance();

      if (hasObserver === true) {
        let observer;

        // initialize as soon as possible
        const init = stop => {
          targetEl = proxy.$el.parentNode;

          if (targetEl) {
            observer = new ResizeObserver(trigger);
            observer.observe(targetEl);
            emitEvent();
          }
          else if (stop !== true) {
            vue.nextTick(() => { init(true); });
          }
        };

        vue.onMounted(() => { init(); });

        vue.onBeforeUnmount(() => {
          timer !== null && clearTimeout(timer);

          if (observer !== void 0) {
            if (observer.disconnect !== void 0) {
              observer.disconnect();
            }
            else if (targetEl) { // FF for Android
              observer.unobserve(targetEl);
            }
          }
        });

        return noop
      }
      else { // no observer, so fallback to old iframe method
        const canRender = useCanRender();

        let curDocView;

        function cleanup () {
          if (timer !== null) {
            clearTimeout(timer);
            timer = null;
          }

          if (curDocView !== void 0) {
            // iOS is fuzzy, need to check it first
            if (curDocView.removeEventListener !== void 0) {
              curDocView.removeEventListener('resize', trigger, listenOpts.passive);
            }
            curDocView = void 0;
          }
        }

        function onObjLoad () {
          cleanup();

          if (targetEl && targetEl.contentDocument) {
            curDocView = targetEl.contentDocument.defaultView;
            curDocView.addEventListener('resize', trigger, listenOpts.passive);
            emitEvent();
          }
        }

        vue.onMounted(() => {
          vue.nextTick(() => {
            targetEl = proxy.$el;
            targetEl && onObjLoad();
          });
        });

        vue.onBeforeUnmount(cleanup);

        // expose public method
        proxy.trigger = trigger;

        return () => {
          if (canRender.value === true) {
            return vue.h('object', {
              style: resizeProps.style,
              tabindex: -1, // fix for Firefox
              type: 'text/html',
              data: resizeProps.url,
              'aria-hidden': 'true',
              onLoad: onObjLoad
            })
          }
        }
      }
    }
  });

  let rtlHasScrollBug = false;

  // mobile Chrome takes the crown for this
  {
    const scroller = document.createElement('div');
    scroller.setAttribute('dir', 'rtl');
    Object.assign(scroller.style, {
      width: '1px',
      height: '1px',
      overflow: 'auto'
    });

    const spacer = document.createElement('div');
    Object.assign(spacer.style, {
      width: '1000px',
      height: '1px'
    });

    document.body.appendChild(scroller);
    scroller.appendChild(spacer);
    scroller.scrollLeft = -1000;

    rtlHasScrollBug = scroller.scrollLeft >= 0;

    scroller.remove();
  }

  function getIndicatorClass (color, top, vertical) {
    const pos = vertical === true
      ? [ 'left', 'right' ]
      : [ 'top', 'bottom' ];

    return `absolute-${ top === true ? pos[ 0 ] : pos[ 1 ] }${ color ? ` text-${ color }` : '' }`
  }

  const alignValues$1 = [ 'left', 'center', 'right', 'justify' ];

  var QTabs = createComponent({
    name: 'QTabs',

    props: {
      modelValue: [ Number, String ],

      align: {
        type: String,
        default: 'center',
        validator: v => alignValues$1.includes(v)
      },
      breakpoint: {
        type: [ String, Number ],
        default: 600
      },

      vertical: Boolean,
      shrink: Boolean,
      stretch: Boolean,

      activeClass: String,
      activeColor: String,
      activeBgColor: String,
      indicatorColor: String,
      leftIcon: String,
      rightIcon: String,

      outsideArrows: Boolean,
      mobileArrows: Boolean,

      switchIndicator: Boolean,

      narrowIndicator: Boolean,
      inlineLabel: Boolean,
      noCaps: Boolean,

      dense: Boolean,

      contentClass: String,

      'onUpdate:modelValue': [ Function, Array ]
    },

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const { registerTick: registerScrollTick } = useTick();
      const { registerTick: registerUpdateArrowsTick } = useTick();
      const { registerTick: registerAnimateTick } = useTick();

      const { registerTimeout: registerFocusTimeout, removeTimeout: removeFocusTimeout } = useTimeout();
      const { registerTimeout: registerScrollToTabTimeout, removeTimeout: removeScrollToTabTimeout } = useTimeout();

      const rootRef = vue.ref(null);
      const contentRef = vue.ref(null);

      const currentModel = vue.ref(props.modelValue);
      const scrollable = vue.ref(false);
      const leftArrow = vue.ref(true);
      const rightArrow = vue.ref(false);
      const justify = vue.ref(false);

      const tabDataList = [];
      const tabDataListLen = vue.ref(0);
      const hasFocus = vue.ref(false);

      let animateTimer = null, scrollTimer = null, unwatchRoute;

      const tabProps = vue.computed(() => ({
        activeClass: props.activeClass,
        activeColor: props.activeColor,
        activeBgColor: props.activeBgColor,
        indicatorClass: getIndicatorClass(
          props.indicatorColor,
          props.switchIndicator,
          props.vertical
        ),
        narrowIndicator: props.narrowIndicator,
        inlineLabel: props.inlineLabel,
        noCaps: props.noCaps
      }));

      const hasActiveTab = vue.computed(() => {
        const len = tabDataListLen.value;
        const val = currentModel.value;

        for (let i = 0; i < len; i++) {
          if (tabDataList[ i ].name.value === val) {
            return true
          }
        }

        return false
      });

      const alignClass = vue.computed(() => {
        const align = scrollable.value === true
          ? 'left'
          : (justify.value === true ? 'justify' : props.align);

        return `q-tabs__content--align-${ align }`
      });

      const classes = vue.computed(() =>
        'q-tabs row no-wrap items-center'
        + ` q-tabs--${ scrollable.value === true ? '' : 'not-' }scrollable`
        + ` q-tabs--${ props.vertical === true ? 'vertical' : 'horizontal' }`
        + ` q-tabs__arrows--${ props.outsideArrows === true ? 'outside' : 'inside' }`
        + ` q-tabs--mobile-with${ props.mobileArrows === true ? '' : 'out' }-arrows`
        + (props.dense === true ? ' q-tabs--dense' : '')
        + (props.shrink === true ? ' col-shrink' : '')
        + (props.stretch === true ? ' self-stretch' : '')
      );

      const innerClass = vue.computed(() =>
        'q-tabs__content scroll--mobile row no-wrap items-center self-stretch hide-scrollbar relative-position '
        + alignClass.value
        + (props.contentClass !== void 0 ? ` ${ props.contentClass }` : '')
      );

      const domProps = vue.computed(() => (
        props.vertical === true
          ? { container: 'height', content: 'offsetHeight', scroll: 'scrollHeight' }
          : { container: 'width', content: 'offsetWidth', scroll: 'scrollWidth' }
      ));

      const isRTL = vue.computed(() => props.vertical !== true && $q.lang.rtl === true);
      const rtlPosCorrection = vue.computed(() => rtlHasScrollBug === false && isRTL.value === true);

      vue.watch(isRTL, updateArrows);

      vue.watch(() => props.modelValue, name => {
        updateModel({ name, setCurrent: true, skipEmit: true });
      });

      vue.watch(() => props.outsideArrows, recalculateScroll);

      function updateModel ({ name, setCurrent, skipEmit }) {
        if (currentModel.value !== name) {
          if (skipEmit !== true && props[ 'onUpdate:modelValue' ] !== void 0) {
            emit('update:modelValue', name);
          }

          if (
            setCurrent === true
            || props[ 'onUpdate:modelValue' ] === void 0
          ) {
            animate(currentModel.value, name);
            currentModel.value = name;
          }
        }
      }

      function recalculateScroll () {
        registerScrollTick(() => {
          updateContainer({
            width: rootRef.value.offsetWidth,
            height: rootRef.value.offsetHeight
          });
        });
      }

      function updateContainer (domSize) {
        // it can be called faster than component being initialized
        // so we need to protect against that case
        // (one example of such case is the docs release notes page)
        if (domProps.value === void 0 || contentRef.value === null) { return }

        const
          size = domSize[ domProps.value.container ],
          scrollSize = Math.min(
            contentRef.value[ domProps.value.scroll ],
            Array.prototype.reduce.call(
              contentRef.value.children,
              (acc, el) => acc + (el[ domProps.value.content ] || 0),
              0
            )
          ),
          scroll = size > 0 && scrollSize > size; // when there is no tab, in Chrome, size === 0 and scrollSize === 1

        scrollable.value = scroll;

        // Arrows need to be updated even if the scroll status was already true
        scroll === true && registerUpdateArrowsTick(updateArrows);

        justify.value = size < parseInt(props.breakpoint, 10);
      }

      function animate (oldName, newName) {
        const
          oldTab = oldName !== void 0 && oldName !== null && oldName !== ''
            ? tabDataList.find(tab => tab.name.value === oldName)
            : null,
          newTab = newName !== void 0 && newName !== null && newName !== ''
            ? tabDataList.find(tab => tab.name.value === newName)
            : null;

        if (oldTab && newTab) {
          const
            oldEl = oldTab.tabIndicatorRef.value,
            newEl = newTab.tabIndicatorRef.value;

          if (animateTimer !== null) {
            clearTimeout(animateTimer);
            animateTimer = null;
          }

          oldEl.style.transition = 'none';
          oldEl.style.transform = 'none';
          newEl.style.transition = 'none';
          newEl.style.transform = 'none';

          const
            oldPos = oldEl.getBoundingClientRect(),
            newPos = newEl.getBoundingClientRect();

          newEl.style.transform = props.vertical === true
            ? `translate3d(0,${ oldPos.top - newPos.top }px,0) scale3d(1,${ newPos.height ? oldPos.height / newPos.height : 1 },1)`
            : `translate3d(${ oldPos.left - newPos.left }px,0,0) scale3d(${ newPos.width ? oldPos.width / newPos.width : 1 },1,1)`;

          // allow scope updates to kick in (QRouteTab needs more time)
          registerAnimateTick(() => {
            animateTimer = setTimeout(() => {
              animateTimer = null;
              newEl.style.transition = 'transform .25s cubic-bezier(.4, 0, .2, 1)';
              newEl.style.transform = 'none';
            }, 70);
          });
        }

        if (newTab && scrollable.value === true) {
          scrollToTabEl(newTab.rootRef.value);
        }
      }

      function scrollToTabEl (el) {
        const
          { left, width, top, height } = contentRef.value.getBoundingClientRect(),
          newPos = el.getBoundingClientRect();

        let offset = props.vertical === true ? newPos.top - top : newPos.left - left;

        if (offset < 0) {
          contentRef.value[ props.vertical === true ? 'scrollTop' : 'scrollLeft' ] += Math.floor(offset);
          updateArrows();
          return
        }

        offset += props.vertical === true ? newPos.height - height : newPos.width - width;
        if (offset > 0) {
          contentRef.value[ props.vertical === true ? 'scrollTop' : 'scrollLeft' ] += Math.ceil(offset);
          updateArrows();
        }
      }

      function updateArrows () {
        const content = contentRef.value;
        if (content === null) { return }

        const
          rect = content.getBoundingClientRect(),
          pos = props.vertical === true ? content.scrollTop : Math.abs(content.scrollLeft);

        if (isRTL.value === true) {
          leftArrow.value = Math.ceil(pos + rect.width) < content.scrollWidth - 1;
          rightArrow.value = pos > 0;
        }
        else {
          leftArrow.value = pos > 0;
          rightArrow.value = props.vertical === true
            ? Math.ceil(pos + rect.height) < content.scrollHeight
            : Math.ceil(pos + rect.width) < content.scrollWidth;
        }
      }

      function animScrollTo (value) {
        scrollTimer !== null && clearInterval(scrollTimer);
        scrollTimer = setInterval(() => {
          if (scrollTowards(value) === true) {
            stopAnimScroll();
          }
        }, 5);
      }

      function scrollToStart () {
        animScrollTo(rtlPosCorrection.value === true ? Number.MAX_SAFE_INTEGER : 0);
      }

      function scrollToEnd () {
        animScrollTo(rtlPosCorrection.value === true ? 0 : Number.MAX_SAFE_INTEGER);
      }

      function stopAnimScroll () {
        if (scrollTimer !== null) {
          clearInterval(scrollTimer);
          scrollTimer = null;
        }
      }

      function onKbdNavigate (keyCode, fromEl) {
        const tabs = Array.prototype.filter.call(
          contentRef.value.children,
          el => el === fromEl || (el.matches && el.matches('.q-tab.q-focusable') === true)
        );

        const len = tabs.length;
        if (len === 0) { return }

        if (keyCode === 36) { // Home
          scrollToTabEl(tabs[ 0 ]);
          tabs[ 0 ].focus();
          return true
        }
        if (keyCode === 35) { // End
          scrollToTabEl(tabs[ len - 1 ]);
          tabs[ len - 1 ].focus();
          return true
        }

        const dirPrev = keyCode === (props.vertical === true ? 38 /* ArrowUp */ : 37 /* ArrowLeft */);
        const dirNext = keyCode === (props.vertical === true ? 40 /* ArrowDown */ : 39 /* ArrowRight */);

        const dir = dirPrev === true ? -1 : (dirNext === true ? 1 : void 0);

        if (dir !== void 0) {
          const rtlDir = isRTL.value === true ? -1 : 1;
          const index = tabs.indexOf(fromEl) + dir * rtlDir;

          if (index >= 0 && index < len) {
            scrollToTabEl(tabs[ index ]);
            tabs[ index ].focus({ preventScroll: true });
          }

          return true
        }
      }

      // let's speed up execution of time-sensitive scrollTowards()
      // with a computed variable by directly applying the minimal
      // number of instructions on get/set functions
      const posFn = vue.computed(() => (
        rtlPosCorrection.value === true
          ? { get: content => Math.abs(content.scrollLeft), set: (content, pos) => { content.scrollLeft = -pos; } }
          : (
              props.vertical === true
                ? { get: content => content.scrollTop, set: (content, pos) => { content.scrollTop = pos; } }
                : { get: content => content.scrollLeft, set: (content, pos) => { content.scrollLeft = pos; } }
            )
      ));

      function scrollTowards (value) {
        const
          content = contentRef.value,
          { get, set } = posFn.value;

        let
          done = false,
          pos = get(content);

        const direction = value < pos ? -1 : 1;

        pos += direction * 5;

        if (pos < 0) {
          done = true;
          pos = 0;
        }
        else if (
          (direction === -1 && pos <= value)
          || (direction === 1 && pos >= value)
        ) {
          done = true;
          pos = value;
        }

        set(content, pos);
        updateArrows();

        return done
      }

      function hasQueryIncluded (targetQuery, matchingQuery) {
        for (const key in targetQuery) {
          if (targetQuery[ key ] !== matchingQuery[ key ]) {
            return false
          }
        }

        return true
      }

      // do not use directly; use verifyRouteModel() instead
      function updateActiveRoute () {
        let name = null, bestScore = { matchedLen: 0, queryDiff: 9999, hrefLen: 0 };

        const list = tabDataList.filter(tab => tab.routeData !== void 0 && tab.routeData.hasRouterLink.value === true);
        const { hash: currentHash, query: currentQuery } = proxy.$route;
        const currentQueryLen = Object.keys(currentQuery).length;

        // Vue Router does not keep account of hash & query when matching
        // so we're doing this as well

        for (const tab of list) {
          const exact = tab.routeData.exact.value === true;

          if (tab.routeData[ exact === true ? 'linkIsExactActive' : 'linkIsActive' ].value !== true) {
            // it cannot match anything as it's not active nor exact-active
            continue
          }

          const { hash, query, matched, href } = tab.routeData.resolvedLink.value;
          const queryLen = Object.keys(query).length;

          if (exact === true) {
            if (hash !== currentHash) {
              // it's set to exact but it doesn't matches the hash
              continue
            }

            if (
              queryLen !== currentQueryLen
              || hasQueryIncluded(currentQuery, query) === false
            ) {
              // it's set to exact but it doesn't matches the query
              continue
            }

            // yey, we found the perfect match (route + hash + query)
            name = tab.name.value;
            break
          }

          if (hash !== '' && hash !== currentHash) {
            // it has hash and it doesn't matches
            continue
          }

          if (
            queryLen !== 0
            && hasQueryIncluded(query, currentQuery) === false
          ) {
            // it has query and it doesn't includes the current one
            continue
          }

          const newScore = {
            matchedLen: matched.length,
            queryDiff: currentQueryLen - queryLen,
            hrefLen: href.length - hash.length
          };

          if (newScore.matchedLen > bestScore.matchedLen) {
            // it matches more routes so it's more specific so we set it as current champion
            name = tab.name.value;
            bestScore = newScore;
            continue
          }
          else if (newScore.matchedLen !== bestScore.matchedLen) {
            // it matches less routes than the current champion so we discard it
            continue
          }

          if (newScore.queryDiff < bestScore.queryDiff) {
            // query is closer to the current one so we set it as current champion
            name = tab.name.value;
            bestScore = newScore;
          }
          else if (newScore.queryDiff !== bestScore.queryDiff) {
            // it matches less routes than the current champion so we discard it
            continue
          }

          if (newScore.hrefLen > bestScore.hrefLen) {
            // href is lengthier so it's more specific so we set it as current champion
            name = tab.name.value;
            bestScore = newScore;
          }
        }

        if (
          name === null
          && tabDataList.some(tab => tab.routeData === void 0 && tab.name.value === currentModel.value) === true
        ) {
          // we shouldn't interfere if non-route tab is active
          return
        }

        updateModel({ name, setCurrent: true });
      }

      function onFocusin (e) {
        removeFocusTimeout();

        if (
          hasFocus.value !== true
          && rootRef.value !== null
          && e.target
          && typeof e.target.closest === 'function'
        ) {
          const tab = e.target.closest('.q-tab');

          // if the target is contained by a QTab/QRouteTab
          // (it might be other elements focused, like additional QBtn)
          if (tab && rootRef.value.contains(tab) === true) {
            hasFocus.value = true;
            scrollable.value === true && scrollToTabEl(tab);
          }
        }
      }

      function onFocusout () {
        registerFocusTimeout(() => { hasFocus.value = false; }, 30);
      }

      function verifyRouteModel () {
        if ($tabs.avoidRouteWatcher === false) {
          registerScrollToTabTimeout(updateActiveRoute);
        }
        else {
          removeScrollToTabTimeout();
        }
      }

      function watchRoute () {
        if (unwatchRoute === void 0) {
          const unwatch = vue.watch(() => proxy.$route.fullPath, verifyRouteModel);
          unwatchRoute = () => {
            unwatch();
            unwatchRoute = void 0;
          };
        }
      }

      function registerTab (tabData) {
        tabDataList.push(tabData);
        tabDataListLen.value++;

        recalculateScroll();

        // if it's a QTab or we don't have Vue Router
        if (tabData.routeData === void 0 || proxy.$route === void 0) {
          // we should position to the currently active tab (if any)
          registerScrollToTabTimeout(() => {
            if (scrollable.value === true) {
              const value = currentModel.value;
              const newTab = value !== void 0 && value !== null && value !== ''
                ? tabDataList.find(tab => tab.name.value === value)
                : null;

              newTab && scrollToTabEl(newTab.rootRef.value);
            }
          });
        }
        // else if it's a QRouteTab with a valid link
        else {
          // start watching route
          watchRoute();

          if (tabData.routeData.hasRouterLink.value === true) {
            verifyRouteModel();
          }
        }
      }

      function unregisterTab (tabData) {
        tabDataList.splice(tabDataList.indexOf(tabData), 1);
        tabDataListLen.value--;

        recalculateScroll();

        if (unwatchRoute !== void 0 && tabData.routeData !== void 0) {
          // unwatch route if we don't have any QRouteTabs left
          if (tabDataList.every(tab => tab.routeData === void 0) === true) {
            unwatchRoute();
          }

          // then update model
          verifyRouteModel();
        }
      }

      const $tabs = {
        currentModel,
        tabProps,
        hasFocus,
        hasActiveTab,

        registerTab,
        unregisterTab,

        verifyRouteModel,
        updateModel,
        onKbdNavigate,

        avoidRouteWatcher: false // false | string (uid)
      };

      vue.provide(tabsKey, $tabs);

      function cleanup () {
        animateTimer !== null && clearTimeout(animateTimer);
        stopAnimScroll();
        unwatchRoute !== void 0 && unwatchRoute();
      }

      let hadRouteWatcher;

      vue.onBeforeUnmount(cleanup);

      vue.onDeactivated(() => {
        hadRouteWatcher = unwatchRoute !== void 0;
        cleanup();
      });

      vue.onActivated(() => {
        hadRouteWatcher === true && watchRoute();
        recalculateScroll();
      });

      return () => {
        return vue.h('div', {
          ref: rootRef,
          class: classes.value,
          role: 'tablist',
          onFocusin,
          onFocusout
        }, [
          vue.h(QResizeObserver, { onResize: updateContainer }),

          vue.h('div', {
            ref: contentRef,
            class: innerClass.value,
            onScroll: updateArrows
          }, hSlot(slots.default)),

          vue.h(QIcon, {
            class: 'q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon'
              + (leftArrow.value === true ? '' : ' q-tabs__arrow--faded'),
            name: props.leftIcon || $q.iconSet.tabs[ props.vertical === true ? 'up' : 'left' ],
            onMousedownPassive: scrollToStart,
            onTouchstartPassive: scrollToStart,
            onMouseupPassive: stopAnimScroll,
            onMouseleavePassive: stopAnimScroll,
            onTouchendPassive: stopAnimScroll
          }),

          vue.h(QIcon, {
            class: 'q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon'
              + (rightArrow.value === true ? '' : ' q-tabs__arrow--faded'),
            name: props.rightIcon || $q.iconSet.tabs[ props.vertical === true ? 'down' : 'right' ],
            onMousedownPassive: scrollToEnd,
            onTouchstartPassive: scrollToEnd,
            onMouseupPassive: stopAnimScroll,
            onMouseleavePassive: stopAnimScroll,
            onTouchendPassive: stopAnimScroll
          })
        ])
      }
    }
  });

  let id$1 = 0;

  const useTabEmits = [ 'click', 'keydown' ];

  const useTabProps = {
    icon: String,
    label: [ Number, String ],

    alert: [ Boolean, String ],
    alertIcon: String,

    name: {
      type: [ Number, String ],
      default: () => `t_${ id$1++ }`
    },

    noCaps: Boolean,

    tabindex: [ String, Number ],
    disable: Boolean,

    contentClass: String,

    ripple: {
      type: [ Boolean, Object ],
      default: true
    }
  };

  function useTab (props, slots, emit, routeData) {
    const $tabs = vue.inject(tabsKey, emptyRenderFn);
    if ($tabs === emptyRenderFn) {
      console.error('QTab/QRouteTab component needs to be child of QTabs');
      return emptyRenderFn
    }

    const { proxy } = vue.getCurrentInstance();

    const blurTargetRef = vue.ref(null);
    const rootRef = vue.ref(null);
    const tabIndicatorRef = vue.ref(null);

    const ripple = vue.computed(() => (
      props.disable === true || props.ripple === false
        ? false
        : Object.assign(
          { keyCodes: [ 13, 32 ], early: true },
          props.ripple === true ? {} : props.ripple
        )
    ));

    const isActive = vue.computed(() => $tabs.currentModel.value === props.name);

    const classes = vue.computed(() =>
      'q-tab relative-position self-stretch flex flex-center text-center'
      + (
        isActive.value === true
          ? (
              ' q-tab--active'
              + ($tabs.tabProps.value.activeClass ? ' ' + $tabs.tabProps.value.activeClass : '')
              + ($tabs.tabProps.value.activeColor ? ` text-${ $tabs.tabProps.value.activeColor }` : '')
              + ($tabs.tabProps.value.activeBgColor ? ` bg-${ $tabs.tabProps.value.activeBgColor }` : '')
            )
          : ' q-tab--inactive'
      )
      + (props.icon && props.label && $tabs.tabProps.value.inlineLabel === false ? ' q-tab--full' : '')
      + (props.noCaps === true || $tabs.tabProps.value.noCaps === true ? ' q-tab--no-caps' : '')
      + (props.disable === true ? ' disabled' : ' q-focusable q-hoverable cursor-pointer')
      + (routeData !== void 0 ? routeData.linkClass.value : '')
    );

    const innerClass = vue.computed(() =>
      'q-tab__content self-stretch flex-center relative-position q-anchor--skip non-selectable '
      + ($tabs.tabProps.value.inlineLabel === true ? 'row no-wrap q-tab__content--inline' : 'column')
      + (props.contentClass !== void 0 ? ` ${ props.contentClass }` : '')
    );

    const tabIndex = vue.computed(() => (
      (
        props.disable === true
        || $tabs.hasFocus.value === true
        || (isActive.value === false && $tabs.hasActiveTab.value === true)
      )
        ? -1
        : props.tabindex || 0
    ));

    function onClick (e, keyboard) {
      if (keyboard !== true && blurTargetRef.value !== null) {
        blurTargetRef.value.focus();
      }

      if (props.disable === true) {
        // we should hinder native navigation though
        if (routeData !== void 0 && routeData.hasRouterLink.value === true) {
          stopAndPrevent(e);
        }
        return
      }

      // do we have a QTab?
      if (routeData === void 0) {
        $tabs.updateModel({ name: props.name });
        emit('click', e);
        return
      }

      if (routeData.hasRouterLink.value === true) {
        const go = (opts = {}) => {
          // if requiring to go to another route, then we
          // let the QTabs route watcher do its job,
          // otherwise directly select this
          let hardError;
          const reqId = opts.to === void 0 || isDeepEqual(opts.to, props.to) === true
            ? ($tabs.avoidRouteWatcher = uid$3())
            : null;

          return routeData.navigateToRouterLink(e, { ...opts, returnRouterError: true })
            .catch(err => { hardError = err; })
            .then(softError => {
              if (reqId === $tabs.avoidRouteWatcher) {
                $tabs.avoidRouteWatcher = false;

                // if we don't have any hard errors or any soft errors, except for
                // when navigating to the same route (on all other soft errors,
                // like when navigation was aborted in a nav guard, we don't activate this tab)
                if (
                  hardError === void 0 && (
                    softError === void 0
                    || softError.message.startsWith('Avoided redundant navigation') === true
                  )
                ) {
                  $tabs.updateModel({ name: props.name });
                }
              }

              if (opts.returnRouterError === true) {
                return hardError !== void 0 ? Promise.reject(hardError) : softError
              }
            })
        };

        emit('click', e, go);
        e.defaultPrevented !== true && go();

        return
      }

      emit('click', e);
    }

    function onKeydown (e) {
      if (isKeyCode(e, [ 13, 32 ])) {
        onClick(e, true);
      }
      else if (
        shouldIgnoreKey(e) !== true
        && e.keyCode >= 35
        && e.keyCode <= 40
        && e.altKey !== true
        && e.metaKey !== true
      ) {
        $tabs.onKbdNavigate(e.keyCode, proxy.$el) === true && stopAndPrevent(e);
      }

      emit('keydown', e);
    }

    function getContent () {
      const
        narrow = $tabs.tabProps.value.narrowIndicator,
        content = [],
        indicator = vue.h('div', {
          ref: tabIndicatorRef,
          class: [
            'q-tab__indicator',
            $tabs.tabProps.value.indicatorClass
          ]
        });

      props.icon !== void 0 && content.push(
        vue.h(QIcon, {
          class: 'q-tab__icon',
          name: props.icon
        })
      );

      props.label !== void 0 && content.push(
        vue.h('div', { class: 'q-tab__label' }, props.label)
      );

      props.alert !== false && content.push(
        props.alertIcon !== void 0
          ? vue.h(QIcon, {
            class: 'q-tab__alert-icon',
            color: props.alert !== true
              ? props.alert
              : void 0,
            name: props.alertIcon
          })
          : vue.h('div', {
            class: 'q-tab__alert'
              + (props.alert !== true ? ` text-${ props.alert }` : '')
          })
      );

      narrow === true && content.push(indicator);

      const node = [
        vue.h('div', { class: 'q-focus-helper', tabindex: -1, ref: blurTargetRef }),
        vue.h('div', { class: innerClass.value }, hMergeSlot(slots.default, content))
      ];

      narrow === false && node.push(indicator);

      return node
    }

    const tabData = {
      name: vue.computed(() => props.name),
      rootRef,
      tabIndicatorRef,
      routeData
    };

    vue.onBeforeUnmount(() => {
      $tabs.unregisterTab(tabData);
    });

    vue.onMounted(() => {
      $tabs.registerTab(tabData);
    });

    function renderTab (tag, customData) {
      const data = {
        ref: rootRef,
        class: classes.value,
        tabindex: tabIndex.value,
        role: 'tab',
        'aria-selected': isActive.value === true ? 'true' : 'false',
        'aria-disabled': props.disable === true ? 'true' : void 0,
        onClick,
        onKeydown,
        ...customData
      };

      return vue.withDirectives(
        vue.h(tag, data, getContent()),
        [ [ Ripple, ripple.value ] ]
      )
    }

    return { renderTab, $tabs }
  }

  var QTab = createComponent({
    name: 'QTab',

    props: useTabProps,

    emits: useTabEmits,

    setup (props, { slots, emit }) {
      const { renderTab } = useTab(props, slots, emit);
      return () => renderTab('div')
    }
  });

  var QTabPanels = createComponent({
    name: 'QTabPanels',

    props: {
      ...usePanelProps,
      ...useDarkProps
    },

    emits: usePanelEmits,

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const { updatePanelsList, getPanelContent, panelDirectives } = usePanel();

      const classes = vue.computed(() =>
        'q-tab-panels q-panel-parent'
        + (isDark.value === true ? ' q-tab-panels--dark q-dark' : '')
      );

      return () => {
        updatePanelsList(slots);

        return hDir(
          'div',
          { class: classes.value },
          getPanelContent(),
          'pan',
          props.swipeable,
          () => panelDirectives.value
        )
      }
    }
  });

  var QTabPanel = createComponent({
    name: 'QTabPanel',

    props: usePanelChildProps,

    setup (_, { slots }) {
      return () => vue.h('div', { class: 'q-tab-panel', role: 'tabpanel' }, hSlot(slots.default))
    }
  });

  // file referenced from docs

  const
    hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/,
    hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/,
    hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/,
    rgb = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/,
    rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/;

  // Keep in sync with ui/types/api/validation.d.ts
  const testPattern = {
    date: v => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v),
    time: v => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(v),
    fulltime: v => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(v),
    timeOrFulltime: v => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(v),

    // -- RFC 5322 --
    // -- Added in v2.6.6 --
    // This is a basic helper validation.
    // For something more complex (like RFC 822) you should write and use your own rule.
    // We won't be accepting PRs to enhance the one below because of the reason above.
    // eslint-disable-next-line
    email: v => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v),

    hexColor: v => hex.test(v),
    hexaColor: v => hexa.test(v),
    hexOrHexaColor: v => hexOrHexa.test(v),

    rgbColor: v => rgb.test(v),
    rgbaColor: v => rgba.test(v),
    rgbOrRgbaColor: v => rgb.test(v) || rgba.test(v),

    hexOrRgbColor: v => hex.test(v) || rgb.test(v),
    hexaOrRgbaColor: v => hexa.test(v) || rgba.test(v),
    anyColor: v => hexOrHexa.test(v) || rgb.test(v) || rgba.test(v)
  };

  var patterns = {
    testPattern
  };

  const reRGBA = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;

  function rgbToHex ({ r, g, b, a }) {
    const alpha = a !== void 0;

    r = Math.round(r);
    g = Math.round(g);
    b = Math.round(b);

    if (
      r > 255
      || g > 255
      || b > 255
      || (alpha && a > 100)
    ) {
      throw new TypeError('Expected 3 numbers below 256 (and optionally one below 100)')
    }

    a = alpha
      ? (Math.round(255 * a / 100) | 1 << 8).toString(16).slice(1)
      : '';

    return '#' + ((b | g << 8 | r << 16) | 1 << 24).toString(16).slice(1) + a
  }

  function rgbToString ({ r, g, b, a }) {
    return `rgb${ a !== void 0 ? 'a' : '' }(${ r },${ g },${ b }${ a !== void 0 ? ',' + (a / 100) : '' })`
  }

  function hexToRgb (hex) {
    if (typeof hex !== 'string') {
      throw new TypeError('Expected a string')
    }

    hex = hex.replace(/^#/, '');

    if (hex.length === 3) {
      hex = hex[ 0 ] + hex[ 0 ] + hex[ 1 ] + hex[ 1 ] + hex[ 2 ] + hex[ 2 ];
    }
    else if (hex.length === 4) {
      hex = hex[ 0 ] + hex[ 0 ] + hex[ 1 ] + hex[ 1 ] + hex[ 2 ] + hex[ 2 ] + hex[ 3 ] + hex[ 3 ];
    }

    const num = parseInt(hex, 16);

    return hex.length > 6
      ? { r: num >> 24 & 255, g: num >> 16 & 255, b: num >> 8 & 255, a: Math.round((num & 255) / 2.55) }
      : { r: num >> 16, g: num >> 8 & 255, b: num & 255 }
  }

  function hsvToRgb ({ h, s, v, a }) {
    let r, g, b;
    s = s / 100;
    v = v / 100;

    h = h / 360;
    const
      i = Math.floor(h * 6),
      f = h * 6 - i,
      p = v * (1 - s),
      q = v * (1 - f * s),
      t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v;
        g = t;
        b = p;
        break
      case 1:
        r = q;
        g = v;
        b = p;
        break
      case 2:
        r = p;
        g = v;
        b = t;
        break
      case 3:
        r = p;
        g = q;
        b = v;
        break
      case 4:
        r = t;
        g = p;
        b = v;
        break
      case 5:
        r = v;
        g = p;
        b = q;
        break
    }

    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255),
      a
    }
  }

  function rgbToHsv ({ r, g, b, a }) {
    const
      max = Math.max(r, g, b),
      min = Math.min(r, g, b),
      d = max - min,
      s = (max === 0 ? 0 : d / max),
      v = max / 255;
    let h;

    switch (max) {
      case min:
        h = 0;
        break
      case r:
        h = (g - b) + d * (g < b ? 6 : 0);
        h /= 6 * d;
        break
      case g:
        h = (b - r) + d * 2;
        h /= 6 * d;
        break
      case b:
        h = (r - g) + d * 4;
        h /= 6 * d;
        break
    }

    return {
      h: Math.round(h * 360),
      s: Math.round(s * 100),
      v: Math.round(v * 100),
      a
    }
  }

  function textToRgb (str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string')
    }

    const color = str.replace(/ /g, '');

    const m = reRGBA.exec(color);

    if (m === null) {
      return hexToRgb(color)
    }

    const rgb = {
      r: Math.min(255, parseInt(m[ 2 ], 10)),
      g: Math.min(255, parseInt(m[ 3 ], 10)),
      b: Math.min(255, parseInt(m[ 4 ], 10))
    };

    if (m[ 1 ]) {
      const alpha = parseFloat(m[ 5 ]);
      rgb.a = Math.min(1, isNaN(alpha) === true ? 1 : alpha) * 100;
    }

    return rgb
  }

  /* works as darken if percent < 0 */
  function lighten (color, percent) {
    if (typeof color !== 'string') {
      throw new TypeError('Expected a string as color')
    }
    if (typeof percent !== 'number') {
      throw new TypeError('Expected a numeric percent')
    }

    const rgb = textToRgb(color),
      t = percent < 0 ? 0 : 255,
      p = Math.abs(percent) / 100,
      R = rgb.r,
      G = rgb.g,
      B = rgb.b;

    return '#' + (
      0x1000000 + (Math.round((t - R) * p) + R) * 0x10000
      + (Math.round((t - G) * p) + G) * 0x100
      + (Math.round((t - B) * p) + B)
    ).toString(16).slice(1)
  }

  function luminosity (color) {
    if (typeof color !== 'string' && (!color || color.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b} object as color')
    }

    const
      rgb = typeof color === 'string' ? textToRgb(color) : color,
      r = rgb.r / 255,
      g = rgb.g / 255,
      b = rgb.b / 255,
      R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4),
      G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4),
      B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B
  }

  function brightness (color) {
    if (typeof color !== 'string' && (!color || color.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b} object as color')
    }

    const rgb = typeof color === 'string'
      ? textToRgb(color)
      : color;

    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000
  }

  function blend (fgColor, bgColor) {
    if (typeof fgColor !== 'string' && (!fgColor || fgColor.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b[, a]} object as fgColor')
    }

    if (typeof bgColor !== 'string' && (!bgColor || bgColor.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b[, a]} object as bgColor')
    }

    const
      rgb1 = typeof fgColor === 'string' ? textToRgb(fgColor) : fgColor,
      r1 = rgb1.r / 255,
      g1 = rgb1.g / 255,
      b1 = rgb1.b / 255,
      a1 = rgb1.a !== void 0 ? rgb1.a / 100 : 1,
      rgb2 = typeof bgColor === 'string' ? textToRgb(bgColor) : bgColor,
      r2 = rgb2.r / 255,
      g2 = rgb2.g / 255,
      b2 = rgb2.b / 255,
      a2 = rgb2.a !== void 0 ? rgb2.a / 100 : 1,
      a = a1 + a2 * (1 - a1),
      r = Math.round(((r1 * a1 + r2 * a2 * (1 - a1)) / a) * 255),
      g = Math.round(((g1 * a1 + g2 * a2 * (1 - a1)) / a) * 255),
      b = Math.round(((b1 * a1 + b2 * a2 * (1 - a1)) / a) * 255);

    const ret = { r, g, b, a: Math.round(a * 100) };
    return typeof fgColor === 'string'
      ? rgbToHex(ret)
      : ret
  }

  function changeAlpha (color, offset) {
    if (typeof color !== 'string') {
      throw new TypeError('Expected a string as color')
    }

    if (offset === void 0 || offset < -1 || offset > 1) {
      throw new TypeError('Expected offset to be between -1 and 1')
    }

    const { r, g, b, a } = textToRgb(color);
    const alpha = a !== void 0 ? a / 100 : 0;

    return rgbToHex({
      r, g, b, a: Math.round(Math.min(1, Math.max(0, alpha + offset)) * 100)
    })
  }

  function getPaletteColor (colorName) {
    if (typeof colorName !== 'string') {
      throw new TypeError('Expected a string as color')
    }

    const el = document.createElement('div');

    el.className = `text-${ colorName } invisible fixed no-pointer-events`;
    document.body.appendChild(el);

    const result = getComputedStyle(el).getPropertyValue('color');

    el.remove();

    return rgbToHex(textToRgb(result))
  }

  var colors = {
    rgbToHex,
    hexToRgb,
    hsvToRgb,
    rgbToHsv,
    textToRgb,
    lighten,
    luminosity,
    brightness,
    blend,
    changeAlpha,
    getPaletteColor
  };

  const palette = [
    'rgb(255,204,204)', 'rgb(255,230,204)', 'rgb(255,255,204)', 'rgb(204,255,204)', 'rgb(204,255,230)', 'rgb(204,255,255)', 'rgb(204,230,255)', 'rgb(204,204,255)', 'rgb(230,204,255)', 'rgb(255,204,255)',
    'rgb(255,153,153)', 'rgb(255,204,153)', 'rgb(255,255,153)', 'rgb(153,255,153)', 'rgb(153,255,204)', 'rgb(153,255,255)', 'rgb(153,204,255)', 'rgb(153,153,255)', 'rgb(204,153,255)', 'rgb(255,153,255)',
    'rgb(255,102,102)', 'rgb(255,179,102)', 'rgb(255,255,102)', 'rgb(102,255,102)', 'rgb(102,255,179)', 'rgb(102,255,255)', 'rgb(102,179,255)', 'rgb(102,102,255)', 'rgb(179,102,255)', 'rgb(255,102,255)',
    'rgb(255,51,51)', 'rgb(255,153,51)', 'rgb(255,255,51)', 'rgb(51,255,51)', 'rgb(51,255,153)', 'rgb(51,255,255)', 'rgb(51,153,255)', 'rgb(51,51,255)', 'rgb(153,51,255)', 'rgb(255,51,255)',
    'rgb(255,0,0)', 'rgb(255,128,0)', 'rgb(255,255,0)', 'rgb(0,255,0)', 'rgb(0,255,128)', 'rgb(0,255,255)', 'rgb(0,128,255)', 'rgb(0,0,255)', 'rgb(128,0,255)', 'rgb(255,0,255)',
    'rgb(245,0,0)', 'rgb(245,123,0)', 'rgb(245,245,0)', 'rgb(0,245,0)', 'rgb(0,245,123)', 'rgb(0,245,245)', 'rgb(0,123,245)', 'rgb(0,0,245)', 'rgb(123,0,245)', 'rgb(245,0,245)',
    'rgb(214,0,0)', 'rgb(214,108,0)', 'rgb(214,214,0)', 'rgb(0,214,0)', 'rgb(0,214,108)', 'rgb(0,214,214)', 'rgb(0,108,214)', 'rgb(0,0,214)', 'rgb(108,0,214)', 'rgb(214,0,214)',
    'rgb(163,0,0)', 'rgb(163,82,0)', 'rgb(163,163,0)', 'rgb(0,163,0)', 'rgb(0,163,82)', 'rgb(0,163,163)', 'rgb(0,82,163)', 'rgb(0,0,163)', 'rgb(82,0,163)', 'rgb(163,0,163)',
    'rgb(92,0,0)', 'rgb(92,46,0)', 'rgb(92,92,0)', 'rgb(0,92,0)', 'rgb(0,92,46)', 'rgb(0,92,92)', 'rgb(0,46,92)', 'rgb(0,0,92)', 'rgb(46,0,92)', 'rgb(92,0,92)',
    'rgb(255,255,255)', 'rgb(205,205,205)', 'rgb(178,178,178)', 'rgb(153,153,153)', 'rgb(127,127,127)', 'rgb(102,102,102)', 'rgb(76,76,76)', 'rgb(51,51,51)', 'rgb(25,25,25)', 'rgb(0,0,0)'
  ];

  const thumbPath = 'M5 5 h10 v10 h-10 v-10 z';
  const alphaTrackImg = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAH0lEQVQoU2NkYGAwZkAFZ5G5jPRRgOYEVDeB3EBjBQBOZwTVugIGyAAAAABJRU5ErkJggg==';

  var QColor = createComponent({
    name: 'QColor',

    props: {
      ...useDarkProps,
      ...useFormProps,

      modelValue: String,

      defaultValue: String,
      defaultView: {
        type: String,
        default: 'spectrum',
        validator: v => [ 'spectrum', 'tune', 'palette' ].includes(v)
      },

      formatModel: {
        type: String,
        default: 'auto',
        validator: v => [ 'auto', 'hex', 'rgb', 'hexa', 'rgba' ].includes(v)
      },

      palette: Array,

      noHeader: Boolean,
      noHeaderTabs: Boolean,
      noFooter: Boolean,

      square: Boolean,
      flat: Boolean,
      bordered: Boolean,

      disable: Boolean,
      readonly: Boolean
    },

    emits: [ 'update:modelValue', 'change' ],

    setup (props, { emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const isDark = useDark(props, $q);
      const { getCache } = useCache();

      const spectrumRef = vue.ref(null);
      const errorIconRef = vue.ref(null);

      const forceHex = vue.computed(() => (
        props.formatModel === 'auto'
          ? null
          : props.formatModel.indexOf('hex') > -1
      ));

      const forceAlpha = vue.computed(() => (
        props.formatModel === 'auto'
          ? null
          : props.formatModel.indexOf('a') > -1
      ));

      const topView = vue.ref(
        props.formatModel === 'auto'
          ? (
              (props.modelValue === void 0 || props.modelValue === null || props.modelValue === '' || props.modelValue.startsWith('#'))
                ? 'hex'
                : 'rgb'
            )
          : (props.formatModel.startsWith('hex') ? 'hex' : 'rgb')
      );

      const view = vue.ref(props.defaultView);
      const model = vue.ref(parseModel(props.modelValue || props.defaultValue));

      const editable = vue.computed(() => props.disable !== true && props.readonly !== true);

      const isHex = vue.computed(() =>
        props.modelValue === void 0
        || props.modelValue === null
        || props.modelValue === ''
        || props.modelValue.startsWith('#')
      );

      const isOutputHex = vue.computed(() => (
        forceHex.value !== null
          ? forceHex.value
          : isHex.value
      ));

      const formAttrs = vue.computed(() => ({
        type: 'hidden',
        name: props.name,
        value: model.value[ isOutputHex.value === true ? 'hex' : 'rgb' ]
      }));

      const injectFormInput = useFormInject(formAttrs);

      const hasAlpha = vue.computed(() => (
        forceAlpha.value !== null
          ? forceAlpha.value
          : model.value.a !== void 0
      ));

      const currentBgColor = vue.computed(() => ({
        backgroundColor: model.value.rgb || '#000'
      }));

      const headerClass = vue.computed(() => {
        const light = model.value.a !== void 0 && model.value.a < 65
          ? true
          : luminosity(model.value) > 0.4;

        return 'q-color-picker__header-content'
          + ` q-color-picker__header-content--${ light ? 'light' : 'dark' }`
      });

      const spectrumStyle = vue.computed(() => ({
        background: `hsl(${ model.value.h },100%,50%)`
      }));

      const spectrumPointerStyle = vue.computed(() => ({
        top: `${ 100 - model.value.v }%`,
        [ $q.lang.rtl === true ? 'right' : 'left' ]: `${ model.value.s }%`
      }));

      const computedPalette = vue.computed(() => (
        props.palette !== void 0 && props.palette.length > 0
          ? props.palette
          : palette
      ));

      const classes = vue.computed(() =>
        'q-color-picker'
        + (props.bordered === true ? ' q-color-picker--bordered' : '')
        + (props.square === true ? ' q-color-picker--square no-border-radius' : '')
        + (props.flat === true ? ' q-color-picker--flat no-shadow' : '')
        + (props.disable === true ? ' disabled' : '')
        + (isDark.value === true ? ' q-color-picker--dark q-dark' : '')
      );

      const attributes = vue.computed(() => {
        if (props.disable === true) {
          return { 'aria-disabled': 'true' }
        }
        if (props.readonly === true) {
          return { 'aria-readonly': 'true' }
        }
        return {}
      });

      const spectrumDirective = vue.computed(() => {
        // if editable.value === true
        return [ [
          TouchPan,
          onSpectrumPan,
          void 0,
          { prevent: true, stop: true, mouse: true }
        ] ]
      });

      vue.watch(() => props.modelValue, v => {
        const localModel = parseModel(v || props.defaultValue);
        if (localModel.hex !== model.value.hex) {
          model.value = localModel;
        }
      });

      vue.watch(() => props.defaultValue, v => {
        if (!props.modelValue && v) {
          const localModel = parseModel(v);
          if (localModel.hex !== model.value.hex) {
            model.value = localModel;
          }
        }
      });

      function updateModel (rgb, change) {
        // update internally
        model.value.hex = rgbToHex(rgb);
        model.value.rgb = rgbToString(rgb);
        model.value.r = rgb.r;
        model.value.g = rgb.g;
        model.value.b = rgb.b;
        model.value.a = rgb.a;

        const value = model.value[ isOutputHex.value === true ? 'hex' : 'rgb' ];

        // emit new value
        emit('update:modelValue', value);
        change === true && emit('change', value);
      }

      function parseModel (v) {
        const alpha = forceAlpha.value !== void 0
          ? forceAlpha.value
          : (
              props.formatModel === 'auto'
                ? null
                : props.formatModel.indexOf('a') > -1
            );

        if (typeof v !== 'string' || v.length === 0 || testPattern.anyColor(v.replace(/ /g, '')) !== true) {
          return {
            h: 0,
            s: 0,
            v: 0,
            r: 0,
            g: 0,
            b: 0,
            a: alpha === true ? 100 : void 0,
            hex: void 0,
            rgb: void 0
          }
        }

        const model = textToRgb(v);

        if (alpha === true && model.a === void 0) {
          model.a = 100;
        }

        model.hex = rgbToHex(model);
        model.rgb = rgbToString(model);

        return Object.assign(model, rgbToHsv(model))
      }

      function changeSpectrum (left, top, change) {
        const panel = spectrumRef.value;
        if (panel === null) { return }

        const
          width = panel.clientWidth,
          height = panel.clientHeight,
          rect = panel.getBoundingClientRect();

        let x = Math.min(width, Math.max(0, left - rect.left));

        if ($q.lang.rtl === true) {
          x = width - x;
        }

        const
          y = Math.min(height, Math.max(0, top - rect.top)),
          s = Math.round(100 * x / width),
          v = Math.round(100 * Math.max(0, Math.min(1, -(y / height) + 1))),
          rgb = hsvToRgb({
            h: model.value.h,
            s,
            v,
            a: hasAlpha.value === true ? model.value.a : void 0
          });

        model.value.s = s;
        model.value.v = v;
        updateModel(rgb, change);
      }

      function onHueChange (val, change) {
        const h = Math.round(val);
        const rgb = hsvToRgb({
          h,
          s: model.value.s,
          v: model.value.v,
          a: hasAlpha.value === true ? model.value.a : void 0
        });

        model.value.h = h;
        updateModel(rgb, change);
      }

      function onNumericChange (value, formatModel, max, evt, change) {
        evt !== void 0 && stop(evt);

        if (!/^[0-9]+$/.test(value)) {
          change === true && proxy.$forceUpdate();
          return
        }

        const val = Math.floor(Number(value));

        if (val < 0 || val > max) {
          change === true && proxy.$forceUpdate();
          return
        }

        const rgb = {
          r: formatModel === 'r' ? val : model.value.r,
          g: formatModel === 'g' ? val : model.value.g,
          b: formatModel === 'b' ? val : model.value.b,
          a: hasAlpha.value === true
            ? (formatModel === 'a' ? val : model.value.a)
            : void 0
        };

        if (formatModel !== 'a') {
          const hsv = rgbToHsv(rgb);
          model.value.h = hsv.h;
          model.value.s = hsv.s;
          model.value.v = hsv.v;
        }

        updateModel(rgb, change);

        if (evt !== void 0 && change !== true && evt.target.selectionEnd !== void 0) {
          const index = evt.target.selectionEnd;
          vue.nextTick(() => {
            evt.target.setSelectionRange(index, index);
          });
        }
      }

      function onEditorChange (evt, change) {
        let rgb;
        const inp = evt.target.value;

        stop(evt);

        if (topView.value === 'hex') {
          if (
            inp.length !== (hasAlpha.value === true ? 9 : 7)
            || !/^#[0-9A-Fa-f]+$/.test(inp)
          ) {
            return true
          }

          rgb = hexToRgb(inp);
        }
        else {
          let model;

          if (!inp.endsWith(')')) {
            return true
          }
          else if (hasAlpha.value !== true && inp.startsWith('rgb(')) {
            model = inp.substring(4, inp.length - 1).split(',').map(n => parseInt(n, 10));

            if (
              model.length !== 3
              || !/^rgb\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3}\)$/.test(inp)
            ) {
              return true
            }
          }
          else if (hasAlpha.value === true && inp.startsWith('rgba(')) {
            model = inp.substring(5, inp.length - 1).split(',');

            if (
              model.length !== 4
              || !/^rgba\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/.test(inp)
            ) {
              return true
            }

            for (let i = 0; i < 3; i++) {
              const v = parseInt(model[ i ], 10);
              if (v < 0 || v > 255) {
                return true
              }
              model[ i ] = v;
            }

            const v = parseFloat(model[ 3 ]);
            if (v < 0 || v > 1) {
              return true
            }
            model[ 3 ] = v;
          }
          else {
            return true
          }

          if (
            model[ 0 ] < 0 || model[ 0 ] > 255
            || model[ 1 ] < 0 || model[ 1 ] > 255
            || model[ 2 ] < 0 || model[ 2 ] > 255
            || (hasAlpha.value === true && (model[ 3 ] < 0 || model[ 3 ] > 1))
          ) {
            return true
          }

          rgb = {
            r: model[ 0 ],
            g: model[ 1 ],
            b: model[ 2 ],
            a: hasAlpha.value === true
              ? model[ 3 ] * 100
              : void 0
          };
        }

        const hsv = rgbToHsv(rgb);
        model.value.h = hsv.h;
        model.value.s = hsv.s;
        model.value.v = hsv.v;

        updateModel(rgb, change);

        if (change !== true) {
          const index = evt.target.selectionEnd;
          vue.nextTick(() => {
            evt.target.setSelectionRange(index, index);
          });
        }
      }

      function onPalettePick (color) {
        const def = parseModel(color);
        const rgb = { r: def.r, g: def.g, b: def.b, a: def.a };

        if (rgb.a === void 0) {
          rgb.a = model.value.a;
        }

        model.value.h = def.h;
        model.value.s = def.s;
        model.value.v = def.v;

        updateModel(rgb, true);
      }

      function onSpectrumPan (evt) {
        if (evt.isFinal) {
          changeSpectrum(
            evt.position.left,
            evt.position.top,
            true
          );
        }
        else {
          onSpectrumChange(evt);
        }
      }

      const onSpectrumChange = throttle(
        evt => { changeSpectrum(evt.position.left, evt.position.top); },
        20
      );

      function onSpectrumClick (evt) {
        changeSpectrum(
          evt.pageX - window.pageXOffset,
          evt.pageY - window.pageYOffset,
          true
        );
      }

      function onActivate (evt) {
        changeSpectrum(
          evt.pageX - window.pageXOffset,
          evt.pageY - window.pageYOffset
        );
      }

      function updateErrorIcon (val) {
        // we MUST avoid vue triggering a render,
        // so manually changing this
        if (errorIconRef.value !== null) {
          errorIconRef.value.$el.style.opacity = val ? 1 : 0;
        }
      }

      function getHeader () {
        const child = [];

        props.noHeaderTabs !== true && child.push(
          vue.h(QTabs, {
            class: 'q-color-picker__header-tabs',
            modelValue: topView.value,
            dense: true,
            align: 'justify',
            ...getCache('topVTab', {
              'onUpdate:modelValue': val => { topView.value = val; }
            })
          }, () => [
            vue.h(QTab, {
              label: 'HEX' + (hasAlpha.value === true ? 'A' : ''),
              name: 'hex',
              ripple: false
            }),

            vue.h(QTab, {
              label: 'RGB' + (hasAlpha.value === true ? 'A' : ''),
              name: 'rgb',
              ripple: false
            })
          ])
        );

        child.push(
          vue.h('div', {
            class: 'q-color-picker__header-banner row flex-center no-wrap'
          }, [
            vue.h('input', {
              class: 'fit',
              value: model.value[ topView.value ],
              ...(editable.value !== true
                ? { readonly: true }
                : {}
              ),
              ...getCache('topIn', {
                onInput: evt => {
                  updateErrorIcon(onEditorChange(evt) === true);
                },
                onChange: stop,
                onBlur: evt => {
                  onEditorChange(evt, true) === true && proxy.$forceUpdate();
                  updateErrorIcon(false);
                }
              })
            }),

            vue.h(QIcon, {
              ref: errorIconRef,
              class: 'q-color-picker__error-icon absolute no-pointer-events',
              name: $q.iconSet.type.negative
            })
          ])
        );

        return vue.h('div', {
          class: 'q-color-picker__header relative-position overflow-hidden'
        }, [
          vue.h('div', { class: 'q-color-picker__header-bg absolute-full' }),

          vue.h('div', {
            class: headerClass.value,
            style: currentBgColor.value
          }, child)
        ])
      }

      function getContent () {
        return vue.h(QTabPanels, {
          modelValue: view.value,
          animated: true
        }, () => [
          vue.h(QTabPanel, {
            class: 'q-color-picker__spectrum-tab overflow-hidden',
            name: 'spectrum'
          }, getSpectrumTab),

          vue.h(QTabPanel, {
            class: 'q-pa-md q-color-picker__tune-tab',
            name: 'tune'
          }, getTuneTab),

          vue.h(QTabPanel, {
            class: 'q-color-picker__palette-tab',
            name: 'palette'
          }, getPaletteTab)
        ])
      }

      function getFooter () {
        return vue.h('div', {
          class: 'q-color-picker__footer relative-position overflow-hidden'
        }, [
          vue.h(QTabs, {
            class: 'absolute-full',
            modelValue: view.value,
            dense: true,
            align: 'justify',
            ...getCache('ftIn', {
              'onUpdate:modelValue': val => { view.value = val; }
            })
          }, () => [
            vue.h(QTab, {
              icon: $q.iconSet.colorPicker.spectrum,
              name: 'spectrum',
              ripple: false
            }),

            vue.h(QTab, {
              icon: $q.iconSet.colorPicker.tune,
              name: 'tune',
              ripple: false
            }),

            vue.h(QTab, {
              icon: $q.iconSet.colorPicker.palette,
              name: 'palette',
              ripple: false
            })
          ])
        ])
      }

      function getSpectrumTab () {
        const data = {
          ref: spectrumRef,
          class: 'q-color-picker__spectrum non-selectable relative-position cursor-pointer'
            + (editable.value !== true ? ' readonly' : ''),
          style: spectrumStyle.value,
          ...(editable.value === true
            ? {
                onClick: onSpectrumClick,
                onMousedown: onActivate
              }
            : {}
          )
        };

        const child = [
          vue.h('div', { style: { paddingBottom: '100%' } }),
          vue.h('div', { class: 'q-color-picker__spectrum-white absolute-full' }),
          vue.h('div', { class: 'q-color-picker__spectrum-black absolute-full' }),
          vue.h('div', {
            class: 'absolute',
            style: spectrumPointerStyle.value
          }, [
            model.value.hex !== void 0
              ? vue.h('div', { class: 'q-color-picker__spectrum-circle' })
              : null
          ])
        ];

        const sliders = [
          vue.h(QSlider, {
            class: 'q-color-picker__hue non-selectable',
            modelValue: model.value.h,
            min: 0,
            max: 360,
            trackSize: '8px',
            innerTrackColor: 'transparent',
            selectionColor: 'transparent',
            readonly: editable.value !== true,
            thumbPath,
            'onUpdate:modelValue': onHueChange,
            ...getCache('lazyhue', {
              onChange: val => onHueChange(val, true)
            })
          })
        ];

        hasAlpha.value === true && sliders.push(
          vue.h(QSlider, {
            class: 'q-color-picker__alpha non-selectable',
            modelValue: model.value.a,
            min: 0,
            max: 100,
            trackSize: '8px',
            trackColor: 'white',
            innerTrackColor: 'transparent',
            selectionColor: 'transparent',
            trackImg: alphaTrackImg,
            readonly: editable.value !== true,
            hideSelection: true,
            thumbPath,
            ...getCache('alphaSlide', {
              'onUpdate:modelValue': value => onNumericChange(value, 'a', 100),
              onChange: value => onNumericChange(value, 'a', 100, void 0, true)
            })
          })
        );

        return [
          hDir('div', data, child, 'spec', editable.value, () => spectrumDirective.value),
          vue.h('div', { class: 'q-color-picker__sliders' }, sliders)
        ]
      }

      function getTuneTab () {
        return [
          vue.h('div', { class: 'row items-center no-wrap' }, [
            vue.h('div', 'R'),
            vue.h(QSlider, {
              modelValue: model.value.r,
              min: 0,
              max: 255,
              color: 'red',
              dark: isDark.value,
              readonly: editable.value !== true,
              ...getCache('rSlide', {
                'onUpdate:modelValue': value => onNumericChange(value, 'r', 255),
                onChange: value => onNumericChange(value, 'r', 255, void 0, true)
              })
            }),
            vue.h('input', {
              value: model.value.r,
              maxlength: 3,
              readonly: editable.value !== true,
              onChange: stop,
              ...getCache('rIn', {
                onInput: evt => onNumericChange(evt.target.value, 'r', 255, evt),
                onBlur: evt => onNumericChange(evt.target.value, 'r', 255, evt, true)
              })
            })
          ]),

          vue.h('div', { class: 'row items-center no-wrap' }, [
            vue.h('div', 'G'),
            vue.h(QSlider, {
              modelValue: model.value.g,
              min: 0,
              max: 255,
              color: 'green',
              dark: isDark.value,
              readonly: editable.value !== true,
              ...getCache('gSlide', {
                'onUpdate:modelValue': value => onNumericChange(value, 'g', 255),
                onChange: value => onNumericChange(value, 'g', 255, void 0, true)
              })
            }),
            vue.h('input', {
              value: model.value.g,
              maxlength: 3,
              readonly: editable.value !== true,
              onChange: stop,
              ...getCache('gIn', {
                onInput: evt => onNumericChange(evt.target.value, 'g', 255, evt),
                onBlur: evt => onNumericChange(evt.target.value, 'g', 255, evt, true)
              })
            })
          ]),

          vue.h('div', { class: 'row items-center no-wrap' }, [
            vue.h('div', 'B'),
            vue.h(QSlider, {
              modelValue: model.value.b,
              min: 0,
              max: 255,
              color: 'blue',
              readonly: editable.value !== true,
              dark: isDark.value,
              ...getCache('bSlide', {
                'onUpdate:modelValue': value => onNumericChange(value, 'b', 255),
                onChange: value => onNumericChange(value, 'b', 255, void 0, true)
              })
            }),
            vue.h('input', {
              value: model.value.b,
              maxlength: 3,
              readonly: editable.value !== true,
              onChange: stop,
              ...getCache('bIn', {
                onInput: evt => onNumericChange(evt.target.value, 'b', 255, evt),
                onBlur: evt => onNumericChange(evt.target.value, 'b', 255, evt, true)
              })
            })
          ]),

          hasAlpha.value === true ? vue.h('div', { class: 'row items-center no-wrap' }, [
            vue.h('div', 'A'),
            vue.h(QSlider, {
              modelValue: model.value.a,
              color: 'grey',
              readonly: editable.value !== true,
              dark: isDark.value,
              ...getCache('aSlide', {
                'onUpdate:modelValue': value => onNumericChange(value, 'a', 100),
                onChange: value => onNumericChange(value, 'a', 100, void 0, true)
              })
            }),
            vue.h('input', {
              value: model.value.a,
              maxlength: 3,
              readonly: editable.value !== true,
              onChange: stop,
              ...getCache('aIn', {
                onInput: evt => onNumericChange(evt.target.value, 'a', 100, evt),
                onBlur: evt => onNumericChange(evt.target.value, 'a', 100, evt, true)
              })
            })
          ]) : null
        ]
      }

      function getPaletteTab () {
        const fn = color => vue.h('div', {
          class: 'q-color-picker__cube col-auto',
          style: { backgroundColor: color },
          ...(
            editable.value === true
              ? getCache('palette#' + color, {
                onClick: () => { onPalettePick(color); }
              })
              : {}
          )
        });

        return [
          vue.h('div', {
            class: 'row items-center q-color-picker__palette-rows'
              + (editable.value === true ? ' q-color-picker__palette-rows--editable' : '')
          }, computedPalette.value.map(fn))
        ]
      }

      return () => {
        const child = [ getContent() ];

        if (props.name !== void 0 && props.disable !== true) {
          injectFormInput(child, 'push');
        }

        props.noHeader !== true && child.unshift(
          getHeader()
        );

        props.noFooter !== true && child.push(
          getFooter()
        );

        return vue.h('div', {
          class: classes.value,
          ...attributes.value
        }, child)
      }
    }
  });

  // taken from https://github.com/jalaali/jalaali-js

  /*
    Jalaali years starting the 33-year rule.
  */
  const breaks = [
    -61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210,
    1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178
  ];

  /*
    Converts a Gregorian date to Jalaali.
  */
  function toJalaali (gy, gm, gd) {
    if (Object.prototype.toString.call(gy) === '[object Date]') {
      gd = gy.getDate();
      gm = gy.getMonth() + 1;
      gy = gy.getFullYear();
    }
    return d2j(g2d(gy, gm, gd))
  }

  /*
    Converts a Jalaali date to Gregorian.
  */
  function toGregorian (jy, jm, jd) {
    return d2g(j2d(jy, jm, jd))
  }

  /*
    Is this a leap year or not?
  */
  function isLeapJalaaliYear (jy) {
    return jalCalLeap(jy) === 0
  }

  /*
    Number of days in a given month in a Jalaali year.
  */
  function jalaaliMonthLength (jy, jm) {
    if (jm <= 6) return 31
    if (jm <= 11) return 30
    if (isLeapJalaaliYear(jy)) return 30
    return 29
  }

  /*
      This function determines if the Jalaali (Persian) year is
      leap (366-day long) or is the common year (365 days)

      @param jy Jalaali calendar year (-61 to 3177)
      @returns number of years since the last leap year (0 to 4)
   */
  function jalCalLeap (jy) {
    const bl = breaks.length;
    let
      jp = breaks[ 0 ],
      jm,
      jump,
      leap,
      n,
      i;

    if (jy < jp || jy >= breaks[ bl - 1 ]) { throw new Error('Invalid Jalaali year ' + jy) }

    for (i = 1; i < bl; i += 1) {
      jm = breaks[ i ];
      jump = jm - jp;
      if (jy < jm) { break }
      jp = jm;
    }
    n = jy - jp;

    if (jump - n < 6) { n = n - jump + div(jump + 4, 33) * 33; }
    leap = mod(mod(n + 1, 33) - 1, 4);
    if (leap === -1) {
      leap = 4;
    }

    return leap
  }

  /*
    This function determines if the Jalaali (Persian) year is
    leap (366-day long) or is the common year (365 days), and
    finds the day in March (Gregorian calendar) of the first
    day of the Jalaali year (jy).

    @param jy Jalaali calendar year (-61 to 3177)
    @param withoutLeap when don't need leap (true or false) default is false
    @return
      leap: number of years since the last leap year (0 to 4)
      gy: Gregorian year of the beginning of Jalaali year
      march: the March day of Farvardin the 1st (1st day of jy)
    @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
    @see: http://www.fourmilab.ch/documents/calendar/
  */
  function jalCal (jy, withoutLeap) {
    const
      bl = breaks.length,
      gy = jy + 621;
    let
      leapJ = -14,
      jp = breaks[ 0 ],
      jm,
      jump,
      leap,
      n,
      i;

    if (jy < jp || jy >= breaks[ bl - 1 ]) { throw new Error('Invalid Jalaali year ' + jy) }

    // Find the limiting years for the Jalaali year jy.
    for (i = 1; i < bl; i += 1) {
      jm = breaks[ i ];
      jump = jm - jp;
      if (jy < jm) { break }
      leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
      jp = jm;
    }
    n = jy - jp;

    // Find the number of leap years from AD 621 to the beginning
    // of the current Jalaali year in the Persian calendar.
    leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
    if (mod(jump, 33) === 4 && jump - n === 4) { leapJ += 1; }

    // And the same in the Gregorian calendar (until the year gy).
    const leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;

    // Determine the Gregorian date of Farvardin the 1st.
    const march = 20 + leapJ - leapG;

    // Find how many years have passed since the last leap year.
    if (!withoutLeap) {
      if (jump - n < 6) { n = n - jump + div(jump + 4, 33) * 33; }
      leap = mod(mod(n + 1, 33) - 1, 4);
      if (leap === -1) {
        leap = 4;
      }
    }

    return {
      leap,
      gy,
      march
    }
  }

  /*
    Converts a date of the Jalaali calendar to the Julian Day number.

    @param jy Jalaali year (1 to 3100)
    @param jm Jalaali month (1 to 12)
    @param jd Jalaali day (1 to 29/31)
    @return Julian Day number
  */
  function j2d (jy, jm, jd) {
    const r = jalCal(jy, true);
    return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1
  }

  /*
    Converts the Julian Day number to a date in the Jalaali calendar.

    @param jdn Julian Day number
    @return
      jy: Jalaali year (1 to 3100)
      jm: Jalaali month (1 to 12)
      jd: Jalaali day (1 to 29/31)
  */
  function d2j (jdn) {
    const gy = d2g(jdn).gy; // Calculate Gregorian year (gy).
    let
      jy = gy - 621,
      jd,
      jm,
      k;
    const
      r = jalCal(jy, false),
      jdn1f = g2d(gy, 3, r.march);

    // Find number of days that passed since 1 Farvardin.
    k = jdn - jdn1f;
    if (k >= 0) {
      if (k <= 185) {
        // The first 6 months.
        jm = 1 + div(k, 31);
        jd = mod(k, 31) + 1;
        return {
          jy,
          jm,
          jd
        }
      }
      else {
        // The remaining months.
        k -= 186;
      }
    }
    else {
      // Previous Jalaali year.
      jy -= 1;
      k += 179;
      if (r.leap === 1) { k += 1; }
    }
    jm = 7 + div(k, 30);
    jd = mod(k, 30) + 1;
    return {
      jy,
      jm,
      jd
    }
  }

  /*
    Calculates the Julian Day number from Gregorian or Julian
    calendar dates. This integer number corresponds to the noon of
    the date (i.e. 12 hours of Universal Time).
    The procedure was tested to be good since 1 March, -100100 (of both
    calendars) up to a few million years into the future.

    @param gy Calendar year (years BC numbered 0, -1, -2, ...)
    @param gm Calendar month (1 to 12)
    @param gd Calendar day of the month (1 to 28/29/30/31)
    @return Julian Day number
  */
  function g2d (gy, gm, gd) {
    let d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4)
        + div(153 * mod(gm + 9, 12) + 2, 5)
        + gd - 34840408;
    d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
    return d
  }

  /*
    Calculates Gregorian and Julian calendar dates from the Julian Day number
    (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
    calendars) to some millions years ahead of the present.

    @param jdn Julian Day number
    @return
      gy: Calendar year (years BC numbered 0, -1, -2, ...)
      gm: Calendar month (1 to 12)
      gd: Calendar day of the month M (1 to 28/29/30/31)
  */
  function d2g (jdn) {
    let j = 4 * jdn + 139361631;
    j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
    const
      i = div(mod(j, 1461), 4) * 5 + 308,
      gd = div(mod(i, 153), 5) + 1,
      gm = mod(div(i, 153), 12) + 1,
      gy = div(j, 1461) - 100100 + div(8 - gm, 6);
    return {
      gy,
      gm,
      gd
    }
  }

  /*
    Utility helper functions.
  */

  function div (a, b) {
    return ~~(a / b)
  }

  function mod (a, b) {
    return a - ~~(a / b) * b
  }

  const calendars = [ 'gregorian', 'persian' ];

  const useDatetimeProps = {
    modelValue: {
      required: true
    },

    mask: {
      type: String
    },
    locale: Object,

    calendar: {
      type: String,
      validator: v => calendars.includes(v),
      default: 'gregorian'
    },

    landscape: Boolean,

    color: String,
    textColor: String,

    square: Boolean,
    flat: Boolean,
    bordered: Boolean,

    readonly: Boolean,
    disable: Boolean
  };

  const useDatetimeEmits = [ 'update:modelValue' ];

  function getDayHash (date) {
    return date.year + '/' + pad(date.month) + '/' + pad(date.day)
  }

  function useDatetime (props, $q) {
    const editable = vue.computed(() => {
      return props.disable !== true && props.readonly !== true
    });

    const tabindex = vue.computed(() => {
      return editable.value === true ? 0 : -1
    });

    const headerClass = vue.computed(() => {
      const cls = [];
      props.color !== void 0 && cls.push(`bg-${ props.color }`);
      props.textColor !== void 0 && cls.push(`text-${ props.textColor }`);
      return cls.join(' ')
    });

    function getLocale () {
      return props.locale !== void 0
        ? { ...$q.lang.date, ...props.locale }
        : $q.lang.date
    }

    function getCurrentDate (dateOnly) {
      const d = new Date();
      const timeFill = dateOnly === true ? null : 0;

      if (props.calendar === 'persian') {
        const jDate = toJalaali(d);
        return {
          year: jDate.jy,
          month: jDate.jm,
          day: jDate.jd
        }
      }

      return {
        year: d.getFullYear(),
        month: d.getMonth() + 1,
        day: d.getDate(),
        hour: timeFill,
        minute: timeFill,
        second: timeFill,
        millisecond: timeFill
      }
    }

    return {
      editable,
      tabindex,
      headerClass,

      getLocale,
      getCurrentDate
    }
  }

  /* eslint no-fallthrough: 0 */

  const
    MILLISECONDS_IN_DAY = 86400000,
    MILLISECONDS_IN_HOUR = 3600000,
    MILLISECONDS_IN_MINUTE = 60000,
    defaultMask = 'YYYY-MM-DDTHH:mm:ss.SSSZ',
    token = /\[((?:[^\]\\]|\\]|\\)*)\]|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]/g,
    reverseToken = /(\[[^\]]*\])|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]|([.*+:?^,\s${}()|\\]+)/g,
    regexStore = {};

  function getRegexData (mask, dateLocale) {
    const
      days = '(' + dateLocale.days.join('|') + ')',
      key = mask + days;

    if (regexStore[ key ] !== void 0) {
      return regexStore[ key ]
    }

    const
      daysShort = '(' + dateLocale.daysShort.join('|') + ')',
      months = '(' + dateLocale.months.join('|') + ')',
      monthsShort = '(' + dateLocale.monthsShort.join('|') + ')';

    const map = {};
    let index = 0;

    const regexText = mask.replace(reverseToken, match => {
      index++;
      switch (match) {
        case 'YY':
          map.YY = index;
          return '(-?\\d{1,2})'
        case 'YYYY':
          map.YYYY = index;
          return '(-?\\d{1,4})'
        case 'M':
          map.M = index;
          return '(\\d{1,2})'
        case 'MM':
          map.M = index; // bumping to M
          return '(\\d{2})'
        case 'MMM':
          map.MMM = index;
          return monthsShort
        case 'MMMM':
          map.MMMM = index;
          return months
        case 'D':
          map.D = index;
          return '(\\d{1,2})'
        case 'Do':
          map.D = index++; // bumping to D
          return '(\\d{1,2}(st|nd|rd|th))'
        case 'DD':
          map.D = index; // bumping to D
          return '(\\d{2})'
        case 'H':
          map.H = index;
          return '(\\d{1,2})'
        case 'HH':
          map.H = index; // bumping to H
          return '(\\d{2})'
        case 'h':
          map.h = index;
          return '(\\d{1,2})'
        case 'hh':
          map.h = index; // bumping to h
          return '(\\d{2})'
        case 'm':
          map.m = index;
          return '(\\d{1,2})'
        case 'mm':
          map.m = index; // bumping to m
          return '(\\d{2})'
        case 's':
          map.s = index;
          return '(\\d{1,2})'
        case 'ss':
          map.s = index; // bumping to s
          return '(\\d{2})'
        case 'S':
          map.S = index;
          return '(\\d{1})'
        case 'SS':
          map.S = index; // bump to S
          return '(\\d{2})'
        case 'SSS':
          map.S = index; // bump to S
          return '(\\d{3})'
        case 'A':
          map.A = index;
          return '(AM|PM)'
        case 'a':
          map.a = index;
          return '(am|pm)'
        case 'aa':
          map.aa = index;
          return '(a\\.m\\.|p\\.m\\.)'

        case 'ddd':
          return daysShort
        case 'dddd':
          return days
        case 'Q':
        case 'd':
        case 'E':
          return '(\\d{1})'
        case 'Qo':
          return '(1st|2nd|3rd|4th)'
        case 'DDD':
        case 'DDDD':
          return '(\\d{1,3})'
        case 'w':
          return '(\\d{1,2})'
        case 'ww':
          return '(\\d{2})'

        case 'Z': // to split: (?:(Z)()()|([+-])?(\\d{2}):?(\\d{2}))
          map.Z = index;
          return '(Z|[+-]\\d{2}:\\d{2})'
        case 'ZZ':
          map.ZZ = index;
          return '(Z|[+-]\\d{2}\\d{2})'

        case 'X':
          map.X = index;
          return '(-?\\d+)'
        case 'x':
          map.x = index;
          return '(-?\\d{4,})'

        default:
          index--;
          if (match[ 0 ] === '[') {
            match = match.substring(1, match.length - 1);
          }
          return match.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      }
    });

    const res = { map, regex: new RegExp('^' + regexText) };
    regexStore[ key ] = res;

    return res
  }

  function getDateLocale (paramDateLocale, langProps) {
    return paramDateLocale !== void 0
      ? paramDateLocale
      : (
          langProps !== void 0
            ? langProps.date
            : defaultLang.date
        )
  }

  function formatTimezone (offset, delimeter = '') {
    const
      sign = offset > 0 ? '-' : '+',
      absOffset = Math.abs(offset),
      hours = Math.floor(absOffset / 60),
      minutes = absOffset % 60;

    return sign + pad(hours) + delimeter + pad(minutes)
  }

  function applyYearMonthDayChange (date, mod, sign) {
    let
      year = date.getFullYear(),
      month = date.getMonth();

    const day = date.getDate();

    if (mod.year !== void 0) {
      year += sign * mod.year;
      delete mod.year;
    }

    if (mod.month !== void 0) {
      month += sign * mod.month;
      delete mod.month;
    }

    date.setDate(1);
    date.setMonth(2);

    date.setFullYear(year);
    date.setMonth(month);
    date.setDate(Math.min(day, daysInMonth(date)));

    if (mod.date !== void 0) {
      date.setDate(date.getDate() + sign * mod.date);
      delete mod.date;
    }

    return date
  }

  function applyYearMonthDay (date, mod, middle) {
    const
      year = mod.year !== void 0 ? mod.year : date[ `get${ middle }FullYear` ](),
      month = mod.month !== void 0 ? mod.month - 1 : date[ `get${ middle }Month` ](),
      maxDay = (new Date(year, month + 1, 0)).getDate(),
      day = Math.min(maxDay, mod.date !== void 0 ? mod.date : date[ `get${ middle }Date` ]());

    date[ `set${ middle }Date` ](1);
    date[ `set${ middle }Month` ](2);

    date[ `set${ middle }FullYear` ](year);
    date[ `set${ middle }Month` ](month);
    date[ `set${ middle }Date` ](day);

    delete mod.year;
    delete mod.month;
    delete mod.date;

    return date
  }

  function getChange (date, rawMod, sign) {
    const
      mod = normalizeMod(rawMod),
      d = new Date(date),
      t = mod.year !== void 0 || mod.month !== void 0 || mod.date !== void 0
        ? applyYearMonthDayChange(d, mod, sign) // removes year/month/day
        : d;

    for (const key in mod) {
      const op = capitalize(key);
      t[ `set${ op }` ](t[ `get${ op }` ]() + sign * mod[ key ]);
    }

    return t
  }

  function normalizeMod (mod) {
    const acc = { ...mod };

    if (mod.years !== void 0) {
      acc.year = mod.years;
      delete acc.years;
    }

    if (mod.months !== void 0) {
      acc.month = mod.months;
      delete acc.months;
    }

    if (mod.days !== void 0) {
      acc.date = mod.days;
      delete acc.days;
    }
    if (mod.day !== void 0) {
      acc.date = mod.day;
      delete acc.day;
    }

    if (mod.hour !== void 0) {
      acc.hours = mod.hour;
      delete acc.hour;
    }

    if (mod.minute !== void 0) {
      acc.minutes = mod.minute;
      delete acc.minute;
    }

    if (mod.second !== void 0) {
      acc.seconds = mod.second;
      delete acc.second;
    }

    if (mod.millisecond !== void 0) {
      acc.milliseconds = mod.millisecond;
      delete acc.millisecond;
    }

    return acc
  }

  function adjustDate (date, rawMod, utc) {
    const
      mod = normalizeMod(rawMod),
      middle = utc === true ? 'UTC' : '',
      d = new Date(date),
      t = mod.year !== void 0 || mod.month !== void 0 || mod.date !== void 0
        ? applyYearMonthDay(d, mod, middle) // removes year/month/day
        : d;

    for (const key in mod) {
      const op = key.charAt(0).toUpperCase() + key.slice(1);
      t[ `set${ middle }${ op }` ](mod[ key ]);
    }

    return t
  }

  function extractDate (str, mask, dateLocale) {
    const d = __splitDate(str, mask, dateLocale);

    const date = new Date(
      d.year,
      d.month === null ? null : d.month - 1,
      d.day === null ? 1 : d.day,
      d.hour,
      d.minute,
      d.second,
      d.millisecond
    );

    const tzOffset = date.getTimezoneOffset();

    return d.timezoneOffset === null || d.timezoneOffset === tzOffset
      ? date
      : getChange(date, { minutes: d.timezoneOffset - tzOffset }, 1)
  }

  function __splitDate (str, mask, dateLocale, calendar, defaultModel) {
    const date = {
      year: null,
      month: null,
      day: null,
      hour: null,
      minute: null,
      second: null,
      millisecond: null,
      timezoneOffset: null,
      dateHash: null,
      timeHash: null
    };

    defaultModel !== void 0 && Object.assign(date, defaultModel);

    if (
      str === void 0
      || str === null
      || str === ''
      || typeof str !== 'string'
    ) {
      return date
    }

    if (mask === void 0) {
      mask = defaultMask;
    }

    const
      langOpts = getDateLocale(dateLocale, Plugin$8.props),
      months = langOpts.months,
      monthsShort = langOpts.monthsShort;

    const { regex, map } = getRegexData(mask, langOpts);

    const match = str.match(regex);

    if (match === null) {
      return date
    }

    let tzString = '';

    if (map.X !== void 0 || map.x !== void 0) {
      const stamp = parseInt(match[ map.X !== void 0 ? map.X : map.x ], 10);

      if (isNaN(stamp) === true || stamp < 0) {
        return date
      }

      const d = new Date(stamp * (map.X !== void 0 ? 1000 : 1));

      date.year = d.getFullYear();
      date.month = d.getMonth() + 1;
      date.day = d.getDate();
      date.hour = d.getHours();
      date.minute = d.getMinutes();
      date.second = d.getSeconds();
      date.millisecond = d.getMilliseconds();
    }
    else {
      if (map.YYYY !== void 0) {
        date.year = parseInt(match[ map.YYYY ], 10);
      }
      else if (map.YY !== void 0) {
        const y = parseInt(match[ map.YY ], 10);
        date.year = y < 0 ? y : 2000 + y;
      }

      if (map.M !== void 0) {
        date.month = parseInt(match[ map.M ], 10);
        if (date.month < 1 || date.month > 12) {
          return date
        }
      }
      else if (map.MMM !== void 0) {
        date.month = monthsShort.indexOf(match[ map.MMM ]) + 1;
      }
      else if (map.MMMM !== void 0) {
        date.month = months.indexOf(match[ map.MMMM ]) + 1;
      }

      if (map.D !== void 0) {
        date.day = parseInt(match[ map.D ], 10);

        if (date.year === null || date.month === null || date.day < 1) {
          return date
        }

        const maxDay = calendar !== 'persian'
          ? (new Date(date.year, date.month, 0)).getDate()
          : jalaaliMonthLength(date.year, date.month);

        if (date.day > maxDay) {
          return date
        }
      }

      if (map.H !== void 0) {
        date.hour = parseInt(match[ map.H ], 10) % 24;
      }
      else if (map.h !== void 0) {
        date.hour = parseInt(match[ map.h ], 10) % 12;
        if (
          (map.A && match[ map.A ] === 'PM')
          || (map.a && match[ map.a ] === 'pm')
          || (map.aa && match[ map.aa ] === 'p.m.')
        ) {
          date.hour += 12;
        }
        date.hour = date.hour % 24;
      }

      if (map.m !== void 0) {
        date.minute = parseInt(match[ map.m ], 10) % 60;
      }

      if (map.s !== void 0) {
        date.second = parseInt(match[ map.s ], 10) % 60;
      }

      if (map.S !== void 0) {
        date.millisecond = parseInt(match[ map.S ], 10) * 10 ** (3 - match[ map.S ].length);
      }

      if (map.Z !== void 0 || map.ZZ !== void 0) {
        tzString = (map.Z !== void 0 ? match[ map.Z ].replace(':', '') : match[ map.ZZ ]);
        date.timezoneOffset = (tzString[ 0 ] === '+' ? -1 : 1) * (60 * tzString.slice(1, 3) + 1 * tzString.slice(3, 5));
      }
    }

    date.dateHash = pad(date.year, 6) + '/' + pad(date.month) + '/' + pad(date.day);
    date.timeHash = pad(date.hour) + ':' + pad(date.minute) + ':' + pad(date.second) + tzString;

    return date
  }

  function isValid (date) {
    return typeof date === 'number'
      ? true
      : isNaN(Date.parse(date)) === false
  }

  function buildDate (mod, utc) {
    return adjustDate(new Date(), mod, utc)
  }

  function getDayOfWeek (date) {
    const dow = new Date(date).getDay();
    return dow === 0 ? 7 : dow
  }

  function getWeekOfYear (date) {
    // Remove time components of date
    const thursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    // Change date to Thursday same week
    thursday.setDate(thursday.getDate() - ((thursday.getDay() + 6) % 7) + 3);

    // Take January 4th as it is always in week 1 (see ISO 8601)
    const firstThursday = new Date(thursday.getFullYear(), 0, 4);

    // Change date to Thursday same week
    firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

    // Check if daylight-saving-time-switch occurred and correct for it
    const ds = thursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
    thursday.setHours(thursday.getHours() - ds);

    // Number of weeks between target Thursday and first Thursday
    const weekDiff = (thursday - firstThursday) / (MILLISECONDS_IN_DAY * 7);
    return 1 + Math.floor(weekDiff)
  }

  function getDayIdentifier (date) {
    return date.getFullYear() * 10000 + date.getMonth() * 100 + date.getDate()
  }

  function getDateIdentifier (date, onlyDate /* = false */) {
    const d = new Date(date);
    return onlyDate === true ? getDayIdentifier(d) : d.getTime()
  }

  function isBetweenDates (date, from, to, opts = {}) {
    const
      d1 = getDateIdentifier(from, opts.onlyDate),
      d2 = getDateIdentifier(to, opts.onlyDate),
      cur = getDateIdentifier(date, opts.onlyDate);

    return (cur > d1 || (opts.inclusiveFrom === true && cur === d1))
      && (cur < d2 || (opts.inclusiveTo === true && cur === d2))
  }

  function addToDate (date, mod) {
    return getChange(date, mod, 1)
  }
  function subtractFromDate (date, mod) {
    return getChange(date, mod, -1)
  }

  function startOfDate (date, unit, utc) {
    const
      t = new Date(date),
      prefix = `set${ utc === true ? 'UTC' : '' }`;

    switch (unit) {
      case 'year':
      case 'years':
        t[ `${ prefix }Month` ](0);
      case 'month':
      case 'months':
        t[ `${ prefix }Date` ](1);
      case 'day':
      case 'days':
      case 'date':
        t[ `${ prefix }Hours` ](0);
      case 'hour':
      case 'hours':
        t[ `${ prefix }Minutes` ](0);
      case 'minute':
      case 'minutes':
        t[ `${ prefix }Seconds` ](0);
      case 'second':
      case 'seconds':
        t[ `${ prefix }Milliseconds` ](0);
    }
    return t
  }

  function endOfDate (date, unit, utc) {
    const
      t = new Date(date),
      prefix = `set${ utc === true ? 'UTC' : '' }`;

    switch (unit) {
      case 'year':
      case 'years':
        t[ `${ prefix }Month` ](11);
      case 'month':
      case 'months':
        t[ `${ prefix }Date` ](daysInMonth(t));
      case 'day':
      case 'days':
      case 'date':
        t[ `${ prefix }Hours` ](23);
      case 'hour':
      case 'hours':
        t[ `${ prefix }Minutes` ](59);
      case 'minute':
      case 'minutes':
        t[ `${ prefix }Seconds` ](59);
      case 'second':
      case 'seconds':
        t[ `${ prefix }Milliseconds` ](999);
    }
    return t
  }

  function getMaxDate (date /* , ...args */) {
    let t = new Date(date);
    Array.prototype.slice.call(arguments, 1).forEach(d => {
      t = Math.max(t, new Date(d));
    });
    return t
  }

  function getMinDate (date /*, ...args */) {
    let t = new Date(date);
    Array.prototype.slice.call(arguments, 1).forEach(d => {
      t = Math.min(t, new Date(d));
    });
    return t
  }

  function getDiff (t, sub, interval) {
    return (
      (t.getTime() - t.getTimezoneOffset() * MILLISECONDS_IN_MINUTE)
      - (sub.getTime() - sub.getTimezoneOffset() * MILLISECONDS_IN_MINUTE)
    ) / interval
  }

  function getDateDiff (date, subtract, unit = 'days') {
    const
      t = new Date(date),
      sub = new Date(subtract);

    switch (unit) {
      case 'years':
      case 'year':
        return (t.getFullYear() - sub.getFullYear())

      case 'months':
      case 'month':
        return (t.getFullYear() - sub.getFullYear()) * 12 + t.getMonth() - sub.getMonth()

      case 'days':
      case 'day':
      case 'date':
        return getDiff(startOfDate(t, 'day'), startOfDate(sub, 'day'), MILLISECONDS_IN_DAY)

      case 'hours':
      case 'hour':
        return getDiff(startOfDate(t, 'hour'), startOfDate(sub, 'hour'), MILLISECONDS_IN_HOUR)

      case 'minutes':
      case 'minute':
        return getDiff(startOfDate(t, 'minute'), startOfDate(sub, 'minute'), MILLISECONDS_IN_MINUTE)

      case 'seconds':
      case 'second':
        return getDiff(startOfDate(t, 'second'), startOfDate(sub, 'second'), 1000)
    }
  }

  function getDayOfYear (date) {
    return getDateDiff(date, startOfDate(date, 'year'), 'days') + 1
  }

  function inferDateFormat (date) {
    return isDate(date) === true
      ? 'date'
      : (typeof date === 'number' ? 'number' : 'string')
  }

  function getDateBetween (date, min, max) {
    const t = new Date(date);

    if (min) {
      const low = new Date(min);
      if (t < low) {
        return low
      }
    }

    if (max) {
      const high = new Date(max);
      if (t > high) {
        return high
      }
    }

    return t
  }

  function isSameDate (date, date2, unit) {
    const
      t = new Date(date),
      d = new Date(date2);

    if (unit === void 0) {
      return t.getTime() === d.getTime()
    }

    switch (unit) {
      case 'second':
      case 'seconds':
        if (t.getSeconds() !== d.getSeconds()) {
          return false
        }
      case 'minute': // intentional fall-through
      case 'minutes':
        if (t.getMinutes() !== d.getMinutes()) {
          return false
        }
      case 'hour': // intentional fall-through
      case 'hours':
        if (t.getHours() !== d.getHours()) {
          return false
        }
      case 'day': // intentional fall-through
      case 'days':
      case 'date':
        if (t.getDate() !== d.getDate()) {
          return false
        }
      case 'month': // intentional fall-through
      case 'months':
        if (t.getMonth() !== d.getMonth()) {
          return false
        }
      case 'year': // intentional fall-through
      case 'years':
        if (t.getFullYear() !== d.getFullYear()) {
          return false
        }
        break
      default:
        throw new Error(`date isSameDate unknown unit ${ unit }`)
    }

    return true
  }

  function daysInMonth (date) {
    return (new Date(date.getFullYear(), date.getMonth() + 1, 0)).getDate()
  }

  function getOrdinal (n) {
    if (n >= 11 && n <= 13) {
      return `${ n }th`
    }
    switch (n % 10) {
      case 1: return `${ n }st`
      case 2: return `${ n }nd`
      case 3: return `${ n }rd`
    }
    return `${ n }th`
  }

  const formatter = {
    // Year: 00, 01, ..., 99
    YY (date, dateLocale, forcedYear) {
      // workaround for < 1900 with new Date()
      const y = this.YYYY(date, dateLocale, forcedYear) % 100;
      return y >= 0
        ? pad(y)
        : '-' + pad(Math.abs(y))
    },

    // Year: 1900, 1901, ..., 2099
    YYYY (date, _dateLocale, forcedYear) {
      // workaround for < 1900 with new Date()
      return forcedYear !== void 0 && forcedYear !== null
        ? forcedYear
        : date.getFullYear()
    },

    // Month: 1, 2, ..., 12
    M (date) {
      return date.getMonth() + 1
    },

    // Month: 01, 02, ..., 12
    MM (date) {
      return pad(date.getMonth() + 1)
    },

    // Month Short Name: Jan, Feb, ...
    MMM (date, dateLocale) {
      return dateLocale.monthsShort[ date.getMonth() ]
    },

    // Month Name: January, February, ...
    MMMM (date, dateLocale) {
      return dateLocale.months[ date.getMonth() ]
    },

    // Quarter: 1, 2, 3, 4
    Q (date) {
      return Math.ceil((date.getMonth() + 1) / 3)
    },

    // Quarter: 1st, 2nd, 3rd, 4th
    Qo (date) {
      return getOrdinal(this.Q(date))
    },

    // Day of month: 1, 2, ..., 31
    D (date) {
      return date.getDate()
    },

    // Day of month: 1st, 2nd, ..., 31st
    Do (date) {
      return getOrdinal(date.getDate())
    },

    // Day of month: 01, 02, ..., 31
    DD (date) {
      return pad(date.getDate())
    },

    // Day of year: 1, 2, ..., 366
    DDD (date) {
      return getDayOfYear(date)
    },

    // Day of year: 001, 002, ..., 366
    DDDD (date) {
      return pad(getDayOfYear(date), 3)
    },

    // Day of week: 0, 1, ..., 6
    d (date) {
      return date.getDay()
    },

    // Day of week: Su, Mo, ...
    dd (date, dateLocale) {
      return this.dddd(date, dateLocale).slice(0, 2)
    },

    // Day of week: Sun, Mon, ...
    ddd (date, dateLocale) {
      return dateLocale.daysShort[ date.getDay() ]
    },

    // Day of week: Sunday, Monday, ...
    dddd (date, dateLocale) {
      return dateLocale.days[ date.getDay() ]
    },

    // Day of ISO week: 1, 2, ..., 7
    E (date) {
      return date.getDay() || 7
    },

    // Week of Year: 1 2 ... 52 53
    w (date) {
      return getWeekOfYear(date)
    },

    // Week of Year: 01 02 ... 52 53
    ww (date) {
      return pad(getWeekOfYear(date))
    },

    // Hour: 0, 1, ... 23
    H (date) {
      return date.getHours()
    },

    // Hour: 00, 01, ..., 23
    HH (date) {
      return pad(date.getHours())
    },

    // Hour: 1, 2, ..., 12
    h (date) {
      const hours = date.getHours();
      return hours === 0
        ? 12
        : (hours > 12 ? hours % 12 : hours)
    },

    // Hour: 01, 02, ..., 12
    hh (date) {
      return pad(this.h(date))
    },

    // Minute: 0, 1, ..., 59
    m (date) {
      return date.getMinutes()
    },

    // Minute: 00, 01, ..., 59
    mm (date) {
      return pad(date.getMinutes())
    },

    // Second: 0, 1, ..., 59
    s (date) {
      return date.getSeconds()
    },

    // Second: 00, 01, ..., 59
    ss (date) {
      return pad(date.getSeconds())
    },

    // 1/10 of second: 0, 1, ..., 9
    S (date) {
      return Math.floor(date.getMilliseconds() / 100)
    },

    // 1/100 of second: 00, 01, ..., 99
    SS (date) {
      return pad(Math.floor(date.getMilliseconds() / 10))
    },

    // Millisecond: 000, 001, ..., 999
    SSS (date) {
      return pad(date.getMilliseconds(), 3)
    },

    // Meridiem: AM, PM
    A (date) {
      return this.H(date) < 12 ? 'AM' : 'PM'
    },

    // Meridiem: am, pm
    a (date) {
      return this.H(date) < 12 ? 'am' : 'pm'
    },

    // Meridiem: a.m., p.m.
    aa (date) {
      return this.H(date) < 12 ? 'a.m.' : 'p.m.'
    },

    // Timezone: -01:00, +00:00, ... +12:00
    Z (date, _dateLocale, _forcedYear, forcedTimezoneOffset) {
      const tzOffset = forcedTimezoneOffset === void 0 || forcedTimezoneOffset === null
        ? date.getTimezoneOffset()
        : forcedTimezoneOffset;

      return formatTimezone(tzOffset, ':')
    },

    // Timezone: -0100, +0000, ... +1200
    ZZ (date, _dateLocale, _forcedYear, forcedTimezoneOffset) {
      const tzOffset = forcedTimezoneOffset === void 0 || forcedTimezoneOffset === null
        ? date.getTimezoneOffset()
        : forcedTimezoneOffset;

      return formatTimezone(tzOffset)
    },

    // Seconds timestamp: 512969520
    X (date) {
      return Math.floor(date.getTime() / 1000)
    },

    // Milliseconds timestamp: 512969520900
    x (date) {
      return date.getTime()
    }
  };

  function formatDate (val, mask, dateLocale, __forcedYear, __forcedTimezoneOffset) {
    if (
      (val !== 0 && !val)
      || val === Infinity
      || val === -Infinity
    ) {
      return
    }

    const date = new Date(val);

    if (isNaN(date)) {
      return
    }

    if (mask === void 0) {
      mask = defaultMask;
    }

    const locale = getDateLocale(dateLocale, Plugin$8.props);

    return mask.replace(
      token,
      (match, text) => (
        match in formatter
          ? formatter[ match ](date, locale, __forcedYear, __forcedTimezoneOffset)
          : (text === void 0 ? match : text.split('\\]').join(']'))
      )
    )
  }

  function clone (date) {
    return isDate(date) === true
      ? new Date(date.getTime())
      : date
  }

  var date = {
    isValid,
    extractDate,
    buildDate,
    getDayOfWeek,
    getWeekOfYear,
    isBetweenDates,
    addToDate,
    subtractFromDate,
    adjustDate,
    startOfDate,
    endOfDate,
    getMaxDate,
    getMinDate,
    getDateDiff,
    getDayOfYear,
    inferDateFormat,
    getDateBetween,
    isSameDate,
    daysInMonth,
    formatDate,
    clone
  };

  const yearsInterval = 20;
  const views = [ 'Calendar', 'Years', 'Months' ];
  const viewIsValid = v => views.includes(v);
  const yearMonthValidator = v => /^-?[\d]+\/[0-1]\d$/.test(v);
  const lineStr = ' \u2014 ';

  function getMonthHash (date) {
    return date.year + '/' + pad(date.month)
  }

  var QDate = createComponent({
    name: 'QDate',

    props: {
      ...useDatetimeProps,
      ...useFormProps,
      ...useDarkProps,

      multiple: Boolean,
      range: Boolean,

      title: String,
      subtitle: String,

      mask: {
        // this mask is forced
        // when using persian calendar
        default: 'YYYY/MM/DD'
      },

      defaultYearMonth: {
        type: String,
        validator: yearMonthValidator
      },

      yearsInMonthView: Boolean,

      events: [ Array, Function ],
      eventColor: [ String, Function ],

      emitImmediately: Boolean,

      options: [ Array, Function ],

      navigationMinYearMonth: {
        type: String,
        validator: yearMonthValidator
      },

      navigationMaxYearMonth: {
        type: String,
        validator: yearMonthValidator
      },

      noUnset: Boolean,

      firstDayOfWeek: [ String, Number ],
      todayBtn: Boolean,
      minimal: Boolean,
      defaultView: {
        type: String,
        default: 'Calendar',
        validator: viewIsValid
      }
    },

    emits: [
      ...useDatetimeEmits,
      'rangeStart', 'rangeEnd', 'navigation'
    ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const isDark = useDark(props, $q);
      const { getCache } = useCache();
      const { tabindex, headerClass, getLocale, getCurrentDate } = useDatetime(props, $q);

      let lastEmitValue;

      const formAttrs = useFormAttrs(props);
      const injectFormInput = useFormInject(formAttrs);

      const blurTargetRef = vue.ref(null);
      const innerMask = vue.ref(getMask());
      const innerLocale = vue.ref(getLocale());

      const mask = vue.computed(() => getMask());
      const locale = vue.computed(() => getLocale());

      const today = vue.computed(() => getCurrentDate());

      // model of current calendar view:
      const viewModel = vue.ref(getViewModel(innerMask.value, innerLocale.value));

      const view = vue.ref(props.defaultView);

      const direction = $q.lang.rtl === true ? 'right' : 'left';
      const monthDirection = vue.ref(direction.value);
      const yearDirection = vue.ref(direction.value);

      const year = viewModel.value.year;
      const startYear = vue.ref(year - (year % yearsInterval) - (year < 0 ? yearsInterval : 0));
      const editRange = vue.ref(null);

      const classes = vue.computed(() => {
        const type = props.landscape === true ? 'landscape' : 'portrait';
        return `q-date q-date--${ type } q-date--${ type }-${ props.minimal === true ? 'minimal' : 'standard' }`
          + (isDark.value === true ? ' q-date--dark q-dark' : '')
          + (props.bordered === true ? ' q-date--bordered' : '')
          + (props.square === true ? ' q-date--square no-border-radius' : '')
          + (props.flat === true ? ' q-date--flat no-shadow' : '')
          + (props.disable === true ? ' disabled' : (props.readonly === true ? ' q-date--readonly' : ''))
      });

      const computedColor = vue.computed(() => {
        return props.color || 'primary'
      });

      const computedTextColor = vue.computed(() => {
        return props.textColor || 'white'
      });

      const isImmediate = vue.computed(() =>
        props.emitImmediately === true
        && props.multiple !== true
        && props.range !== true
      );

      const normalizedModel = vue.computed(() => (
        Array.isArray(props.modelValue) === true
          ? props.modelValue
          : (props.modelValue !== null && props.modelValue !== void 0 ? [ props.modelValue ] : [])
      ));

      const daysModel = vue.computed(() =>
        normalizedModel.value
          .filter(date => typeof date === 'string')
          .map(date => decodeString(date, innerMask.value, innerLocale.value))
          .filter(date =>
            date.dateHash !== null
            && date.day !== null
            && date.month !== null
            && date.year !== null
          )
      );

      const rangeModel = vue.computed(() => {
        const fn = date => decodeString(date, innerMask.value, innerLocale.value);
        return normalizedModel.value
          .filter(date => isObject(date) === true && date.from !== void 0 && date.to !== void 0)
          .map(range => ({ from: fn(range.from), to: fn(range.to) }))
          .filter(range => range.from.dateHash !== null && range.to.dateHash !== null && range.from.dateHash < range.to.dateHash)
      });

      const getNativeDateFn = vue.computed(() => (
        props.calendar !== 'persian'
          ? model => new Date(model.year, model.month - 1, model.day)
          : model => {
            const gDate = toGregorian(model.year, model.month, model.day);
            return new Date(gDate.gy, gDate.gm - 1, gDate.gd)
          }
      ));

      const encodeObjectFn = vue.computed(() => (
        props.calendar === 'persian'
          ? getDayHash
          : (date, mask, locale) => formatDate(
              new Date(
                date.year,
                date.month - 1,
                date.day,
                date.hour,
                date.minute,
                date.second,
                date.millisecond
              ),
              mask === void 0 ? innerMask.value : mask,
              locale === void 0 ? innerLocale.value : locale,
              date.year,
              date.timezoneOffset
            )
      ));

      const daysInModel = vue.computed(() =>
        daysModel.value.length + rangeModel.value.reduce(
          (acc, range) => acc + 1 + getDateDiff(
            getNativeDateFn.value(range.to),
            getNativeDateFn.value(range.from)
          ),
          0
        )
      );

      const headerTitle = vue.computed(() => {
        if (props.title !== void 0 && props.title !== null && props.title.length > 0) {
          return props.title
        }

        if (editRange.value !== null) {
          const model = editRange.value.init;
          const date = getNativeDateFn.value(model);

          return innerLocale.value.daysShort[ date.getDay() ] + ', '
            + innerLocale.value.monthsShort[ model.month - 1 ] + ' '
            + model.day + lineStr + '?'
        }

        if (daysInModel.value === 0) {
          return lineStr
        }

        if (daysInModel.value > 1) {
          return `${ daysInModel.value } ${ innerLocale.value.pluralDay }`
        }

        const model = daysModel.value[ 0 ];
        const date = getNativeDateFn.value(model);

        if (isNaN(date.valueOf()) === true) {
          return lineStr
        }

        if (innerLocale.value.headerTitle !== void 0) {
          return innerLocale.value.headerTitle(date, model)
        }

        return innerLocale.value.daysShort[ date.getDay() ] + ', '
          + innerLocale.value.monthsShort[ model.month - 1 ] + ' '
          + model.day
      });

      const minSelectedModel = vue.computed(() => {
        const model = daysModel.value.concat(rangeModel.value.map(range => range.from))
          .sort((a, b) => a.year - b.year || a.month - b.month);

        return model[ 0 ]
      });

      const maxSelectedModel = vue.computed(() => {
        const model = daysModel.value.concat(rangeModel.value.map(range => range.to))
          .sort((a, b) => b.year - a.year || b.month - a.month);

        return model[ 0 ]
      });

      const headerSubtitle = vue.computed(() => {
        if (props.subtitle !== void 0 && props.subtitle !== null && props.subtitle.length > 0) {
          return props.subtitle
        }

        if (daysInModel.value === 0) {
          return lineStr
        }

        if (daysInModel.value > 1) {
          const from = minSelectedModel.value;
          const to = maxSelectedModel.value;
          const month = innerLocale.value.monthsShort;

          return month[ from.month - 1 ] + (
            from.year !== to.year
              ? ' ' + from.year + lineStr + month[ to.month - 1 ] + ' '
              : (
                  from.month !== to.month
                    ? lineStr + month[ to.month - 1 ]
                    : ''
                )
          ) + ' ' + to.year
        }

        return daysModel.value[ 0 ].year
      });

      const dateArrow = vue.computed(() => {
        const val = [ $q.iconSet.datetime.arrowLeft, $q.iconSet.datetime.arrowRight ];
        return $q.lang.rtl === true ? val.reverse() : val
      });

      const computedFirstDayOfWeek = vue.computed(() => (
        props.firstDayOfWeek !== void 0
          ? Number(props.firstDayOfWeek)
          : innerLocale.value.firstDayOfWeek
      ));

      const daysOfWeek = vue.computed(() => {
        const
          days = innerLocale.value.daysShort,
          first = computedFirstDayOfWeek.value;

        return first > 0
          ? days.slice(first, 7).concat(days.slice(0, first))
          : days
      });

      const daysInMonth = vue.computed(() => {
        const date = viewModel.value;
        return props.calendar !== 'persian'
          ? (new Date(date.year, date.month, 0)).getDate()
          : jalaaliMonthLength(date.year, date.month)
      });

      const evtColor = vue.computed(() => (
        typeof props.eventColor === 'function'
          ? props.eventColor
          : () => props.eventColor
      ));

      const minNav = vue.computed(() => {
        if (props.navigationMinYearMonth === void 0) {
          return null
        }

        const data = props.navigationMinYearMonth.split('/');
        return { year: parseInt(data[ 0 ], 10), month: parseInt(data[ 1 ], 10) }
      });

      const maxNav = vue.computed(() => {
        if (props.navigationMaxYearMonth === void 0) {
          return null
        }

        const data = props.navigationMaxYearMonth.split('/');
        return { year: parseInt(data[ 0 ], 10), month: parseInt(data[ 1 ], 10) }
      });

      const navBoundaries = vue.computed(() => {
        const data = {
          month: { prev: true, next: true },
          year: { prev: true, next: true }
        };

        if (minNav.value !== null && minNav.value.year >= viewModel.value.year) {
          data.year.prev = false;
          if (minNav.value.year === viewModel.value.year && minNav.value.month >= viewModel.value.month) {
            data.month.prev = false;
          }
        }

        if (maxNav.value !== null && maxNav.value.year <= viewModel.value.year) {
          data.year.next = false;
          if (maxNav.value.year === viewModel.value.year && maxNav.value.month <= viewModel.value.month) {
            data.month.next = false;
          }
        }

        return data
      });

      const daysMap = vue.computed(() => {
        const map = {};

        daysModel.value.forEach(entry => {
          const hash = getMonthHash(entry);

          if (map[ hash ] === void 0) {
            map[ hash ] = [];
          }

          map[ hash ].push(entry.day);
        });

        return map
      });

      const rangeMap = vue.computed(() => {
        const map = {};

        rangeModel.value.forEach(entry => {
          const hashFrom = getMonthHash(entry.from);
          const hashTo = getMonthHash(entry.to);

          if (map[ hashFrom ] === void 0) {
            map[ hashFrom ] = [];
          }

          map[ hashFrom ].push({
            from: entry.from.day,
            to: hashFrom === hashTo ? entry.to.day : void 0,
            range: entry
          });

          if (hashFrom < hashTo) {
            let hash;
            const { year, month } = entry.from;
            const cur = month < 12
              ? { year, month: month + 1 }
              : { year: year + 1, month: 1 };

            while ((hash = getMonthHash(cur)) <= hashTo) {
              if (map[ hash ] === void 0) {
                map[ hash ] = [];
              }

              map[ hash ].push({
                from: void 0,
                to: hash === hashTo ? entry.to.day : void 0,
                range: entry
              });

              cur.month++;
              if (cur.month > 12) {
                cur.year++;
                cur.month = 1;
              }
            }
          }
        });

        return map
      });

      const rangeView = vue.computed(() => {
        if (editRange.value === null) {
          return
        }

        const { init, initHash, final, finalHash } = editRange.value;

        const [ from, to ] = initHash <= finalHash
          ? [ init, final ]
          : [ final, init ];

        const fromHash = getMonthHash(from);
        const toHash = getMonthHash(to);

        if (fromHash !== viewMonthHash.value && toHash !== viewMonthHash.value) {
          return
        }

        const view = {};

        if (fromHash === viewMonthHash.value) {
          view.from = from.day;
          view.includeFrom = true;
        }
        else {
          view.from = 1;
        }

        if (toHash === viewMonthHash.value) {
          view.to = to.day;
          view.includeTo = true;
        }
        else {
          view.to = daysInMonth.value;
        }

        return view
      });

      const viewMonthHash = vue.computed(() => getMonthHash(viewModel.value));

      const selectionDaysMap = vue.computed(() => {
        const map = {};

        if (props.options === void 0) {
          for (let i = 1; i <= daysInMonth.value; i++) {
            map[ i ] = true;
          }

          return map
        }

        const fn = typeof props.options === 'function'
          ? props.options
          : date => props.options.includes(date);

        for (let i = 1; i <= daysInMonth.value; i++) {
          const dayHash = viewMonthHash.value + '/' + pad(i);
          map[ i ] = fn(dayHash);
        }

        return map
      });

      const eventDaysMap = vue.computed(() => {
        const map = {};

        if (props.events === void 0) {
          for (let i = 1; i <= daysInMonth.value; i++) {
            map[ i ] = false;
          }
        }
        else {
          const fn = typeof props.events === 'function'
            ? props.events
            : date => props.events.includes(date);

          for (let i = 1; i <= daysInMonth.value; i++) {
            const dayHash = viewMonthHash.value + '/' + pad(i);
            map[ i ] = fn(dayHash) === true && evtColor.value(dayHash);
          }
        }

        return map
      });

      const viewDays = vue.computed(() => {
        let date, endDay;
        const { year, month } = viewModel.value;

        if (props.calendar !== 'persian') {
          date = new Date(year, month - 1, 1);
          endDay = (new Date(year, month - 1, 0)).getDate();
        }
        else {
          const gDate = toGregorian(year, month, 1);
          date = new Date(gDate.gy, gDate.gm - 1, gDate.gd);
          let prevJM = month - 1;
          let prevJY = year;
          if (prevJM === 0) {
            prevJM = 12;
            prevJY--;
          }
          endDay = jalaaliMonthLength(prevJY, prevJM);
        }

        return {
          days: date.getDay() - computedFirstDayOfWeek.value - 1,
          endDay
        }
      });

      const days = vue.computed(() => {
        const res = [];
        const { days, endDay } = viewDays.value;

        const len = days < 0 ? days + 7 : days;
        if (len < 6) {
          for (let i = endDay - len; i <= endDay; i++) {
            res.push({ i, fill: true });
          }
        }

        const index = res.length;

        for (let i = 1; i <= daysInMonth.value; i++) {
          const day = { i, event: eventDaysMap.value[ i ], classes: [] };

          if (selectionDaysMap.value[ i ] === true) {
            day.in = true;
            day.flat = true;
          }

          res.push(day);
        }

        // if current view has days in model
        if (daysMap.value[ viewMonthHash.value ] !== void 0) {
          daysMap.value[ viewMonthHash.value ].forEach(day => {
            const i = index + day - 1;
            Object.assign(res[ i ], {
              selected: true,
              unelevated: true,
              flat: false,
              color: computedColor.value,
              textColor: computedTextColor.value
            });
          });
        }

        // if current view has ranges in model
        if (rangeMap.value[ viewMonthHash.value ] !== void 0) {
          rangeMap.value[ viewMonthHash.value ].forEach(entry => {
            if (entry.from !== void 0) {
              const from = index + entry.from - 1;
              const to = index + (entry.to || daysInMonth.value) - 1;

              for (let day = from; day <= to; day++) {
                Object.assign(res[ day ], {
                  range: entry.range,
                  unelevated: true,
                  color: computedColor.value,
                  textColor: computedTextColor.value
                });
              }

              Object.assign(res[ from ], {
                rangeFrom: true,
                flat: false
              });

              entry.to !== void 0 && Object.assign(res[ to ], {
                rangeTo: true,
                flat: false
              });
            }
            else if (entry.to !== void 0) {
              const to = index + entry.to - 1;

              for (let day = index; day <= to; day++) {
                Object.assign(res[ day ], {
                  range: entry.range,
                  unelevated: true,
                  color: computedColor.value,
                  textColor: computedTextColor.value
                });
              }

              Object.assign(res[ to ], {
                flat: false,
                rangeTo: true
              });
            }
            else {
              const to = index + daysInMonth.value - 1;
              for (let day = index; day <= to; day++) {
                Object.assign(res[ day ], {
                  range: entry.range,
                  unelevated: true,
                  color: computedColor.value,
                  textColor: computedTextColor.value
                });
              }
            }
          });
        }

        if (rangeView.value !== void 0) {
          const from = index + rangeView.value.from - 1;
          const to = index + rangeView.value.to - 1;

          for (let day = from; day <= to; day++) {
            res[ day ].color = computedColor.value;
            res[ day ].editRange = true;
          }

          if (rangeView.value.includeFrom === true) {
            res[ from ].editRangeFrom = true;
          }
          if (rangeView.value.includeTo === true) {
            res[ to ].editRangeTo = true;
          }
        }

        if (viewModel.value.year === today.value.year && viewModel.value.month === today.value.month) {
          res[ index + today.value.day - 1 ].today = true;
        }

        const left = res.length % 7;
        if (left > 0) {
          const afterDays = 7 - left;
          for (let i = 1; i <= afterDays; i++) {
            res.push({ i, fill: true });
          }
        }

        res.forEach(day => {
          let cls = 'q-date__calendar-item ';

          if (day.fill === true) {
            cls += 'q-date__calendar-item--fill';
          }
          else {
            cls += `q-date__calendar-item--${ day.in === true ? 'in' : 'out' }`;

            if (day.range !== void 0) {
              cls += ` q-date__range${ day.rangeTo === true ? '-to' : (day.rangeFrom === true ? '-from' : '') }`;
            }

            if (day.editRange === true) {
              cls += ` q-date__edit-range${ day.editRangeFrom === true ? '-from' : '' }${ day.editRangeTo === true ? '-to' : '' }`;
            }

            if (day.range !== void 0 || day.editRange === true) {
              cls += ` text-${ day.color }`;
            }
          }

          day.classes = cls;
        });

        return res
      });

      const attributes = vue.computed(() => (
        props.disable === true
          ? { 'aria-disabled': 'true' }
          : (props.readonly === true ? { 'aria-readonly': 'true' } : {})
      ));

      vue.watch(() => props.modelValue, v => {
        if (lastEmitValue === v) {
          lastEmitValue = 0;
        }
        else {
          const model = getViewModel(innerMask.value, innerLocale.value);
          updateViewModel(model.year, model.month, model);
        }
      });

      vue.watch(view, () => {
        if (blurTargetRef.value !== null && proxy.$el.contains(document.activeElement) === true) {
          blurTargetRef.value.focus();
        }
      });

      vue.watch(() => viewModel.value.year + '|' + viewModel.value.month, () => {
        emit('navigation', { year: viewModel.value.year, month: viewModel.value.month });
      });

      vue.watch(mask, val => {
        updateValue(val, innerLocale.value, 'mask');
        innerMask.value = val;
      });

      vue.watch(locale, val => {
        updateValue(innerMask.value, val, 'locale');
        innerLocale.value = val;
      });

      function setToday () {
        const date = today.value;
        const month = daysMap.value[ getMonthHash(date) ];

        if (month === void 0 || month.includes(date.day) === false) {
          addToModel(date);
        }

        setCalendarTo(date.year, date.month);
      }

      function setView (viewMode) {
        if (viewIsValid(viewMode) === true) {
          view.value = viewMode;
        }
      }

      function offsetCalendar (type, descending) {
        if ([ 'month', 'year' ].includes(type)) {
          const fn = type === 'month' ? goToMonth : goToYear;
          fn(descending === true ? -1 : 1);
        }
      }

      function setCalendarTo (year, month) {
        view.value = 'Calendar';
        updateViewModel(year, month);
      }

      function setEditingRange (from, to) {
        if (props.range === false || !from) {
          editRange.value = null;
          return
        }

        const init = Object.assign({ ...viewModel.value }, from);
        const final = to !== void 0
          ? Object.assign({ ...viewModel.value }, to)
          : init;

        editRange.value = {
          init,
          initHash: getDayHash(init),
          final,
          finalHash: getDayHash(final)
        };

        setCalendarTo(init.year, init.month);
      }

      function getMask () {
        return props.calendar === 'persian' ? 'YYYY/MM/DD' : props.mask
      }

      function decodeString (date, mask, locale) {
        return __splitDate(
          date,
          mask,
          locale,
          props.calendar,
          {
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0
          }
        )
      }

      function getViewModel (mask, locale) {
        const model = Array.isArray(props.modelValue) === true
          ? props.modelValue
          : (props.modelValue ? [ props.modelValue ] : []);

        if (model.length === 0) {
          return getDefaultViewModel()
        }

        const target = model[ model.length - 1 ];
        const decoded = decodeString(
          target.from !== void 0 ? target.from : target,
          mask,
          locale
        );

        return decoded.dateHash === null
          ? getDefaultViewModel()
          : decoded
      }

      function getDefaultViewModel () {
        let year, month;

        if (props.defaultYearMonth !== void 0) {
          const d = props.defaultYearMonth.split('/');
          year = parseInt(d[ 0 ], 10);
          month = parseInt(d[ 1 ], 10);
        }
        else {
          // may come from data() where computed
          // props are not yet available
          const d = today.value !== void 0
            ? today.value
            : getCurrentDate();

          year = d.year;
          month = d.month;
        }

        return {
          year,
          month,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          dateHash: year + '/' + pad(month) + '/01'
        }
      }

      function goToMonth (offset) {
        let year = viewModel.value.year;
        let month = Number(viewModel.value.month) + offset;

        if (month === 13) {
          month = 1;
          year++;
        }
        else if (month === 0) {
          month = 12;
          year--;
        }

        updateViewModel(year, month);
        isImmediate.value === true && emitImmediately('month');
      }

      function goToYear (offset) {
        const year = Number(viewModel.value.year) + offset;
        updateViewModel(year, viewModel.value.month);
        isImmediate.value === true && emitImmediately('year');
      }

      function setYear (year) {
        updateViewModel(year, viewModel.value.month);
        view.value = props.defaultView === 'Years' ? 'Months' : 'Calendar';
        isImmediate.value === true && emitImmediately('year');
      }

      function setMonth (month) {
        updateViewModel(viewModel.value.year, month);
        view.value = 'Calendar';
        isImmediate.value === true && emitImmediately('month');
      }

      function toggleDate (date, monthHash) {
        const month = daysMap.value[ monthHash ];
        const fn = month !== void 0 && month.includes(date.day) === true
          ? removeFromModel
          : addToModel;

        fn(date);
      }

      function getShortDate (date) {
        return { year: date.year, month: date.month, day: date.day }
      }

      function updateViewModel (year, month, time) {
        if (minNav.value !== null && year <= minNav.value.year) {
          year = minNav.value.year;
          if (month < minNav.value.month) {
            month = minNav.value.month;
          }
        }

        if (maxNav.value !== null && year >= maxNav.value.year) {
          year = maxNav.value.year;
          if (month > maxNav.value.month) {
            month = maxNav.value.month;
          }
        }

        if (time !== void 0) {
          const { hour, minute, second, millisecond, timezoneOffset, timeHash } = time;
          Object.assign(viewModel.value, { hour, minute, second, millisecond, timezoneOffset, timeHash });
        }

        const newHash = year + '/' + pad(month) + '/01';

        if (newHash !== viewModel.value.dateHash) {
          monthDirection.value = (viewModel.value.dateHash < newHash) === ($q.lang.rtl !== true) ? 'left' : 'right';
          if (year !== viewModel.value.year) {
            yearDirection.value = monthDirection.value;
          }

          vue.nextTick(() => {
            startYear.value = year - year % yearsInterval - (year < 0 ? yearsInterval : 0);
            Object.assign(viewModel.value, {
              year,
              month,
              day: 1,
              dateHash: newHash
            });
          });
        }
      }

      function emitValue (val, action, date) {
        const value = val !== null && val.length === 1 && props.multiple === false
          ? val[ 0 ]
          : val;

        lastEmitValue = value;

        const { reason, details } = getEmitParams(action, date);
        emit('update:modelValue', value, reason, details);
      }

      function emitImmediately (reason) {
        const date = daysModel.value[ 0 ] !== void 0 && daysModel.value[ 0 ].dateHash !== null
          ? { ...daysModel.value[ 0 ] }
          : { ...viewModel.value }; // inherit day, hours, minutes, milliseconds...

        // nextTick required because of animation delay in viewModel
        vue.nextTick(() => {
          date.year = viewModel.value.year;
          date.month = viewModel.value.month;

          const maxDay = props.calendar !== 'persian'
            ? (new Date(date.year, date.month, 0)).getDate()
            : jalaaliMonthLength(date.year, date.month);

          date.day = Math.min(Math.max(1, date.day), maxDay);

          const value = encodeEntry(date);
          lastEmitValue = value;

          const { details } = getEmitParams('', date);
          emit('update:modelValue', value, reason, details);
        });
      }

      function getEmitParams (action, date) {
        return date.from !== void 0
          ? {
              reason: `${ action }-range`,
              details: {
                ...getShortDate(date.target),
                from: getShortDate(date.from),
                to: getShortDate(date.to)
              }
            }
          : {
              reason: `${ action }-day`,
              details: getShortDate(date)
            }
      }

      function encodeEntry (date, mask, locale) {
        return date.from !== void 0
          ? { from: encodeObjectFn.value(date.from, mask, locale), to: encodeObjectFn.value(date.to, mask, locale) }
          : encodeObjectFn.value(date, mask, locale)
      }

      function addToModel (date) {
        let value;

        if (props.multiple === true) {
          if (date.from !== void 0) {
            // we also need to filter out intersections

            const fromHash = getDayHash(date.from);
            const toHash = getDayHash(date.to);

            const days = daysModel.value
              .filter(day => day.dateHash < fromHash || day.dateHash > toHash);

            const ranges = rangeModel.value
              .filter(({ from, to }) => to.dateHash < fromHash || from.dateHash > toHash);

            value = days.concat(ranges).concat(date).map(entry => encodeEntry(entry));
          }
          else {
            const model = normalizedModel.value.slice();
            model.push(encodeEntry(date));
            value = model;
          }
        }
        else {
          value = encodeEntry(date);
        }

        emitValue(value, 'add', date);
      }

      function removeFromModel (date) {
        if (props.noUnset === true) {
          return
        }

        let model = null;

        if (props.multiple === true && Array.isArray(props.modelValue) === true) {
          const val = encodeEntry(date);

          if (date.from !== void 0) {
            model = props.modelValue.filter(
              date => (
                date.from !== void 0
                  ? (date.from !== val.from && date.to !== val.to)
                  : true
              )
            );
          }
          else {
            model = props.modelValue.filter(date => date !== val);
          }

          if (model.length === 0) {
            model = null;
          }
        }

        emitValue(model, 'remove', date);
      }

      function updateValue (mask, locale, reason) {
        const model = daysModel.value
          .concat(rangeModel.value)
          .map(entry => encodeEntry(entry, mask, locale))
          .filter(entry => {
            return entry.from !== void 0
              ? entry.from.dateHash !== null && entry.to.dateHash !== null
              : entry.dateHash !== null
          });

        emit('update:modelValue', (props.multiple === true ? model : model[ 0 ]) || null, reason);
      }

      function getHeader () {
        if (props.minimal === true) { return }

        return vue.h('div', {
          class: 'q-date__header ' + headerClass.value
        }, [
          vue.h('div', {
            class: 'relative-position'
          }, [
            vue.h(vue.Transition, {
              name: 'q-transition--fade'
            }, () => vue.h('div', {
              key: 'h-yr-' + headerSubtitle.value,
              class: 'q-date__header-subtitle q-date__header-link '
                + (view.value === 'Years' ? 'q-date__header-link--active' : 'cursor-pointer'),
              tabindex: tabindex.value,
              ...getCache('vY', {
                onClick () { view.value = 'Years'; },
                onKeyup (e) { e.keyCode === 13 && (view.value = 'Years'); }
              })
            }, [ headerSubtitle.value ]))
          ]),

          vue.h('div', {
            class: 'q-date__header-title relative-position flex no-wrap'
          }, [
            vue.h('div', {
              class: 'relative-position col'
            }, [
              vue.h(vue.Transition, {
                name: 'q-transition--fade'
              }, () => vue.h('div', {
                key: 'h-sub' + headerTitle.value,
                class: 'q-date__header-title-label q-date__header-link '
                  + (view.value === 'Calendar' ? 'q-date__header-link--active' : 'cursor-pointer'),
                tabindex: tabindex.value,
                ...getCache('vC', {
                  onClick () { view.value = 'Calendar'; },
                  onKeyup (e) { e.keyCode === 13 && (view.value = 'Calendar'); }
                })
              }, [ headerTitle.value ]))
            ]),

            props.todayBtn === true ? vue.h(QBtn, {
              class: 'q-date__header-today self-start',
              icon: $q.iconSet.datetime.today,
              flat: true,
              size: 'sm',
              round: true,
              tabindex: tabindex.value,
              onClick: setToday
            }) : null
          ])
        ])
      }

      function getNavigation ({ label, type, key, dir, goTo, boundaries, cls }) {
        return [
          vue.h('div', {
            class: 'row items-center q-date__arrow'
          }, [
            vue.h(QBtn, {
              round: true,
              dense: true,
              size: 'sm',
              flat: true,
              icon: dateArrow.value[ 0 ],
              tabindex: tabindex.value,
              disable: boundaries.prev === false,
              ...getCache('go-#' + type, { onClick () { goTo(-1); } })
            })
          ]),

          vue.h('div', {
            class: 'relative-position overflow-hidden flex flex-center' + cls
          }, [
            vue.h(vue.Transition, {
              name: 'q-transition--jump-' + dir
            }, () => vue.h('div', { key }, [
              vue.h(QBtn, {
                flat: true,
                dense: true,
                noCaps: true,
                label,
                tabindex: tabindex.value,
                ...getCache('view#' + type, { onClick: () => { view.value = type; } })
              })
            ]))
          ]),

          vue.h('div', {
            class: 'row items-center q-date__arrow'
          }, [
            vue.h(QBtn, {
              round: true,
              dense: true,
              size: 'sm',
              flat: true,
              icon: dateArrow.value[ 1 ],
              tabindex: tabindex.value,
              disable: boundaries.next === false,
              ...getCache('go+#' + type, { onClick () { goTo(1); } })
            })
          ])
        ]
      }

      const renderViews = {
        Calendar: () => ([
          vue.h('div', {
            key: 'calendar-view',
            class: 'q-date__view q-date__calendar'
          }, [
            vue.h('div', {
              class: 'q-date__navigation row items-center no-wrap'
            }, getNavigation({
              label: innerLocale.value.months[ viewModel.value.month - 1 ],
              type: 'Months',
              key: viewModel.value.month,
              dir: monthDirection.value,
              goTo: goToMonth,
              boundaries: navBoundaries.value.month,
              cls: ' col'
            }).concat(getNavigation({
              label: viewModel.value.year,
              type: 'Years',
              key: viewModel.value.year,
              dir: yearDirection.value,
              goTo: goToYear,
              boundaries: navBoundaries.value.year,
              cls: ''
            }))),

            vue.h('div', {
              class: 'q-date__calendar-weekdays row items-center no-wrap'
            }, daysOfWeek.value.map(day => vue.h('div', { class: 'q-date__calendar-item' }, [ vue.h('div', day) ]))),

            vue.h('div', {
              class: 'q-date__calendar-days-container relative-position overflow-hidden'
            }, [
              vue.h(vue.Transition, {
                name: 'q-transition--slide-' + monthDirection.value
              }, () => vue.h('div', {
                key: viewMonthHash.value,
                class: 'q-date__calendar-days fit'
              }, days.value.map(day => vue.h('div', { class: day.classes }, [
                day.in === true
                  ? vue.h(
                    QBtn, {
                      class: day.today === true ? 'q-date__today' : '',
                      dense: true,
                      flat: day.flat,
                      unelevated: day.unelevated,
                      color: day.color,
                      textColor: day.textColor,
                      label: day.i,
                      tabindex: tabindex.value,
                      ...getCache('day#' + day.i, {
                        onClick: () => { onDayClick(day.i); },
                        onMouseover: () => { onDayMouseover(day.i); }
                      })
                    },
                    day.event !== false
                      ? () => vue.h('div', { class: 'q-date__event bg-' + day.event })
                      : null
                  )
                  : vue.h('div', '' + day.i)
              ]))))
            ])
          ])
        ]),

        Months () {
          const currentYear = viewModel.value.year === today.value.year;
          const isDisabled = month => {
            return (
              (minNav.value !== null && viewModel.value.year === minNav.value.year && minNav.value.month > month)
              || (maxNav.value !== null && viewModel.value.year === maxNav.value.year && maxNav.value.month < month)
            )
          };

          const content = innerLocale.value.monthsShort.map((month, i) => {
            const active = viewModel.value.month === i + 1;

            return vue.h('div', {
              class: 'q-date__months-item flex flex-center'
            }, [
              vue.h(QBtn, {
                class: currentYear === true && today.value.month === i + 1 ? 'q-date__today' : null,
                flat: active !== true,
                label: month,
                unelevated: active,
                color: active === true ? computedColor.value : null,
                textColor: active === true ? computedTextColor.value : null,
                tabindex: tabindex.value,
                disable: isDisabled(i + 1),
                ...getCache('month#' + i, { onClick: () => { setMonth(i + 1); } })
              })
            ])
          });

          props.yearsInMonthView === true && content.unshift(
            vue.h('div', { class: 'row no-wrap full-width' }, [
              getNavigation({
                label: viewModel.value.year,
                type: 'Years',
                key: viewModel.value.year,
                dir: yearDirection.value,
                goTo: goToYear,
                boundaries: navBoundaries.value.year,
                cls: ' col'
              })
            ])
          );

          return vue.h('div', {
            key: 'months-view',
            class: 'q-date__view q-date__months flex flex-center'
          }, content)
        },

        Years () {
          const
            start = startYear.value,
            stop = start + yearsInterval,
            years = [];

          const isDisabled = year => {
            return (
              (minNav.value !== null && minNav.value.year > year)
              || (maxNav.value !== null && maxNav.value.year < year)
            )
          };

          for (let i = start; i <= stop; i++) {
            const active = viewModel.value.year === i;

            years.push(
              vue.h('div', {
                class: 'q-date__years-item flex flex-center'
              }, [
                vue.h(QBtn, {
                  key: 'yr' + i,
                  class: today.value.year === i ? 'q-date__today' : null,
                  flat: !active,
                  label: i,
                  dense: true,
                  unelevated: active,
                  color: active === true ? computedColor.value : null,
                  textColor: active === true ? computedTextColor.value : null,
                  tabindex: tabindex.value,
                  disable: isDisabled(i),
                  ...getCache('yr#' + i, { onClick: () => { setYear(i); } })
                })
              ])
            );
          }

          return vue.h('div', {
            class: 'q-date__view q-date__years flex flex-center'
          }, [
            vue.h('div', {
              class: 'col-auto'
            }, [
              vue.h(QBtn, {
                round: true,
                dense: true,
                flat: true,
                icon: dateArrow.value[ 0 ],
                tabindex: tabindex.value,
                disable: isDisabled(start),
                ...getCache('y-', { onClick: () => { startYear.value -= yearsInterval; } })
              })
            ]),

            vue.h('div', {
              class: 'q-date__years-content col self-stretch row items-center'
            }, years),

            vue.h('div', {
              class: 'col-auto'
            }, [
              vue.h(QBtn, {
                round: true,
                dense: true,
                flat: true,
                icon: dateArrow.value[ 1 ],
                tabindex: tabindex.value,
                disable: isDisabled(stop),
                ...getCache('y+', { onClick: () => { startYear.value += yearsInterval; } })
              })
            ])
          ])
        }
      };

      function onDayClick (dayIndex) {
        const day = { ...viewModel.value, day: dayIndex };

        if (props.range === false) {
          toggleDate(day, viewMonthHash.value);
          return
        }

        if (editRange.value === null) {
          const dayProps = days.value.find(day => day.fill !== true && day.i === dayIndex);

          if (props.noUnset !== true && dayProps.range !== void 0) {
            removeFromModel({ target: day, from: dayProps.range.from, to: dayProps.range.to });
            return
          }

          if (dayProps.selected === true) {
            removeFromModel(day);
            return
          }

          const initHash = getDayHash(day);

          editRange.value = {
            init: day,
            initHash,
            final: day,
            finalHash: initHash
          };

          emit('rangeStart', getShortDate(day));
        }
        else {
          const
            initHash = editRange.value.initHash,
            finalHash = getDayHash(day),
            payload = initHash <= finalHash
              ? { from: editRange.value.init, to: day }
              : { from: day, to: editRange.value.init };

          editRange.value = null;
          addToModel(initHash === finalHash ? day : { target: day, ...payload });

          emit('rangeEnd', {
            from: getShortDate(payload.from),
            to: getShortDate(payload.to)
          });
        }
      }

      function onDayMouseover (dayIndex) {
        if (editRange.value !== null) {
          const final = { ...viewModel.value, day: dayIndex };

          Object.assign(editRange.value, {
            final,
            finalHash: getDayHash(final)
          });
        }
      }

      // expose public methods
      Object.assign(proxy, {
        setToday, setView, offsetCalendar, setCalendarTo, setEditingRange
      });

      return () => {
        const content = [
          vue.h('div', {
            class: 'q-date__content col relative-position'
          }, [
            vue.h(vue.Transition, {
              name: 'q-transition--fade'
            }, renderViews[ view.value ])
          ])
        ];

        const def = hSlot(slots.default);
        def !== void 0 && content.push(
          vue.h('div', { class: 'q-date__actions' }, def)
        );

        if (props.name !== void 0 && props.disable !== true) {
          injectFormInput(content, 'push');
        }

        return vue.h('div', {
          class: classes.value,
          ...attributes.value
        }, [
          getHeader(),

          vue.h('div', {
            ref: blurTargetRef,
            class: 'q-date__main col column',
            tabindex: -1
          }, content)
        ])
      }
    }
  });

  function useHistory (showing, hide, hideOnRouteChange) {
    let historyEntry;

    function removeFromHistory () {
      if (historyEntry !== void 0) {
        History.remove(historyEntry);
        historyEntry = void 0;
      }
    }

    vue.onBeforeUnmount(() => {
      showing.value === true && removeFromHistory();
    });

    return {
      removeFromHistory,

      addToHistory () {
        historyEntry = {
          condition: () => hideOnRouteChange.value === true,
          handler: hide
        };

        History.add(historyEntry);
      }
    }
  }

  let
    registered = 0,
    scrollPositionX,
    scrollPositionY,
    maxScrollTop,
    vpPendingUpdate = false,
    bodyLeft,
    bodyTop,
    href,
    closeTimer = null;

  function onWheel (e) {
    if (shouldPreventScroll(e)) {
      stopAndPrevent(e);
    }
  }

  function shouldPreventScroll (e) {
    if (e.target === document.body || e.target.classList.contains('q-layout__backdrop')) {
      return true
    }

    const
      path = getEventPath(e),
      shift = e.shiftKey && !e.deltaX,
      scrollY = !shift && Math.abs(e.deltaX) <= Math.abs(e.deltaY),
      delta = shift || scrollY ? e.deltaY : e.deltaX;

    for (let index = 0; index < path.length; index++) {
      const el = path[ index ];

      if (hasScrollbar(el, scrollY)) {
        return scrollY
          ? (
              delta < 0 && el.scrollTop === 0
                ? true
                : delta > 0 && el.scrollTop + el.clientHeight === el.scrollHeight
            )
          : (
              delta < 0 && el.scrollLeft === 0
                ? true
                : delta > 0 && el.scrollLeft + el.clientWidth === el.scrollWidth
            )
      }
    }

    return true
  }

  function onAppleScroll (e) {
    if (e.target === document) {
      // required, otherwise iOS blocks further scrolling
      // until the mobile scrollbar dissappears
      document.scrollingElement.scrollTop = document.scrollingElement.scrollTop; // eslint-disable-line
    }
  }

  function onAppleResize (evt) {
    if (vpPendingUpdate === true) {
      return
    }

    vpPendingUpdate = true;

    requestAnimationFrame(() => {
      vpPendingUpdate = false;

      const
        { height } = evt.target,
        { clientHeight, scrollTop } = document.scrollingElement;

      if (maxScrollTop === void 0 || height !== window.innerHeight) {
        maxScrollTop = clientHeight - height;
        document.scrollingElement.scrollTop = scrollTop;
      }

      if (scrollTop > maxScrollTop) {
        document.scrollingElement.scrollTop -= Math.ceil((scrollTop - maxScrollTop) / 8);
      }
    });
  }

  function apply$1 (action) {
    const
      body = document.body,
      hasViewport = window.visualViewport !== void 0;

    if (action === 'add') {
      const { overflowY, overflowX } = window.getComputedStyle(body);

      scrollPositionX = getHorizontalScrollPosition(window);
      scrollPositionY = getVerticalScrollPosition(window);
      bodyLeft = body.style.left;
      bodyTop = body.style.top;

      href = window.location.href;

      body.style.left = `-${ scrollPositionX }px`;
      body.style.top = `-${ scrollPositionY }px`;

      if (overflowX !== 'hidden' && (overflowX === 'scroll' || body.scrollWidth > window.innerWidth)) {
        body.classList.add('q-body--force-scrollbar-x');
      }
      if (overflowY !== 'hidden' && (overflowY === 'scroll' || body.scrollHeight > window.innerHeight)) {
        body.classList.add('q-body--force-scrollbar-y');
      }

      body.classList.add('q-body--prevent-scroll');
      document.qScrollPrevented = true;

      if (client.is.ios === true) {
        if (hasViewport === true) {
          window.scrollTo(0, 0);
          window.visualViewport.addEventListener('resize', onAppleResize, listenOpts.passiveCapture);
          window.visualViewport.addEventListener('scroll', onAppleResize, listenOpts.passiveCapture);
          window.scrollTo(0, 0);
        }
        else {
          window.addEventListener('scroll', onAppleScroll, listenOpts.passiveCapture);
        }
      }
    }

    if (client.is.desktop === true && client.is.mac === true) {
      // ref. https://developers.google.com/web/updates/2017/01/scrolling-intervention
      window[ `${ action }EventListener` ]('wheel', onWheel, listenOpts.notPassive);
    }

    if (action === 'remove') {
      if (client.is.ios === true) {
        if (hasViewport === true) {
          window.visualViewport.removeEventListener('resize', onAppleResize, listenOpts.passiveCapture);
          window.visualViewport.removeEventListener('scroll', onAppleResize, listenOpts.passiveCapture);
        }
        else {
          window.removeEventListener('scroll', onAppleScroll, listenOpts.passiveCapture);
        }
      }

      body.classList.remove('q-body--prevent-scroll');
      body.classList.remove('q-body--force-scrollbar-x');
      body.classList.remove('q-body--force-scrollbar-y');

      document.qScrollPrevented = false;

      body.style.left = bodyLeft;
      body.style.top = bodyTop;

      // scroll back only if route has not changed
      if (window.location.href === href) {
        window.scrollTo(scrollPositionX, scrollPositionY);
      }

      maxScrollTop = void 0;
    }
  }

  function preventScroll (state) {
    let action = 'add';

    if (state === true) {
      registered++;

      if (closeTimer !== null) {
        clearTimeout(closeTimer);
        closeTimer = null;
        return
      }

      if (registered > 1) {
        return
      }
    }
    else {
      if (registered === 0) {
        return
      }

      registered--;

      if (registered > 0) {
        return
      }

      action = 'remove';

      if (client.is.ios === true && client.is.nativeMobile === true) {
        closeTimer !== null && clearTimeout(closeTimer);
        closeTimer = setTimeout(() => {
          apply$1(action);
          closeTimer = null;
        }, 100);
        return
      }
    }

    apply$1(action);
  }

  function usePreventScroll () {
    let currentState;

    return {
      preventBodyScroll (state) {
        if (
          state !== currentState
          && (currentState !== void 0 || state === true)
        ) {
          currentState = state;
          preventScroll(state);
        }
      }
    }
  }

  let maximizedModals = 0;

  const positionClass$1 = {
    standard: 'fixed-full flex-center',
    top: 'fixed-top justify-center',
    bottom: 'fixed-bottom justify-center',
    right: 'fixed-right items-center',
    left: 'fixed-left items-center'
  };

  const defaultTransitions = {
    standard: [ 'scale', 'scale' ],
    top: [ 'slide-down', 'slide-up' ],
    bottom: [ 'slide-up', 'slide-down' ],
    right: [ 'slide-left', 'slide-right' ],
    left: [ 'slide-right', 'slide-left' ]
  };

  var QDialog = createComponent({
    name: 'QDialog',

    inheritAttrs: false,

    props: {
      ...useModelToggleProps,
      ...useTransitionProps,

      transitionShow: String, // override useTransitionProps
      transitionHide: String, // override useTransitionProps

      persistent: Boolean,
      autoClose: Boolean,
      allowFocusOutside: Boolean,

      noEscDismiss: Boolean,
      noBackdropDismiss: Boolean,
      noRouteDismiss: Boolean,
      noRefocus: Boolean,
      noFocus: Boolean,
      noShake: Boolean,

      seamless: Boolean,

      maximized: Boolean,
      fullWidth: Boolean,
      fullHeight: Boolean,

      square: Boolean,

      position: {
        type: String,
        default: 'standard',
        validator: val => val === 'standard'
          || [ 'top', 'bottom', 'left', 'right' ].includes(val)
      }
    },

    emits: [
      ...useModelToggleEmits,
      'shake', 'click', 'escapeKey'
    ],

    setup (props, { slots, emit, attrs }) {
      const vm = vue.getCurrentInstance();

      const innerRef = vue.ref(null);
      const showing = vue.ref(false);
      const animating = vue.ref(false);

      let shakeTimeout = null, refocusTarget = null, isMaximized, avoidAutoClose;

      const hideOnRouteChange = vue.computed(() =>
        props.persistent !== true
        && props.noRouteDismiss !== true
        && props.seamless !== true
      );

      const { preventBodyScroll } = usePreventScroll();
      const { registerTimeout } = useTimeout();
      const { registerTick, removeTick } = useTick();

      const { transitionProps, transitionStyle } = useTransition(
        props,
        () => defaultTransitions[ props.position ][ 0 ],
        () => defaultTransitions[ props.position ][ 1 ]
      );

      const { showPortal, hidePortal, portalIsAccessible, renderPortal } = usePortal(
        vm, innerRef, renderPortalContent, 'dialog'
      );

      const { hide } = useModelToggle({
        showing,
        hideOnRouteChange,
        handleShow,
        handleHide,
        processOnMount: true
      });

      const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange);

      const classes = vue.computed(() =>
        'q-dialog__inner flex no-pointer-events'
        + ` q-dialog__inner--${ props.maximized === true ? 'maximized' : 'minimized' }`
        + ` q-dialog__inner--${ props.position } ${ positionClass$1[ props.position ] }`
        + (animating.value === true ? ' q-dialog__inner--animating' : '')
        + (props.fullWidth === true ? ' q-dialog__inner--fullwidth' : '')
        + (props.fullHeight === true ? ' q-dialog__inner--fullheight' : '')
        + (props.square === true ? ' q-dialog__inner--square' : '')
      );

      const useBackdrop = vue.computed(() => showing.value === true && props.seamless !== true);

      const onEvents = vue.computed(() => (
        props.autoClose === true
          ? { onClick: onAutoClose }
          : {}
      ));

      const rootClasses = vue.computed(() => [
        'q-dialog fullscreen no-pointer-events '
          + `q-dialog--${ useBackdrop.value === true ? 'modal' : 'seamless' }`,
        attrs.class
      ]);

      vue.watch(() => props.maximized, state => {
        showing.value === true && updateMaximized(state);
      });

      vue.watch(useBackdrop, val => {
        preventBodyScroll(val);

        if (val === true) {
          addFocusout(onFocusChange);
          addEscapeKey(onEscapeKey);
        }
        else {
          removeFocusout(onFocusChange);
          removeEscapeKey(onEscapeKey);
        }
      });

      function handleShow (evt) {
        addToHistory();

        refocusTarget = props.noRefocus === false && document.activeElement !== null
          ? document.activeElement
          : null;

        updateMaximized(props.maximized);
        showPortal();
        animating.value = true;

        if (props.noFocus !== true) {
          document.activeElement !== null && document.activeElement.blur();
          registerTick(focus);
        }
        else {
          removeTick();
        }

        // should removeTimeout() if this gets removed
        registerTimeout(() => {
          if (vm.proxy.$q.platform.is.ios === true) {
            if (props.seamless !== true && document.activeElement) {
              const
                { top, bottom } = document.activeElement.getBoundingClientRect(),
                { innerHeight } = window,
                height = window.visualViewport !== void 0
                  ? window.visualViewport.height
                  : innerHeight;

              if (top > 0 && bottom > height / 2) {
                document.scrollingElement.scrollTop = Math.min(
                  document.scrollingElement.scrollHeight - height,
                  bottom >= innerHeight
                    ? Infinity
                    : Math.ceil(document.scrollingElement.scrollTop + bottom - height / 2)
                );
              }

              document.activeElement.scrollIntoView();
            }

            // required in order to avoid the "double-tap needed" issue
            avoidAutoClose = true;
            innerRef.value.click();
            avoidAutoClose = false;
          }

          showPortal(true); // done showing portal
          animating.value = false;
          emit('show', evt);
        }, props.transitionDuration);
      }

      function handleHide (evt) {
        removeTick();
        removeFromHistory();
        cleanup(true);
        animating.value = true;
        hidePortal();

        if (refocusTarget !== null) {
          ((evt && evt.type.indexOf('key') === 0
            ? refocusTarget.closest('[tabindex]:not([tabindex^="-"])')
            : void 0
          ) || refocusTarget).focus();
          refocusTarget = null;
        }

        // should removeTimeout() if this gets removed
        registerTimeout(() => {
          hidePortal(true); // done hiding, now destroy
          animating.value = false;
          emit('hide', evt);
        }, props.transitionDuration);
      }

      function focus (selector) {
        addFocusFn(() => {
          let node = innerRef.value;

          if (node === null || node.contains(document.activeElement) === true) {
            return
          }

          node = (selector !== '' ? node.querySelector(selector) : null)
            || node.querySelector('[autofocus][tabindex], [data-autofocus][tabindex]')
            || node.querySelector('[autofocus] [tabindex], [data-autofocus] [tabindex]')
            || node.querySelector('[autofocus], [data-autofocus]')
            || node;
          node.focus({ preventScroll: true });
        });
      }

      function shake (focusTarget) {
        if (focusTarget && typeof focusTarget.focus === 'function') {
          focusTarget.focus({ preventScroll: true });
        }
        else {
          focus();
        }

        emit('shake');

        const node = innerRef.value;

        if (node !== null) {
          node.classList.remove('q-animate--scale');
          node.classList.add('q-animate--scale');
          shakeTimeout !== null && clearTimeout(shakeTimeout);
          shakeTimeout = setTimeout(() => {
            shakeTimeout = null;
            if (innerRef.value !== null) {
              node.classList.remove('q-animate--scale');
              // some platforms (like desktop Chrome)
              // require calling focus() again
              focus();
            }
          }, 170);
        }
      }

      function onEscapeKey () {
        if (props.seamless !== true) {
          if (props.persistent === true || props.noEscDismiss === true) {
            props.maximized !== true && props.noShake !== true && shake();
          }
          else {
            emit('escapeKey');
            hide();
          }
        }
      }

      function cleanup (hiding) {
        if (shakeTimeout !== null) {
          clearTimeout(shakeTimeout);
          shakeTimeout = null;
        }

        if (hiding === true || showing.value === true) {
          updateMaximized(false);

          if (props.seamless !== true) {
            preventBodyScroll(false);
            removeFocusout(onFocusChange);
            removeEscapeKey(onEscapeKey);
          }
        }

        if (hiding !== true) {
          refocusTarget = null;
        }
      }

      function updateMaximized (active) {
        if (active === true) {
          if (isMaximized !== true) {
            maximizedModals < 1 && document.body.classList.add('q-body--dialog');
            maximizedModals++;

            isMaximized = true;
          }
        }
        else if (isMaximized === true) {
          if (maximizedModals < 2) {
            document.body.classList.remove('q-body--dialog');
          }

          maximizedModals--;
          isMaximized = false;
        }
      }

      function onAutoClose (e) {
        if (avoidAutoClose !== true) {
          hide(e);
          emit('click', e);
        }
      }

      function onBackdropClick (e) {
        if (props.persistent !== true && props.noBackdropDismiss !== true) {
          hide(e);
        }
        else if (props.noShake !== true) {
          shake();
        }
      }

      function onFocusChange (evt) {
        // the focus is not in a vue child component
        if (
          props.allowFocusOutside !== true
          && portalIsAccessible.value === true
          && childHasFocus(innerRef.value, evt.target) !== true
        ) {
          focus('[tabindex]:not([tabindex="-1"])');
        }
      }

      Object.assign(vm.proxy, {
        // expose public methods
        focus, shake,

        // private but needed by QSelect
        __updateRefocusTarget (target) {
          refocusTarget = target || null;
        }
      });

      vue.onBeforeUnmount(cleanup);

      function renderPortalContent () {
        return vue.h('div', {
          role: 'dialog',
          'aria-modal': useBackdrop.value === true ? 'true' : 'false',
          ...attrs,
          class: rootClasses.value
        }, [
          vue.h(vue.Transition, {
            name: 'q-transition--fade',
            appear: true
          }, () => (
            useBackdrop.value === true
              ? vue.h('div', {
                class: 'q-dialog__backdrop fixed-full',
                style: transitionStyle.value,
                'aria-hidden': 'true',
                tabindex: -1,
                onClick: onBackdropClick
              })
              : null
          )),

          vue.h(
            vue.Transition,
            transitionProps.value,
            () => (
              showing.value === true
                ? vue.h('div', {
                  ref: innerRef,
                  class: classes.value,
                  style: transitionStyle.value,
                  tabindex: -1,
                  ...onEvents.value
                }, hSlot(slots.default))
                : null
            )
          )
        ])
      }

      return renderPortal
    }
  });

  const duration = 150;

  var QDrawer = createComponent({
    name: 'QDrawer',

    inheritAttrs: false,

    props: {
      ...useModelToggleProps,
      ...useDarkProps,

      side: {
        type: String,
        default: 'left',
        validator: v => [ 'left', 'right' ].includes(v)
      },

      width: {
        type: Number,
        default: 300
      },

      mini: Boolean,
      miniToOverlay: Boolean,
      miniWidth: {
        type: Number,
        default: 57
      },

      breakpoint: {
        type: Number,
        default: 1023
      },
      showIfAbove: Boolean,

      behavior: {
        type: String,
        validator: v => [ 'default', 'desktop', 'mobile' ].includes(v),
        default: 'default'
      },

      bordered: Boolean,
      elevated: Boolean,

      overlay: Boolean,
      persistent: Boolean,
      noSwipeOpen: Boolean,
      noSwipeClose: Boolean,
      noSwipeBackdrop: Boolean
    },

    emits: [
      ...useModelToggleEmits,
      'onLayout', 'miniState'
    ],

    setup (props, { slots, emit, attrs }) {
      const vm = vue.getCurrentInstance();
      const { proxy: { $q } } = vm;

      const isDark = useDark(props, $q);
      const { preventBodyScroll } = usePreventScroll();
      const { registerTimeout, removeTimeout } = useTimeout();

      const $layout = vue.inject(layoutKey, emptyRenderFn);
      if ($layout === emptyRenderFn) {
        console.error('QDrawer needs to be child of QLayout');
        return emptyRenderFn
      }

      let lastDesktopState, timerMini = null, layoutTotalWidthWatcher;

      const belowBreakpoint = vue.ref(
        props.behavior === 'mobile'
        || (props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint)
      );

      const isMini = vue.computed(() =>
        props.mini === true && belowBreakpoint.value !== true
      );

      const size = vue.computed(() => (
        isMini.value === true
          ? props.miniWidth
          : props.width
      ));

      const showing = vue.ref(
        props.showIfAbove === true && belowBreakpoint.value === false
          ? true
          : props.modelValue === true
      );

      const hideOnRouteChange = vue.computed(() =>
        props.persistent !== true
        && (belowBreakpoint.value === true || onScreenOverlay.value === true)
      );

      function handleShow (evt, noEvent) {
        addToHistory();

        evt !== false && $layout.animate();
        applyPosition(0);

        if (belowBreakpoint.value === true) {
          const otherInstance = $layout.instances[ otherSide.value ];
          if (otherInstance !== void 0 && otherInstance.belowBreakpoint === true) {
            otherInstance.hide(false);
          }

          applyBackdrop(1);
          $layout.isContainer.value !== true && preventBodyScroll(true);
        }
        else {
          applyBackdrop(0);
          evt !== false && setScrollable(false);
        }

        registerTimeout(() => {
          evt !== false && setScrollable(true);
          noEvent !== true && emit('show', evt);
        }, duration);
      }

      function handleHide (evt, noEvent) {
        removeFromHistory();

        evt !== false && $layout.animate();

        applyBackdrop(0);
        applyPosition(stateDirection.value * size.value);

        cleanup();

        if (noEvent !== true) {
          registerTimeout(() => { emit('hide', evt); }, duration);
        }
        else {
          removeTimeout();
        }
      }

      const { show, hide } = useModelToggle({
        showing,
        hideOnRouteChange,
        handleShow,
        handleHide
      });

      const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange);

      const instance = {
        belowBreakpoint,
        hide
      };

      const rightSide = vue.computed(() => props.side === 'right');

      const stateDirection = vue.computed(() =>
        ($q.lang.rtl === true ? -1 : 1) * (rightSide.value === true ? 1 : -1)
      );

      const flagBackdropBg = vue.ref(0);
      const flagPanning = vue.ref(false);
      const flagMiniAnimate = vue.ref(false);
      const flagContentPosition = vue.ref( // starting with "hidden" for SSR
        size.value * stateDirection.value
      );

      const otherSide = vue.computed(() => (rightSide.value === true ? 'left' : 'right'));
      const offset = vue.computed(() => (
        showing.value === true && belowBreakpoint.value === false && props.overlay === false
          ? (props.miniToOverlay === true ? props.miniWidth : size.value)
          : 0
      ));

      const fixed = vue.computed(() =>
        props.overlay === true
        || props.miniToOverlay === true
        || $layout.view.value.indexOf(rightSide.value ? 'R' : 'L') > -1
        || ($q.platform.is.ios === true && $layout.isContainer.value === true)
      );

      const onLayout = vue.computed(() =>
        props.overlay === false
        && showing.value === true
        && belowBreakpoint.value === false
      );

      const onScreenOverlay = vue.computed(() =>
        props.overlay === true
        && showing.value === true
        && belowBreakpoint.value === false
      );

      const backdropClass = vue.computed(() =>
        'fullscreen q-drawer__backdrop'
        + (showing.value === false && flagPanning.value === false ? ' hidden' : '')
      );

      const backdropStyle = vue.computed(() => ({
        backgroundColor: `rgba(0,0,0,${ flagBackdropBg.value * 0.4 })`
      }));

      const headerSlot = vue.computed(() => (
        rightSide.value === true
          ? $layout.rows.value.top[ 2 ] === 'r'
          : $layout.rows.value.top[ 0 ] === 'l'
      ));

      const footerSlot = vue.computed(() => (
        rightSide.value === true
          ? $layout.rows.value.bottom[ 2 ] === 'r'
          : $layout.rows.value.bottom[ 0 ] === 'l'
      ));

      const aboveStyle = vue.computed(() => {
        const css = {};

        if ($layout.header.space === true && headerSlot.value === false) {
          if (fixed.value === true) {
            css.top = `${ $layout.header.offset }px`;
          }
          else if ($layout.header.space === true) {
            css.top = `${ $layout.header.size }px`;
          }
        }

        if ($layout.footer.space === true && footerSlot.value === false) {
          if (fixed.value === true) {
            css.bottom = `${ $layout.footer.offset }px`;
          }
          else if ($layout.footer.space === true) {
            css.bottom = `${ $layout.footer.size }px`;
          }
        }

        return css
      });

      const style = vue.computed(() => {
        const style = {
          width: `${ size.value }px`,
          transform: `translateX(${ flagContentPosition.value }px)`
        };

        return belowBreakpoint.value === true
          ? style
          : Object.assign(style, aboveStyle.value)
      });

      const contentClass = vue.computed(() =>
        'q-drawer__content fit '
        + ($layout.isContainer.value !== true ? 'scroll' : 'overflow-auto')
      );

      const classes = vue.computed(() =>
        `q-drawer q-drawer--${ props.side }`
        + (flagMiniAnimate.value === true ? ' q-drawer--mini-animate' : '')
        + (props.bordered === true ? ' q-drawer--bordered' : '')
        + (isDark.value === true ? ' q-drawer--dark q-dark' : '')
        + (
          flagPanning.value === true
            ? ' no-transition'
            : (showing.value === true ? '' : ' q-layout--prevent-focus')
        )
        + (
          belowBreakpoint.value === true
            ? ' fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding'
            : ` q-drawer--${ isMini.value === true ? 'mini' : 'standard' }`
            + (fixed.value === true || onLayout.value !== true ? ' fixed' : '')
            + (props.overlay === true || props.miniToOverlay === true ? ' q-drawer--on-top' : '')
            + (headerSlot.value === true ? ' q-drawer--top-padding' : '')
        )
      );

      const openDirective = vue.computed(() => {
        // if props.noSwipeOpen !== true
        const dir = $q.lang.rtl === true ? props.side : otherSide.value;

        return [ [
          TouchPan,
          onOpenPan,
          void 0,
          {
            [ dir ]: true,
            mouse: true
          }
        ] ]
      });

      const contentCloseDirective = vue.computed(() => {
        // if belowBreakpoint.value === true && props.noSwipeClose !== true
        const dir = $q.lang.rtl === true ? otherSide.value : props.side;

        return [ [
          TouchPan,
          onClosePan,
          void 0,
          {
            [ dir ]: true,
            mouse: true
          }
        ] ]
      });

      const backdropCloseDirective = vue.computed(() => {
        // if showing.value === true && props.noSwipeBackdrop !== true
        const dir = $q.lang.rtl === true ? otherSide.value : props.side;

        return [ [
          TouchPan,
          onClosePan,
          void 0,
          {
            [ dir ]: true,
            mouse: true,
            mouseAllDir: true
          }
        ] ]
      });

      function updateBelowBreakpoint () {
        updateLocal(belowBreakpoint, (
          props.behavior === 'mobile'
          || (props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint)
        ));
      }

      vue.watch(belowBreakpoint, val => {
        if (val === true) { // from lg to xs
          lastDesktopState = showing.value;
          showing.value === true && hide(false);
        }
        else if (
          props.overlay === false
          && props.behavior !== 'mobile'
          && lastDesktopState !== false
        ) { // from xs to lg
          if (showing.value === true) {
            applyPosition(0);
            applyBackdrop(0);
            cleanup();
          }
          else {
            show(false);
          }
        }
      });

      vue.watch(() => props.side, (newSide, oldSide) => {
        if ($layout.instances[ oldSide ] === instance) {
          $layout.instances[ oldSide ] = void 0;
          $layout[ oldSide ].space = false;
          $layout[ oldSide ].offset = 0;
        }

        $layout.instances[ newSide ] = instance;
        $layout[ newSide ].size = size.value;
        $layout[ newSide ].space = onLayout.value;
        $layout[ newSide ].offset = offset.value;
      });

      vue.watch($layout.totalWidth, () => {
        if ($layout.isContainer.value === true || document.qScrollPrevented !== true) {
          updateBelowBreakpoint();
        }
      });

      vue.watch(
        () => props.behavior + props.breakpoint,
        updateBelowBreakpoint
      );

      vue.watch($layout.isContainer, val => {
        showing.value === true && preventBodyScroll(val !== true);
        val === true && updateBelowBreakpoint();
      });

      vue.watch($layout.scrollbarWidth, () => {
        applyPosition(showing.value === true ? 0 : void 0);
      });

      vue.watch(offset, val => { updateLayout('offset', val); });

      vue.watch(onLayout, val => {
        emit('onLayout', val);
        updateLayout('space', val);
      });

      vue.watch(rightSide, () => { applyPosition(); });

      vue.watch(size, val => {
        applyPosition();
        updateSizeOnLayout(props.miniToOverlay, val);
      });

      vue.watch(() => props.miniToOverlay, val => {
        updateSizeOnLayout(val, size.value);
      });

      vue.watch(() => $q.lang.rtl, () => { applyPosition(); });

      vue.watch(() => props.mini, () => {
        if (props.modelValue === true) {
          animateMini();
          $layout.animate();
        }
      });

      vue.watch(isMini, val => { emit('miniState', val); });

      function applyPosition (position) {
        if (position === void 0) {
          vue.nextTick(() => {
            position = showing.value === true ? 0 : size.value;
            applyPosition(stateDirection.value * position);
          });
        }
        else {
          if (
            $layout.isContainer.value === true
            && rightSide.value === true
            && (belowBreakpoint.value === true || Math.abs(position) === size.value)
          ) {
            position += stateDirection.value * $layout.scrollbarWidth.value;
          }

          flagContentPosition.value = position;
        }
      }

      function applyBackdrop (x) {
        flagBackdropBg.value = x;
      }

      function setScrollable (v) {
        const action = v === true
          ? 'remove'
          : ($layout.isContainer.value !== true ? 'add' : '');

        action !== '' && document.body.classList[ action ]('q-body--drawer-toggle');
      }

      function animateMini () {
        timerMini !== null && clearTimeout(timerMini);

        if (vm.proxy && vm.proxy.$el) {
          // need to speed it up and apply it immediately,
          // even faster than Vue's nextTick!
          vm.proxy.$el.classList.add('q-drawer--mini-animate');
        }

        flagMiniAnimate.value = true;
        timerMini = setTimeout(() => {
          timerMini = null;
          flagMiniAnimate.value = false;
          if (vm && vm.proxy && vm.proxy.$el) {
            vm.proxy.$el.classList.remove('q-drawer--mini-animate');
          }
        }, 150);
      }

      function onOpenPan (evt) {
        if (showing.value !== false) {
          // some browsers might capture and trigger this
          // even if Drawer has just been opened (but animation is still pending)
          return
        }

        const
          width = size.value,
          position = between(evt.distance.x, 0, width);

        if (evt.isFinal === true) {
          const opened = position >= Math.min(75, width);

          if (opened === true) {
            show();
          }
          else {
            $layout.animate();
            applyBackdrop(0);
            applyPosition(stateDirection.value * width);
          }

          flagPanning.value = false;
          return
        }

        applyPosition(
          ($q.lang.rtl === true ? rightSide.value !== true : rightSide.value)
            ? Math.max(width - position, 0)
            : Math.min(0, position - width)
        );
        applyBackdrop(
          between(position / width, 0, 1)
        );

        if (evt.isFirst === true) {
          flagPanning.value = true;
        }
      }

      function onClosePan (evt) {
        if (showing.value !== true) {
          // some browsers might capture and trigger this
          // even if Drawer has just been closed (but animation is still pending)
          return
        }

        const
          width = size.value,
          dir = evt.direction === props.side,
          position = ($q.lang.rtl === true ? dir !== true : dir)
            ? between(evt.distance.x, 0, width)
            : 0;

        if (evt.isFinal === true) {
          const opened = Math.abs(position) < Math.min(75, width);

          if (opened === true) {
            $layout.animate();
            applyBackdrop(1);
            applyPosition(0);
          }
          else {
            hide();
          }

          flagPanning.value = false;
          return
        }

        applyPosition(stateDirection.value * position);
        applyBackdrop(between(1 - position / width, 0, 1));

        if (evt.isFirst === true) {
          flagPanning.value = true;
        }
      }

      function cleanup () {
        preventBodyScroll(false);
        setScrollable(true);
      }

      function updateLayout (prop, val) {
        $layout.update(props.side, prop, val);
      }

      function updateLocal (prop, val) {
        if (prop.value !== val) {
          prop.value = val;
        }
      }

      function updateSizeOnLayout (miniToOverlay, size) {
        updateLayout('size', miniToOverlay === true ? props.miniWidth : size);
      }

      $layout.instances[ props.side ] = instance;
      updateSizeOnLayout(props.miniToOverlay, size.value);
      updateLayout('space', onLayout.value);
      updateLayout('offset', offset.value);

      if (
        props.showIfAbove === true
        && props.modelValue !== true
        && showing.value === true
        && props[ 'onUpdate:modelValue' ] !== void 0
      ) {
        emit('update:modelValue', true);
      }

      vue.onMounted(() => {
        emit('onLayout', onLayout.value);
        emit('miniState', isMini.value);

        lastDesktopState = props.showIfAbove === true;

        const fn = () => {
          const action = showing.value === true ? handleShow : handleHide;
          action(false, true);
        };

        if ($layout.totalWidth.value !== 0) {
          // make sure that all computed properties
          // have been updated before calling handleShow/handleHide()
          vue.nextTick(fn);
          return
        }

        layoutTotalWidthWatcher = vue.watch($layout.totalWidth, () => {
          layoutTotalWidthWatcher();
          layoutTotalWidthWatcher = void 0;

          if (showing.value === false && props.showIfAbove === true && belowBreakpoint.value === false) {
            show(false);
          }
          else {
            fn();
          }
        });
      });

      vue.onBeforeUnmount(() => {
        layoutTotalWidthWatcher !== void 0 && layoutTotalWidthWatcher();

        if (timerMini !== null) {
          clearTimeout(timerMini);
          timerMini = null;
        }

        showing.value === true && cleanup();

        if ($layout.instances[ props.side ] === instance) {
          $layout.instances[ props.side ] = void 0;
          updateLayout('size', 0);
          updateLayout('offset', 0);
          updateLayout('space', false);
        }
      });

      return () => {
        const child = [];

        if (belowBreakpoint.value === true) {
          props.noSwipeOpen === false && child.push(
            vue.withDirectives(
              vue.h('div', {
                key: 'open',
                class: `q-drawer__opener fixed-${ props.side }`,
                'aria-hidden': 'true'
              }),
              openDirective.value
            )
          );

          child.push(
            hDir(
              'div',
              {
                ref: 'backdrop',
                class: backdropClass.value,
                style: backdropStyle.value,
                'aria-hidden': 'true',
                onClick: hide
              },
              void 0,
              'backdrop',
              props.noSwipeBackdrop !== true && showing.value === true,
              () => backdropCloseDirective.value
            )
          );
        }

        const mini = isMini.value === true && slots.mini !== void 0;
        const content = [
          vue.h('div', {
            ...attrs,
            key: '' + mini, // required otherwise Vue will not diff correctly
            class: [
              contentClass.value,
              attrs.class
            ]
          }, mini === true
            ? slots.mini()
            : hSlot(slots.default)
          )
        ];

        if (props.elevated === true && showing.value === true) {
          content.push(
            vue.h('div', {
              class: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'
            })
          );
        }

        child.push(
          hDir(
            'aside',
            { ref: 'content', class: classes.value, style: style.value },
            content,
            'contentclose',
            props.noSwipeClose !== true && belowBreakpoint.value === true,
            () => contentCloseDirective.value
          )
        );

        return vue.h('div', { class: 'q-drawer-container' }, child)
      }
    }
  });

  function getBlockElement (el, parent) {
    if (parent && el === parent) {
      return null
    }

    const nodeName = el.nodeName.toLowerCase();

    if ([ 'div', 'li', 'ul', 'ol', 'blockquote' ].includes(nodeName) === true) {
      return el
    }

    const
      style = window.getComputedStyle
        ? window.getComputedStyle(el)
        : el.currentStyle,
      display = style.display;

    if (display === 'block' || display === 'table') {
      return el
    }

    return getBlockElement(el.parentNode)
  }

  function isChildOf (el, parent, orSame) {
    return !el || el === document.body
      ? false
      : (orSame === true && el === parent) || (parent === document ? document.body : parent).contains(el.parentNode)
  }

  function createRange (node, chars, range) {
    if (!range) {
      range = document.createRange();
      range.selectNode(node);
      range.setStart(node, 0);
    }

    if (chars.count === 0) {
      range.setEnd(node, chars.count);
    }
    else if (chars.count > 0) {
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent.length < chars.count) {
          chars.count -= node.textContent.length;
        }
        else {
          range.setEnd(node, chars.count);
          chars.count = 0;
        }
      }
      else {
        for (let lp = 0; chars.count !== 0 && lp < node.childNodes.length; lp++) {
          range = createRange(node.childNodes[ lp ], chars, range);
        }
      }
    }

    return range
  }

  const urlRegex = /^https?:\/\//;

  class Caret {
    constructor (el, eVm) {
      this.el = el;
      this.eVm = eVm;
      this._range = null;
    }

    get selection () {
      if (this.el) {
        const sel = document.getSelection();

        // only when the selection in element
        if (isChildOf(sel.anchorNode, this.el, true) && isChildOf(sel.focusNode, this.el, true)) {
          return sel
        }
      }

      return null
    }

    get hasSelection () {
      return this.selection !== null
        ? this.selection.toString().length > 0
        : false
    }

    get range () {
      const sel = this.selection;

      if (sel !== null && sel.rangeCount) {
        return sel.getRangeAt(0)
      }

      return this._range
    }

    get parent () {
      const range = this.range;

      if (range !== null) {
        const node = range.startContainer;

        return node.nodeType === document.ELEMENT_NODE
          ? node
          : node.parentNode
      }

      return null
    }

    get blockParent () {
      const parent = this.parent;

      if (parent !== null) {
        return getBlockElement(parent, this.el)
      }

      return null
    }

    save (range = this.range) {
      if (range !== null) {
        this._range = range;
      }
    }

    restore (range = this._range) {
      const
        r = document.createRange(),
        sel = document.getSelection();

      if (range !== null) {
        r.setStart(range.startContainer, range.startOffset);
        r.setEnd(range.endContainer, range.endOffset);
        sel.removeAllRanges();
        sel.addRange(r);
      }
      else {
        sel.selectAllChildren(this.el);
        sel.collapseToEnd();
      }
    }

    savePosition () {
      let charCount = -1, node;
      const
        selection = document.getSelection(),
        parentEl = this.el.parentNode;

      if (selection.focusNode && isChildOf(selection.focusNode, parentEl)) {
        node = selection.focusNode;
        charCount = selection.focusOffset;

        while (node && node !== parentEl) {
          if (node !== this.el && node.previousSibling) {
            node = node.previousSibling;
            charCount += node.textContent.length;
          }
          else {
            node = node.parentNode;
          }
        }
      }

      this.savedPos = charCount;
    }

    restorePosition (length = 0) {
      if (this.savedPos > 0 && this.savedPos < length) {
        const
          selection = window.getSelection(),
          range = createRange(this.el, { count: this.savedPos });

        if (range) {
          range.collapse(false);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    }

    hasParent (name, spanLevel) {
      const el = spanLevel
        ? this.parent
        : this.blockParent;

      return el !== null
        ? el.nodeName.toLowerCase() === name.toLowerCase()
        : false
    }

    hasParents (list, recursive, el = this.parent) {
      if (el === null) {
        return false
      }

      if (list.includes(el.nodeName.toLowerCase()) === true) {
        return true
      }

      return recursive === true
        ? this.hasParents(list, recursive, el.parentNode)
        : false
    }

    is (cmd, param) {
      if (this.selection === null) {
        return false
      }

      switch (cmd) {
        case 'formatBlock':
          return (param === 'DIV' && this.parent === this.el)
            || this.hasParent(param, param === 'PRE')
        case 'link':
          return this.hasParent('A', true)
        case 'fontSize':
          return document.queryCommandValue(cmd) === param
        case 'fontName':
          const res = document.queryCommandValue(cmd);
          return res === `"${ param }"` || res === param
        case 'fullscreen':
          return this.eVm.inFullscreen.value
        case 'viewsource':
          return this.eVm.isViewingSource.value
        case void 0:
          return false
        default:
          const state = document.queryCommandState(cmd);
          return param !== void 0 ? state === param : state
      }
    }

    getParentAttribute (attrib) {
      if (this.parent !== null) {
        return this.parent.getAttribute(attrib)
      }

      return null
    }

    can (name) {
      if (name === 'outdent') {
        return this.hasParents([ 'blockquote', 'li' ], true)
      }

      if (name === 'indent') {
        return this.hasParents([ 'li' ], true)
      }

      if (name === 'link') {
        return this.selection !== null || this.is('link')
      }
    }

    apply (cmd, param, done = noop) {
      if (cmd === 'formatBlock') {
        if ([ 'BLOCKQUOTE', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6' ].includes(param) && this.is(cmd, param)) {
          cmd = 'outdent';
          param = null;
        }

        if (param === 'PRE' && this.is(cmd, 'PRE')) {
          param = 'P';
        }
      }
      else if (cmd === 'print') {
        done();

        const win = window.open();

        win.document.write(`
        <!doctype html>
        <html>
          <head>
            <title>Print - ${ document.title }</title>
          </head>
          <body>
            <div>${ this.el.innerHTML }</div>
          </body>
        </html>
      `);
        win.print();
        win.close();

        return
      }
      else if (cmd === 'link') {
        const link = this.getParentAttribute('href');

        if (link === null) {
          const selection = this.selectWord(this.selection);
          const url = selection ? selection.toString() : '';

          if (!url.length) {
            if (!this.range || !this.range.cloneContents().querySelector('img')) {
              return
            }
          }

          this.eVm.editLinkUrl.value = urlRegex.test(url) ? url : 'https://';
          document.execCommand('createLink', false, this.eVm.editLinkUrl.value);

          this.save(selection.getRangeAt(0));
        }
        else {
          this.eVm.editLinkUrl.value = link;

          this.range.selectNodeContents(this.parent);
          this.save();
        }

        return
      }
      else if (cmd === 'fullscreen') {
        this.eVm.toggleFullscreen();
        done();

        return
      }
      else if (cmd === 'viewsource') {
        this.eVm.isViewingSource.value = this.eVm.isViewingSource.value === false;
        this.eVm.setContent(this.eVm.props.modelValue);
        done();

        return
      }

      document.execCommand(cmd, false, param);

      done();
    }

    selectWord (sel) {
      if (sel === null || sel.isCollapsed !== true || /* IE 11 */ sel.modify === void 0) {
        return sel
      }

      // Detect if selection is backwards
      const range = document.createRange();
      range.setStart(sel.anchorNode, sel.anchorOffset);
      range.setEnd(sel.focusNode, sel.focusOffset);
      const direction = range.collapsed ? [ 'backward', 'forward' ] : [ 'forward', 'backward' ];
      range.detach();

      // modify() works on the focus of the selection
      const
        endNode = sel.focusNode,
        endOffset = sel.focusOffset;
      sel.collapse(sel.anchorNode, sel.anchorOffset);
      sel.modify('move', direction[ 0 ], 'character');
      sel.modify('move', direction[ 1 ], 'word');
      sel.extend(endNode, endOffset);
      sel.modify('extend', direction[ 1 ], 'character');
      sel.modify('extend', direction[ 0 ], 'word');

      return sel
    }
  }

  var QTooltip = createComponent({
    name: 'QTooltip',

    inheritAttrs: false,

    props: {
      ...useAnchorProps,
      ...useModelToggleProps,
      ...useTransitionProps,

      maxHeight: {
        type: String,
        default: null
      },
      maxWidth: {
        type: String,
        default: null
      },

      transitionShow: {
        default: 'jump-down'
      },
      transitionHide: {
        default: 'jump-up'
      },

      anchor: {
        type: String,
        default: 'bottom middle',
        validator: validatePosition
      },
      self: {
        type: String,
        default: 'top middle',
        validator: validatePosition
      },
      offset: {
        type: Array,
        default: () => [ 14, 14 ],
        validator: validateOffset
      },

      scrollTarget: {
        default: void 0
      },

      delay: {
        type: Number,
        default: 0
      },

      hideDelay: {
        type: Number,
        default: 0
      }
    },

    emits: [
      ...useModelToggleEmits
    ],

    setup (props, { slots, emit, attrs }) {
      let unwatchPosition, observer;

      const vm = vue.getCurrentInstance();
      const { proxy: { $q } } = vm;

      const innerRef = vue.ref(null);
      const showing = vue.ref(false);

      const anchorOrigin = vue.computed(() => parsePosition(props.anchor, $q.lang.rtl));
      const selfOrigin = vue.computed(() => parsePosition(props.self, $q.lang.rtl));
      const hideOnRouteChange = vue.computed(() => props.persistent !== true);

      const { registerTick, removeTick } = useTick();
      const { registerTimeout } = useTimeout();
      const { transitionProps, transitionStyle } = useTransition(props);
      const { localScrollTarget, changeScrollEvent, unconfigureScrollTarget } = useScrollTarget(props, configureScrollTarget);

      const { anchorEl, canShow, anchorEvents } = useAnchor({ showing, configureAnchorEl });

      const { show, hide } = useModelToggle({
        showing, canShow, handleShow, handleHide,
        hideOnRouteChange,
        processOnMount: true
      });

      Object.assign(anchorEvents, { delayShow, delayHide });

      const { showPortal, hidePortal, renderPortal } = usePortal(vm, innerRef, renderPortalContent, 'tooltip');

      // if we're on mobile, let's improve the experience
      // by closing it when user taps outside of it
      if ($q.platform.is.mobile === true) {
        const clickOutsideProps = {
          anchorEl,
          innerRef,
          onClickOutside (e) {
            hide(e);

            // prevent click if it's on a dialog backdrop
            if (e.target.classList.contains('q-dialog__backdrop')) {
              stopAndPrevent(e);
            }

            return true
          }
        };

        const hasClickOutside = vue.computed(() =>
          // it doesn't has external model
          // (null is the default value)
          props.modelValue === null
          // and it's not persistent
          && props.persistent !== true
          && showing.value === true
        );

        vue.watch(hasClickOutside, val => {
          const fn = val === true ? addClickOutside : removeClickOutside;
          fn(clickOutsideProps);
        });

        vue.onBeforeUnmount(() => {
          removeClickOutside(clickOutsideProps);
        });
      }

      function handleShow (evt) {
        showPortal();

        // should removeTick() if this gets removed
        registerTick(() => {
          observer = new MutationObserver(() => updatePosition());
          observer.observe(innerRef.value, { attributes: false, childList: true, characterData: true, subtree: true });
          updatePosition();
          configureScrollTarget();
        });

        if (unwatchPosition === void 0) {
          unwatchPosition = vue.watch(
            () => $q.screen.width + '|' + $q.screen.height + '|' + props.self + '|' + props.anchor + '|' + $q.lang.rtl,
            updatePosition
          );
        }

        // should removeTimeout() if this gets removed
        registerTimeout(() => {
          showPortal(true); // done showing portal
          emit('show', evt);
        }, props.transitionDuration);
      }

      function handleHide (evt) {
        removeTick();
        hidePortal();

        anchorCleanup();

        // should removeTimeout() if this gets removed
        registerTimeout(() => {
          hidePortal(true); // done hiding, now destroy
          emit('hide', evt);
        }, props.transitionDuration);
      }

      function anchorCleanup () {
        if (observer !== void 0) {
          observer.disconnect();
          observer = void 0;
        }

        if (unwatchPosition !== void 0) {
          unwatchPosition();
          unwatchPosition = void 0;
        }

        unconfigureScrollTarget();
        cleanEvt(anchorEvents, 'tooltipTemp');
      }

      function updatePosition () {
        const el = innerRef.value;

        if (anchorEl.value === null || !el) {
          return
        }

        setPosition({
          el,
          offset: props.offset,
          anchorEl: anchorEl.value,
          anchorOrigin: anchorOrigin.value,
          selfOrigin: selfOrigin.value,
          maxHeight: props.maxHeight,
          maxWidth: props.maxWidth
        });
      }

      function delayShow (evt) {
        if ($q.platform.is.mobile === true) {
          clearSelection();
          document.body.classList.add('non-selectable');

          const target = anchorEl.value;
          const evts = [ 'touchmove', 'touchcancel', 'touchend', 'click' ]
            .map(e => ([ target, e, 'delayHide', 'passiveCapture' ]));

          addEvt(anchorEvents, 'tooltipTemp', evts);
        }

        registerTimeout(() => { show(evt); }, props.delay);
      }

      function delayHide (evt) {
        if ($q.platform.is.mobile === true) {
          cleanEvt(anchorEvents, 'tooltipTemp');
          clearSelection();
          // delay needed otherwise selection still occurs
          setTimeout(() => {
            document.body.classList.remove('non-selectable');
          }, 10);
        }

        // should removeTimeout() if this gets removed
        registerTimeout(() => { hide(evt); }, props.hideDelay);
      }

      function configureAnchorEl () {
        if (props.noParentEvent === true || anchorEl.value === null) { return }

        const evts = $q.platform.is.mobile === true
          ? [
              [ anchorEl.value, 'touchstart', 'delayShow', 'passive' ]
            ]
          : [
              [ anchorEl.value, 'mouseenter', 'delayShow', 'passive' ],
              [ anchorEl.value, 'mouseleave', 'delayHide', 'passive' ]
            ];

        addEvt(anchorEvents, 'anchor', evts);
      }

      function configureScrollTarget () {
        if (anchorEl.value !== null || props.scrollTarget !== void 0) {
          localScrollTarget.value = getScrollTarget(anchorEl.value, props.scrollTarget);
          const fn = props.noParentEvent === true
            ? updatePosition
            : hide;

          changeScrollEvent(localScrollTarget.value, fn);
        }
      }

      function getTooltipContent () {
        return showing.value === true
          ? vue.h('div', {
            ...attrs,
            ref: innerRef,
            class: [
              'q-tooltip q-tooltip--style q-position-engine no-pointer-events',
              attrs.class
            ],
            style: [
              attrs.style,
              transitionStyle.value
            ],
            role: 'tooltip'
          }, hSlot(slots.default))
          : null
      }

      function renderPortalContent () {
        return vue.h(vue.Transition, transitionProps.value, getTooltipContent)
      }

      vue.onBeforeUnmount(anchorCleanup);

      // expose public methods
      Object.assign(vm.proxy, { updatePosition });

      return renderPortal
    }
  });

  var QItem = createComponent({
    name: 'QItem',

    props: {
      ...useDarkProps,
      ...useRouterLinkProps,

      tag: {
        type: String,
        default: 'div'
      },

      active: {
        type: Boolean,
        default: null
      },

      clickable: Boolean,
      dense: Boolean,
      insetLevel: Number,

      tabindex: [ String, Number ],

      focused: Boolean,
      manualFocus: Boolean
    },

    emits: [ 'click', 'keyup' ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const isDark = useDark(props, $q);
      const { hasLink, linkAttrs, linkClass, linkTag, navigateOnClick } = useRouterLink();

      const rootRef = vue.ref(null);
      const blurTargetRef = vue.ref(null);

      const isActionable = vue.computed(() =>
        props.clickable === true
          || hasLink.value === true
          || props.tag === 'label'
      );

      const isClickable = vue.computed(() =>
        props.disable !== true && isActionable.value === true
      );

      const classes = vue.computed(() =>
        'q-item q-item-type row no-wrap'
        + (props.dense === true ? ' q-item--dense' : '')
        + (isDark.value === true ? ' q-item--dark' : '')
        + (
          hasLink.value === true && props.active === null
            ? linkClass.value
            : (
                props.active === true
                  ? ` q-item--active${ props.activeClass !== void 0 ? ` ${ props.activeClass }` : '' }`
                  : ''
              )
        )
        + (props.disable === true ? ' disabled' : '')
        + (
          isClickable.value === true
            ? ' q-item--clickable q-link cursor-pointer '
              + (props.manualFocus === true ? 'q-manual-focusable' : 'q-focusable q-hoverable')
              + (props.focused === true ? ' q-manual-focusable--focused' : '')
            : ''
        )
      );

      const style = vue.computed(() => {
        if (props.insetLevel === void 0) {
          return null
        }

        const dir = $q.lang.rtl === true ? 'Right' : 'Left';
        return {
          [ 'padding' + dir ]: (16 + props.insetLevel * 56) + 'px'
        }
      });

      function onClick (e) {
        if (isClickable.value === true) {
          if (blurTargetRef.value !== null) {
            if (e.qKeyEvent !== true && document.activeElement === rootRef.value) {
              blurTargetRef.value.focus();
            }
            else if (document.activeElement === blurTargetRef.value) {
              rootRef.value.focus();
            }
          }

          navigateOnClick(e);
        }
      }

      function onKeyup (e) {
        if (isClickable.value === true && isKeyCode(e, 13) === true) {
          stopAndPrevent(e);

          // for ripple
          e.qKeyEvent = true;

          // for click trigger
          const evt = new MouseEvent('click', e);
          evt.qKeyEvent = true;
          rootRef.value.dispatchEvent(evt);
        }

        emit('keyup', e);
      }

      function getContent () {
        const child = hUniqueSlot(slots.default, []);

        isClickable.value === true && child.unshift(
          vue.h('div', { class: 'q-focus-helper', tabindex: -1, ref: blurTargetRef })
        );

        return child
      }

      return () => {
        const data = {
          ref: rootRef,
          class: classes.value,
          style: style.value,
          role: 'listitem',
          onClick,
          onKeyup
        };

        if (isClickable.value === true) {
          data.tabindex = props.tabindex || '0';
          Object.assign(data, linkAttrs.value);
        }
        else if (isActionable.value === true) {
          data[ 'aria-disabled' ] = 'true';
        }

        return vue.h(
          linkTag.value,
          data,
          getContent()
        )
      }
    }
  });

  var QItemSection = createComponent({
    name: 'QItemSection',

    props: {
      avatar: Boolean,
      thumbnail: Boolean,
      side: Boolean,
      top: Boolean,
      noWrap: Boolean
    },

    setup (props, { slots }) {
      const classes = vue.computed(() =>
        'q-item__section column'
        + ` q-item__section--${ props.avatar === true || props.side === true || props.thumbnail === true ? 'side' : 'main' }`
        + (props.top === true ? ' q-item__section--top justify-start' : ' justify-center')
        + (props.avatar === true ? ' q-item__section--avatar' : '')
        + (props.thumbnail === true ? ' q-item__section--thumbnail' : '')
        + (props.noWrap === true ? ' q-item__section--nowrap' : '')
      );

      return () => vue.h('div', { class: classes.value }, hSlot(slots.default))
    }
  });

  function run (e, btn, eVm) {
    if (btn.handler) {
      btn.handler(e, eVm, eVm.caret);
    }
    else {
      eVm.runCmd(btn.cmd, btn.param);
    }
  }

  function getGroup (children) {
    return vue.h('div', { class: 'q-editor__toolbar-group' }, children)
  }

  function getBtn (eVm, btn, clickHandler, active = false) {
    const
      toggled = active || (btn.type === 'toggle'
        ? (btn.toggled ? btn.toggled(eVm) : btn.cmd && eVm.caret.is(btn.cmd, btn.param))
        : false),
      child = [];

    if (btn.tip && eVm.$q.platform.is.desktop) {
      const Key = btn.key
        ? vue.h('div', [
          vue.h('small', `(CTRL + ${ String.fromCharCode(btn.key) })`)
        ])
        : null;
      child.push(
        vue.h(QTooltip, { delay: 1000 }, () => [
          vue.h('div', { innerHTML: btn.tip }),
          Key
        ])
      );
    }

    return vue.h(QBtn, {
      ...eVm.buttonProps.value,
      icon: btn.icon !== null ? btn.icon : void 0,
      color: toggled ? btn.toggleColor || eVm.props.toolbarToggleColor : btn.color || eVm.props.toolbarColor,
      textColor: toggled && !eVm.props.toolbarPush ? null : btn.textColor || eVm.props.toolbarTextColor,
      label: btn.label,
      disable: btn.disable ? (typeof btn.disable === 'function' ? btn.disable(eVm) : true) : false,
      size: 'sm',
      onClick (e) {
        clickHandler && clickHandler();
        run(e, btn, eVm);
      }
    }, () => child)
  }

  function getDropdown (eVm, btn) {
    const onlyIcons = btn.list === 'only-icons';
    let
      label = btn.label,
      icon = btn.icon !== null ? btn.icon : void 0,
      contentClass,
      Items;

    function closeDropdown () {
      Dropdown.component.proxy.hide();
    }

    if (onlyIcons) {
      Items = btn.options.map(btn => {
        const active = btn.type === void 0
          ? eVm.caret.is(btn.cmd, btn.param)
          : false;

        if (active) {
          label = btn.tip;
          icon = btn.icon !== null ? btn.icon : void 0;
        }
        return getBtn(eVm, btn, closeDropdown, active)
      });
      contentClass = eVm.toolbarBackgroundClass.value;
      Items = [
        getGroup(Items)
      ];
    }
    else {
      const activeClass = eVm.props.toolbarToggleColor !== void 0
        ? `text-${ eVm.props.toolbarToggleColor }`
        : null;
      const inactiveClass = eVm.props.toolbarTextColor !== void 0
        ? `text-${ eVm.props.toolbarTextColor }`
        : null;

      const noIcons = btn.list === 'no-icons';

      Items = btn.options.map(btn => {
        const disable = btn.disable ? btn.disable(eVm) : false;
        const active = btn.type === void 0
          ? eVm.caret.is(btn.cmd, btn.param)
          : false;

        if (active) {
          label = btn.tip;
          icon = btn.icon !== null ? btn.icon : void 0;
        }

        const htmlTip = btn.htmlTip;

        return vue.h(QItem, {
          active,
          activeClass,
          clickable: true,
          disable,
          dense: true,
          onClick (e) {
            closeDropdown();
            eVm.contentRef.value !== null && eVm.contentRef.value.focus();
            eVm.caret.restore();
            run(e, btn, eVm);
          }
        }, () => [
          noIcons === true
            ? null
            : vue.h(
              QItemSection,
              {
                class: active ? activeClass : inactiveClass,
                side: true
              },
              () => vue.h(QIcon, { name: btn.icon !== null ? btn.icon : void 0 })
            ),

          vue.h(
            QItemSection,
            htmlTip
              ? () => vue.h('div', { class: 'text-no-wrap', innerHTML: btn.htmlTip })
              : (btn.tip ? () => vue.h('div', { class: 'text-no-wrap' }, btn.tip) : void 0)
          )
        ])
      });
      contentClass = [ eVm.toolbarBackgroundClass.value, inactiveClass ];
    }

    const highlight = btn.highlight && label !== btn.label;
    const Dropdown = vue.h(QBtnDropdown, {
      ...eVm.buttonProps.value,
      noCaps: true,
      noWrap: true,
      color: highlight ? eVm.props.toolbarToggleColor : eVm.props.toolbarColor,
      textColor: highlight && !eVm.props.toolbarPush ? null : eVm.props.toolbarTextColor,
      label: btn.fixedLabel ? btn.label : label,
      icon: btn.fixedIcon ? (btn.icon !== null ? btn.icon : void 0) : icon,
      contentClass,
      onShow: evt => eVm.emit('dropdownShow', evt),
      onHide: evt => eVm.emit('dropdownHide', evt),
      onBeforeShow: evt => eVm.emit('dropdownBeforeShow', evt),
      onBeforeHide: evt => eVm.emit('dropdownBeforeHide', evt)
    }, () => Items);

    return Dropdown
  }

  function getToolbar (eVm) {
    if (eVm.caret) {
      return eVm.buttons.value
        .filter(f => {
          return !eVm.isViewingSource.value || f.find(fb => fb.cmd === 'viewsource')
        })
        .map(group => getGroup(
          group.map(btn => {
            if (eVm.isViewingSource.value && btn.cmd !== 'viewsource') {
              return false
            }

            if (btn.type === 'slot') {
              return hSlot(eVm.slots[ btn.slot ])
            }

            if (btn.type === 'dropdown') {
              return getDropdown(eVm, btn)
            }

            return getBtn(eVm, btn)
          })
        ))
    }
  }

  function getFonts (defaultFont, defaultFontLabel, defaultFontIcon, fonts = {}) {
    const aliases = Object.keys(fonts);
    if (aliases.length === 0) {
      return {}
    }

    const def = {
      default_font: {
        cmd: 'fontName',
        param: defaultFont,
        icon: defaultFontIcon,
        tip: defaultFontLabel
      }
    };

    aliases.forEach(alias => {
      const name = fonts[ alias ];
      def[ alias ] = {
        cmd: 'fontName',
        param: name,
        icon: defaultFontIcon,
        tip: name,
        htmlTip: `<font face="${ name }">${ name }</font>`
      };
    });

    return def
  }

  function getLinkEditor (eVm) {
    if (eVm.caret) {
      const color = eVm.props.toolbarColor || eVm.props.toolbarTextColor;
      let link = eVm.editLinkUrl.value;
      const updateLink = () => {
        eVm.caret.restore();

        if (link !== eVm.editLinkUrl.value) {
          document.execCommand('createLink', false, link === '' ? ' ' : link);
        }

        eVm.editLinkUrl.value = null;
      };

      return [
        vue.h('div', { class: `q-mx-xs text-${ color }` }, `${ eVm.$q.lang.editor.url }: `),
        vue.h('input', {
          key: 'qedt_btm_input',
          class: 'col q-editor__link-input',
          value: link,
          onInput: evt => {
            stop(evt);
            link = evt.target.value;
          },
          onKeydown: evt => {
            if (shouldIgnoreKey(evt) === true) {
              return
            }

            switch (evt.keyCode) {
              case 13: // ENTER key
                prevent(evt);
                return updateLink()
              case 27: // ESCAPE key
                prevent(evt);
                eVm.caret.restore();
                if (!eVm.editLinkUrl.value || eVm.editLinkUrl.value === 'https://') {
                  document.execCommand('unlink');
                }
                eVm.editLinkUrl.value = null;
                break
            }
          }
        }),
        getGroup([
          vue.h(QBtn, {
            key: 'qedt_btm_rem',
            tabindex: -1,
            ...eVm.buttonProps.value,
            label: eVm.$q.lang.label.remove,
            noCaps: true,
            onClick: () => {
              eVm.caret.restore();
              document.execCommand('unlink');
              eVm.editLinkUrl.value = null;
            }
          }),
          vue.h(QBtn, {
            key: 'qedt_btm_upd',
            ...eVm.buttonProps.value,
            label: eVm.$q.lang.label.update,
            noCaps: true,
            onClick: updateLink
          })
        ])
      ]
    }
  }

  const listenerRE = /^on[A-Z]/;

  function useSplitAttrs (attrs, vnode) {
    const acc = {
      listeners: vue.ref({}),
      attributes: vue.ref({})
    };

    function update () {
      const attributes = {};
      const listeners = {};

      for (const key in attrs) {
        if (key !== 'class' && key !== 'style' && listenerRE.test(key) === false) {
          attributes[ key ] = attrs[ key ];
        }
      }

      for (const key in vnode.props) {
        if (listenerRE.test(key) === true) {
          listeners[ key ] = vnode.props[ key ];
        }
      }

      acc.attributes.value = attributes;
      acc.listeners.value = listeners;
    }

    vue.onBeforeUpdate(update);

    update();

    return acc
  }

  const
    toString = Object.prototype.toString,
    hasOwn = Object.prototype.hasOwnProperty,
    notPlainObject = new Set(
      [ 'Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp' ]
        .map(name => '[object ' + name + ']')
    );

  function isPlainObject (obj) {
    if (obj !== Object(obj) || notPlainObject.has(toString.call(obj)) === true) {
      return false
    }

    if (
      obj.constructor
      && hasOwn.call(obj, 'constructor') === false
      && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf') === false
    ) {
      return false
    }

    let key;
    for (key in obj) {} // eslint-disable-line

    return key === void 0 || hasOwn.call(obj, key)
  }

  function extend () {
    let
      options, name, src, copy, copyIsArray, clone,
      target = arguments[ 0 ] || {},
      i = 1,
      deep = false;
    const length = arguments.length;

    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[ 1 ] || {};
      i = 2;
    }

    if (Object(target) !== target && typeof target !== 'function') {
      target = {};
    }

    if (length === i) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      if ((options = arguments[ i ]) !== null) {
        for (name in options) {
          src = target[ name ];
          copy = options[ name ];

          if (target === copy) {
            continue
          }

          if (
            deep === true
            && copy
            && ((copyIsArray = Array.isArray(copy)) || isPlainObject(copy) === true)
          ) {
            if (copyIsArray === true) {
              clone = Array.isArray(src) === true ? src : [];
            }
            else {
              clone = isPlainObject(src) === true ? src : {};
            }

            target[ name ] = extend(deep, clone, copy);
          }
          else if (copy !== void 0) {
            target[ name ] = copy;
          }
        }
      }
    }

    return target
  }

  var QEditor = createComponent({
    name: 'QEditor',

    props: {
      ...useDarkProps,
      ...useFullscreenProps,

      modelValue: {
        type: String,
        required: true
      },
      readonly: Boolean,
      disable: Boolean,
      minHeight: {
        type: String,
        default: '10rem'
      },
      maxHeight: String,
      height: String,
      definitions: Object,
      fonts: Object,
      placeholder: String,

      toolbar: {
        type: Array,
        validator: v => v.length === 0 || v.every(group => group.length),
        default () {
          return [
            [ 'left', 'center', 'right', 'justify' ],
            [ 'bold', 'italic', 'underline', 'strike' ],
            [ 'undo', 'redo' ]
          ]
        }
      },
      toolbarColor: String,
      toolbarBg: String,
      toolbarTextColor: String,
      toolbarToggleColor: {
        type: String,
        default: 'primary'
      },
      toolbarOutline: Boolean,
      toolbarPush: Boolean,
      toolbarRounded: Boolean,

      paragraphTag: {
        type: String,
        validator: v => [ 'div', 'p' ].includes(v),
        default: 'div'
      },

      contentStyle: Object,
      contentClass: [ Object, Array, String ],

      square: Boolean,
      flat: Boolean,
      dense: Boolean
    },

    emits: [
      ...useFullscreenEmits,
      'update:modelValue',
      'keydown', 'click', 'mouseup', 'keyup', 'touchend',
      'focus', 'blur',
      'dropdownShow',
      'dropdownHide',
      'dropdownBeforeShow',
      'dropdownBeforeHide',
      'linkShow',
      'linkHide'
    ],

    setup (props, { slots, emit, attrs }) {
      const { proxy, vnode } = vue.getCurrentInstance();
      const { $q } = proxy;

      const isDark = useDark(props, $q);
      const { inFullscreen, toggleFullscreen } = useFullscreen();
      const splitAttrs = useSplitAttrs(attrs, vnode);

      const rootRef = vue.ref(null);
      const contentRef = vue.ref(null);

      const editLinkUrl = vue.ref(null);
      const isViewingSource = vue.ref(false);

      const editable = vue.computed(() => !props.readonly && !props.disable);

      let defaultFont, offsetBottom;
      let lastEmit = props.modelValue; // eslint-disable-line

      {
        document.execCommand('defaultParagraphSeparator', false, props.paragraphTag);
        defaultFont = window.getComputedStyle(document.body).fontFamily;
      }

      const toolbarBackgroundClass = vue.computed(() => (
        props.toolbarBg ? ` bg-${ props.toolbarBg }` : ''
      ));

      const buttonProps = vue.computed(() => {
        const flat = props.toolbarOutline !== true
          && props.toolbarPush !== true;

        return {
          type: 'a',
          flat,
          noWrap: true,
          outline: props.toolbarOutline,
          push: props.toolbarPush,
          rounded: props.toolbarRounded,
          dense: true,
          color: props.toolbarColor,
          disable: !editable.value,
          size: 'sm'
        }
      });

      const buttonDef = vue.computed(() => {
        const
          e = $q.lang.editor,
          i = $q.iconSet.editor;

        return {
          bold: { cmd: 'bold', icon: i.bold, tip: e.bold, key: 66 },
          italic: { cmd: 'italic', icon: i.italic, tip: e.italic, key: 73 },
          strike: { cmd: 'strikeThrough', icon: i.strikethrough, tip: e.strikethrough, key: 83 },
          underline: { cmd: 'underline', icon: i.underline, tip: e.underline, key: 85 },
          unordered: { cmd: 'insertUnorderedList', icon: i.unorderedList, tip: e.unorderedList },
          ordered: { cmd: 'insertOrderedList', icon: i.orderedList, tip: e.orderedList },
          subscript: { cmd: 'subscript', icon: i.subscript, tip: e.subscript, htmlTip: 'x<subscript>2</subscript>' },
          superscript: { cmd: 'superscript', icon: i.superscript, tip: e.superscript, htmlTip: 'x<superscript>2</superscript>' },
          link: { cmd: 'link', disable: eVm => eVm.caret && !eVm.caret.can('link'), icon: i.hyperlink, tip: e.hyperlink, key: 76 },
          fullscreen: { cmd: 'fullscreen', icon: i.toggleFullscreen, tip: e.toggleFullscreen, key: 70 },
          viewsource: { cmd: 'viewsource', icon: i.viewSource, tip: e.viewSource },

          quote: { cmd: 'formatBlock', param: 'BLOCKQUOTE', icon: i.quote, tip: e.quote, key: 81 },
          left: { cmd: 'justifyLeft', icon: i.left, tip: e.left },
          center: { cmd: 'justifyCenter', icon: i.center, tip: e.center },
          right: { cmd: 'justifyRight', icon: i.right, tip: e.right },
          justify: { cmd: 'justifyFull', icon: i.justify, tip: e.justify },

          print: { type: 'no-state', cmd: 'print', icon: i.print, tip: e.print, key: 80 },
          outdent: { type: 'no-state', disable: eVm => eVm.caret && !eVm.caret.can('outdent'), cmd: 'outdent', icon: i.outdent, tip: e.outdent },
          indent: { type: 'no-state', disable: eVm => eVm.caret && !eVm.caret.can('indent'), cmd: 'indent', icon: i.indent, tip: e.indent },
          removeFormat: { type: 'no-state', cmd: 'removeFormat', icon: i.removeFormat, tip: e.removeFormat },
          hr: { type: 'no-state', cmd: 'insertHorizontalRule', icon: i.hr, tip: e.hr },
          undo: { type: 'no-state', cmd: 'undo', icon: i.undo, tip: e.undo, key: 90 },
          redo: { type: 'no-state', cmd: 'redo', icon: i.redo, tip: e.redo, key: 89 },

          h1: { cmd: 'formatBlock', param: 'H1', icon: i.heading1 || i.heading, tip: e.heading1, htmlTip: `<h1 class="q-ma-none">${ e.heading1 }</h1>` },
          h2: { cmd: 'formatBlock', param: 'H2', icon: i.heading2 || i.heading, tip: e.heading2, htmlTip: `<h2 class="q-ma-none">${ e.heading2 }</h2>` },
          h3: { cmd: 'formatBlock', param: 'H3', icon: i.heading3 || i.heading, tip: e.heading3, htmlTip: `<h3 class="q-ma-none">${ e.heading3 }</h3>` },
          h4: { cmd: 'formatBlock', param: 'H4', icon: i.heading4 || i.heading, tip: e.heading4, htmlTip: `<h4 class="q-ma-none">${ e.heading4 }</h4>` },
          h5: { cmd: 'formatBlock', param: 'H5', icon: i.heading5 || i.heading, tip: e.heading5, htmlTip: `<h5 class="q-ma-none">${ e.heading5 }</h5>` },
          h6: { cmd: 'formatBlock', param: 'H6', icon: i.heading6 || i.heading, tip: e.heading6, htmlTip: `<h6 class="q-ma-none">${ e.heading6 }</h6>` },
          p: { cmd: 'formatBlock', param: props.paragraphTag, icon: i.heading, tip: e.paragraph },
          code: { cmd: 'formatBlock', param: 'PRE', icon: i.code, htmlTip: `<code>${ e.code }</code>` },

          'size-1': { cmd: 'fontSize', param: '1', icon: i.size1 || i.size, tip: e.size1, htmlTip: `<font size="1">${ e.size1 }</font>` },
          'size-2': { cmd: 'fontSize', param: '2', icon: i.size2 || i.size, tip: e.size2, htmlTip: `<font size="2">${ e.size2 }</font>` },
          'size-3': { cmd: 'fontSize', param: '3', icon: i.size3 || i.size, tip: e.size3, htmlTip: `<font size="3">${ e.size3 }</font>` },
          'size-4': { cmd: 'fontSize', param: '4', icon: i.size4 || i.size, tip: e.size4, htmlTip: `<font size="4">${ e.size4 }</font>` },
          'size-5': { cmd: 'fontSize', param: '5', icon: i.size5 || i.size, tip: e.size5, htmlTip: `<font size="5">${ e.size5 }</font>` },
          'size-6': { cmd: 'fontSize', param: '6', icon: i.size6 || i.size, tip: e.size6, htmlTip: `<font size="6">${ e.size6 }</font>` },
          'size-7': { cmd: 'fontSize', param: '7', icon: i.size7 || i.size, tip: e.size7, htmlTip: `<font size="7">${ e.size7 }</font>` }
        }
      });

      const buttons = vue.computed(() => {
        const userDef = props.definitions || {};
        const def = props.definitions || props.fonts
          ? extend(
            true,
            {},
            buttonDef.value,
            userDef,
            getFonts(
              defaultFont,
              $q.lang.editor.defaultFont,
              $q.iconSet.editor.font,
              props.fonts
            )
          )
          : buttonDef.value;

        return props.toolbar.map(
          group => group.map(token => {
            if (token.options) {
              return {
                type: 'dropdown',
                icon: token.icon,
                label: token.label,
                size: 'sm',
                dense: true,
                fixedLabel: token.fixedLabel,
                fixedIcon: token.fixedIcon,
                highlight: token.highlight,
                list: token.list,
                options: token.options.map(item => def[ item ])
              }
            }

            const obj = def[ token ];

            if (obj) {
              return obj.type === 'no-state' || (userDef[ token ] && (
                obj.cmd === void 0 || (buttonDef.value[ obj.cmd ] && buttonDef.value[ obj.cmd ].type === 'no-state')
              ))
                ? obj
                : Object.assign({ type: 'toggle' }, obj)
            }
            else {
              return {
                type: 'slot',
                slot: token
              }
            }
          })
        )
      });

      const eVm = {
        $q,
        props,
        slots,
        emit,
        // caret (will get injected after mount)
        inFullscreen,
        toggleFullscreen,
        runCmd,
        isViewingSource,
        editLinkUrl,
        toolbarBackgroundClass,
        buttonProps,
        contentRef,
        buttons,
        setContent
      };

      vue.watch(() => props.modelValue, v => {
        if (lastEmit !== v) {
          lastEmit = v;
          setContent(v, true);
        }
      });

      vue.watch(editLinkUrl, v => {
        emit(`link-${ v ? 'Show' : 'Hide' }`);
      });

      const hasToolbar = vue.computed(() => props.toolbar && props.toolbar.length > 0);

      const keys = vue.computed(() => {
        const
          k = {},
          add = btn => {
            if (btn.key) {
              k[ btn.key ] = {
                cmd: btn.cmd,
                param: btn.param
              };
            }
          };

        buttons.value.forEach(group => {
          group.forEach(token => {
            if (token.options) {
              token.options.forEach(add);
            }
            else {
              add(token);
            }
          });
        });
        return k
      });

      const innerStyle = vue.computed(() => (
        inFullscreen.value
          ? props.contentStyle
          : [
              {
                minHeight: props.minHeight,
                height: props.height,
                maxHeight: props.maxHeight
              },
              props.contentStyle
            ]
      ));

      const classes = vue.computed(() =>
        `q-editor q-editor--${ isViewingSource.value === true ? 'source' : 'default' }`
        + (props.disable === true ? ' disabled' : '')
        + (inFullscreen.value === true ? ' fullscreen column' : '')
        + (props.square === true ? ' q-editor--square no-border-radius' : '')
        + (props.flat === true ? ' q-editor--flat' : '')
        + (props.dense === true ? ' q-editor--dense' : '')
        + (isDark.value === true ? ' q-editor--dark q-dark' : '')
      );

      const innerClass = vue.computed(() => ([
        props.contentClass,
        'q-editor__content',
        { col: inFullscreen.value, 'overflow-auto': inFullscreen.value || props.maxHeight }
      ]));

      const attributes = vue.computed(() => (
        props.disable === true
          ? { 'aria-disabled': 'true' }
          : (props.readonly === true ? { 'aria-readonly': 'true' } : {})
      ));

      function onInput () {
        if (contentRef.value !== null) {
          const prop = `inner${ isViewingSource.value === true ? 'Text' : 'HTML' }`;
          const val = contentRef.value[ prop ];

          if (val !== props.modelValue) {
            lastEmit = val;
            emit('update:modelValue', val);
          }
        }
      }

      function onKeydown (e) {
        emit('keydown', e);

        if (e.ctrlKey !== true || shouldIgnoreKey(e) === true) {
          refreshToolbar();
          return
        }

        const key = e.keyCode;
        const target = keys.value[ key ];
        if (target !== void 0) {
          const { cmd, param } = target;
          stopAndPrevent(e);
          runCmd(cmd, param, false);
        }
      }

      function onClick (e) {
        refreshToolbar();
        emit('click', e);
      }

      function onBlur (e) {
        if (contentRef.value !== null) {
          const { scrollTop, scrollHeight } = contentRef.value;
          offsetBottom = scrollHeight - scrollTop;
        }
        eVm.caret.save();
        emit('blur', e);
      }

      function onFocus (e) {
        vue.nextTick(() => {
          if (contentRef.value !== null && offsetBottom !== void 0) {
            contentRef.value.scrollTop = contentRef.value.scrollHeight - offsetBottom;
          }
        });
        emit('focus', e);
      }

      function onFocusin (e) {
        const root = rootRef.value;

        if (
          root !== null
          && root.contains(e.target) === true
          && (
            e.relatedTarget === null
            || root.contains(e.relatedTarget) !== true
          )
        ) {
          const prop = `inner${ isViewingSource.value === true ? 'Text' : 'HTML' }`;
          eVm.caret.restorePosition(contentRef.value[ prop ].length);
          refreshToolbar();
        }
      }

      function onFocusout (e) {
        const root = rootRef.value;

        if (
          root !== null
          && root.contains(e.target) === true
          && (
            e.relatedTarget === null
            || root.contains(e.relatedTarget) !== true
          )
        ) {
          eVm.caret.savePosition();
          refreshToolbar();
        }
      }

      function onPointerStart () {
        offsetBottom = void 0;
      }

      function onSelectionchange (e) {
        eVm.caret.save();
      }

      function setContent (v, restorePosition) {
        if (contentRef.value !== null) {
          if (restorePosition === true) {
            eVm.caret.savePosition();
          }

          const prop = `inner${ isViewingSource.value === true ? 'Text' : 'HTML' }`;
          contentRef.value[ prop ] = v;

          if (restorePosition === true) {
            eVm.caret.restorePosition(contentRef.value[ prop ].length);
            refreshToolbar();
          }
        }
      }

      function runCmd (cmd, param, update = true) {
        focus();
        eVm.caret.restore();
        eVm.caret.apply(cmd, param, () => {
          focus();
          eVm.caret.save();
          if (update) {
            refreshToolbar();
          }
        });
      }

      function refreshToolbar () {
        setTimeout(() => {
          editLinkUrl.value = null;
          proxy.$forceUpdate();
        }, 1);
      }

      function focus () {
        addFocusFn(() => {
          contentRef.value !== null && contentRef.value.focus({ preventScroll: true });
        });
      }

      function getContentEl () {
        return contentRef.value
      }

      vue.onMounted(() => {
        eVm.caret = proxy.caret = new Caret(contentRef.value, eVm);
        setContent(props.modelValue);
        refreshToolbar();

        document.addEventListener('selectionchange', onSelectionchange);
      });

      vue.onBeforeUnmount(() => {
        document.removeEventListener('selectionchange', onSelectionchange);
      });

      // expose public methods
      Object.assign(proxy, {
        runCmd, refreshToolbar, focus, getContentEl
      });

      return () => {
        let toolbars;

        if (hasToolbar.value) {
          const bars = [
            vue.h('div', {
              key: 'qedt_top',
              class: 'q-editor__toolbar row no-wrap scroll-x'
                + toolbarBackgroundClass.value
            }, getToolbar(eVm))
          ];

          editLinkUrl.value !== null && bars.push(
            vue.h('div', {
              key: 'qedt_btm',
              class: 'q-editor__toolbar row no-wrap items-center scroll-x'
                + toolbarBackgroundClass.value
            }, getLinkEditor(eVm))
          );

          toolbars = vue.h('div', {
            key: 'toolbar_ctainer',
            class: 'q-editor__toolbars-container'
          }, bars);
        }

        return vue.h('div', {
          ref: rootRef,
          class: classes.value,
          style: { height: inFullscreen.value === true ? '100%' : null },
          ...attributes.value,
          onFocusin,
          onFocusout
        }, [
          toolbars,

          vue.h('div', {
            ref: contentRef,
            style: innerStyle.value,
            class: innerClass.value,
            contenteditable: editable.value,
            placeholder: props.placeholder,
            ...({}),
            ...splitAttrs.listeners.value,
            onInput,
            onKeydown,
            onClick,
            onBlur,
            onFocus,

            // clean saved scroll position
            onMousedown: onPointerStart,
            onTouchstartPassive: onPointerStart
          })
        ])
      }
    }
  });

  var QItemLabel = createComponent({
    name: 'QItemLabel',

    props: {
      overline: Boolean,
      caption: Boolean,
      header: Boolean,
      lines: [ Number, String ]
    },

    setup (props, { slots }) {
      const parsedLines = vue.computed(() => parseInt(props.lines, 10));

      const classes = vue.computed(() =>
        'q-item__label'
        + (props.overline === true ? ' q-item__label--overline text-overline' : '')
        + (props.caption === true ? ' q-item__label--caption text-caption' : '')
        + (props.header === true ? ' q-item__label--header' : '')
        + (parsedLines.value === 1 ? ' ellipsis' : '')
      );

      const style = vue.computed(() => {
        return props.lines !== void 0 && parsedLines.value > 1
          ? {
              overflow: 'hidden',
              display: '-webkit-box',
              '-webkit-box-orient': 'vertical',
              '-webkit-line-clamp': parsedLines.value
            }
          : null
      });

      return () => vue.h('div', {
        style: style.value,
        class: classes.value
      }, hSlot(slots.default))
    }
  });

  var QSlideTransition = createComponent({
    name: 'QSlideTransition',

    props: {
      appear: Boolean,
      duration: {
        type: Number,
        default: 300
      }
    },

    emits: [ 'show', 'hide' ],

    setup (props, { slots, emit }) {
      let animating = false, doneFn, element;
      let timer = null, timerFallback = null, animListener, lastEvent;

      function cleanup () {
        doneFn && doneFn();
        doneFn = null;
        animating = false;

        if (timer !== null) {
          clearTimeout(timer);
          timer = null;
        }

        if (timerFallback !== null) {
          clearTimeout(timerFallback);
          timerFallback = null;
        }

        element !== void 0 && element.removeEventListener('transitionend', animListener);
        animListener = null;
      }

      function begin (el, height, done) {
        // here overflowY is 'hidden'
        if (height !== void 0) {
          el.style.height = `${ height }px`;
        }
        el.style.transition = `height ${ props.duration }ms cubic-bezier(.25, .8, .50, 1)`;

        animating = true;
        doneFn = done;
      }

      function end (el, event) {
        el.style.overflowY = null;
        el.style.height = null;
        el.style.transition = null;
        cleanup();
        event !== lastEvent && emit(event);
      }

      function onEnter (el, done) {
        let pos = 0;
        element = el;

        // if animationg overflowY is already 'hidden'
        if (animating === true) {
          cleanup();
          pos = el.offsetHeight === el.scrollHeight ? 0 : void 0;
        }
        else {
          lastEvent = 'hide';
          el.style.overflowY = 'hidden';
        }

        begin(el, pos, done);

        timer = setTimeout(() => {
          timer = null;
          el.style.height = `${ el.scrollHeight }px`;
          animListener = evt => {
            timerFallback = null;

            if (Object(evt) !== evt || evt.target === el) {
              end(el, 'show');
            }
          };
          el.addEventListener('transitionend', animListener);
          timerFallback = setTimeout(animListener, props.duration * 1.1);
        }, 100);
      }

      function onLeave (el, done) {
        let pos;
        element = el;

        if (animating === true) {
          cleanup();
        }
        else {
          lastEvent = 'show';
          // we need to set overflowY 'hidden' before calculating the height
          // or else we get small differences
          el.style.overflowY = 'hidden';
          pos = el.scrollHeight;
        }

        begin(el, pos, done);

        timer = setTimeout(() => {
          timer = null;
          el.style.height = 0;
          animListener = evt => {
            timerFallback = null;

            if (Object(evt) !== evt || evt.target === el) {
              end(el, 'hide');
            }
          };
          el.addEventListener('transitionend', animListener);
          timerFallback = setTimeout(animListener, props.duration * 1.1);
        }, 100);
      }

      vue.onBeforeUnmount(() => {
        animating === true && cleanup();
      });

      return () => vue.h(vue.Transition, {
        css: false,
        appear: props.appear,
        onEnter,
        onLeave
      }, slots.default)
    }
  });

  const insetMap = {
    true: 'inset',
    item: 'item-inset',
    'item-thumbnail': 'item-thumbnail-inset'
  };

  const margins = {
    xs: 2,
    sm: 4,
    md: 8,
    lg: 16,
    xl: 24
  };

  var QSeparator = createComponent({
    name: 'QSeparator',

    props: {
      ...useDarkProps,

      spaced: [ Boolean, String ],
      inset: [ Boolean, String ],
      vertical: Boolean,
      color: String,
      size: String
    },

    setup (props) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const orientation = vue.computed(() => (
        props.vertical === true
          ? 'vertical'
          : 'horizontal'
      ));

      const orientClass = vue.computed(() => ` q-separator--${ orientation.value }`);

      const insetClass = vue.computed(() => (
        props.inset !== false
          ? `${ orientClass.value }-${ insetMap[ props.inset ] }`
          : ''
      ));

      const classes = vue.computed(() =>
        `q-separator${ orientClass.value }${ insetClass.value }`
        + (props.color !== void 0 ? ` bg-${ props.color }` : '')
        + (isDark.value === true ? ' q-separator--dark' : '')
      );

      const style = vue.computed(() => {
        const acc = {};

        if (props.size !== void 0) {
          acc[ props.vertical === true ? 'width' : 'height' ] = props.size;
        }

        if (props.spaced !== false) {
          const size = props.spaced === true
            ? `${ margins.md }px`
            : props.spaced in margins ? `${ margins[ props.spaced ] }px` : props.spaced;

          const dir = props.vertical === true
            ? [ 'Left', 'Right' ]
            : [ 'Top', 'Bottom' ];

          acc[ `margin${ dir[ 0 ] }` ] = acc[ `margin${ dir[ 1 ] }` ] = size;
        }

        return acc
      });

      return () => vue.h('hr', {
        class: classes.value,
        style: style.value,
        'aria-orientation': orientation.value
      })
    }
  });

  const itemGroups = vue.shallowReactive({});
  const LINK_PROPS = Object.keys(useRouterLinkProps);

  var QExpansionItem = createComponent({
    name: 'QExpansionItem',

    props: {
      ...useRouterLinkProps,
      ...useModelToggleProps,
      ...useDarkProps,

      icon: String,

      label: String,
      labelLines: [ Number, String ],

      caption: String,
      captionLines: [ Number, String ],

      dense: Boolean,

      toggleAriaLabel: String,
      expandIcon: String,
      expandedIcon: String,
      expandIconClass: [ Array, String, Object ],
      duration: Number,

      headerInsetLevel: Number,
      contentInsetLevel: Number,

      expandSeparator: Boolean,
      defaultOpened: Boolean,
      hideExpandIcon: Boolean,
      expandIconToggle: Boolean,
      switchToggleSide: Boolean,
      denseToggle: Boolean,
      group: String,
      popup: Boolean,

      headerStyle: [ Array, String, Object ],
      headerClass: [ Array, String, Object ]
    },

    emits: [
      ...useModelToggleEmits,
      'click', 'afterShow', 'afterHide'
    ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const isDark = useDark(props, $q);

      const showing = vue.ref(
        props.modelValue !== null
          ? props.modelValue
          : props.defaultOpened
      );

      const blurTargetRef = vue.ref(null);
      const targetUid = uid$3();

      const { show, hide, toggle } = useModelToggle({ showing });

      let uniqueId, exitGroup;

      const classes = vue.computed(() =>
        'q-expansion-item q-item-type'
        + ` q-expansion-item--${ showing.value === true ? 'expanded' : 'collapsed' }`
        + ` q-expansion-item--${ props.popup === true ? 'popup' : 'standard' }`
      );

      const contentStyle = vue.computed(() => {
        if (props.contentInsetLevel === void 0) {
          return null
        }

        const dir = $q.lang.rtl === true ? 'Right' : 'Left';
        return {
          [ 'padding' + dir ]: (props.contentInsetLevel * 56) + 'px'
        }
      });

      const hasLink = vue.computed(() =>
        props.disable !== true && (
          props.href !== void 0
          || (props.to !== void 0 && props.to !== null && props.to !== '')
        )
      );

      const linkProps = vue.computed(() => {
        const acc = {};
        LINK_PROPS.forEach(key => {
          acc[ key ] = props[ key ];
        });
        return acc
      });

      const isClickable = vue.computed(() =>
        hasLink.value === true || props.expandIconToggle !== true
      );

      const expansionIcon = vue.computed(() => (
        props.expandedIcon !== void 0 && showing.value === true
          ? props.expandedIcon
          : props.expandIcon || $q.iconSet.expansionItem[ props.denseToggle === true ? 'denseIcon' : 'icon' ]
      ));

      const activeToggleIcon = vue.computed(() =>
        props.disable !== true && (hasLink.value === true || props.expandIconToggle === true)
      );

      const headerSlotScope = vue.computed(() => ({
        expanded: showing.value === true,
        detailsId: props.targetUid,
        toggle,
        show,
        hide
      }));

      const toggleAriaAttrs = vue.computed(() => {
        const toggleAriaLabel = props.toggleAriaLabel !== void 0
          ? props.toggleAriaLabel
          : $q.lang.label[ showing.value === true ? 'collapse' : 'expand' ](props.label);

        return {
          role: 'button',
          'aria-expanded': showing.value === true ? 'true' : 'false',
          'aria-controls': targetUid,
          'aria-label': toggleAriaLabel
        }
      });

      vue.watch(() => props.group, name => {
        exitGroup !== void 0 && exitGroup();
        name !== void 0 && enterGroup();
      });

      function onHeaderClick (e) {
        hasLink.value !== true && toggle(e);
        emit('click', e);
      }

      function toggleIconKeyboard (e) {
        e.keyCode === 13 && toggleIcon(e, true);
      }

      function toggleIcon (e, keyboard) {
        keyboard !== true && blurTargetRef.value !== null && blurTargetRef.value.focus();
        toggle(e);
        stopAndPrevent(e);
      }

      function onShow () {
        emit('afterShow');
      }

      function onHide () {
        emit('afterHide');
      }

      function enterGroup () {
        if (uniqueId === void 0) {
          uniqueId = uid$3();
        }

        if (showing.value === true) {
          itemGroups[ props.group ] = uniqueId;
        }

        const show = vue.watch(showing, val => {
          if (val === true) {
            itemGroups[ props.group ] = uniqueId;
          }
          else if (itemGroups[ props.group ] === uniqueId) {
            delete itemGroups[ props.group ];
          }
        });

        const group = vue.watch(
          () => itemGroups[ props.group ],
          (val, oldVal) => {
            if (oldVal === uniqueId && val !== void 0 && val !== uniqueId) {
              hide();
            }
          }
        );

        exitGroup = () => {
          show();
          group();

          if (itemGroups[ props.group ] === uniqueId) {
            delete itemGroups[ props.group ];
          }

          exitGroup = void 0;
        };
      }

      function getToggleIcon () {
        const data = {
          class: [
            'q-focusable relative-position cursor-pointer'
              + `${ props.denseToggle === true && props.switchToggleSide === true ? ' items-end' : '' }`,
            props.expandIconClass
          ],
          side: props.switchToggleSide !== true,
          avatar: props.switchToggleSide
        };

        const child = [
          vue.h(QIcon, {
            class: 'q-expansion-item__toggle-icon'
              + (props.expandedIcon === void 0 && showing.value === true
                ? ' q-expansion-item__toggle-icon--rotated'
                : ''),
            name: expansionIcon.value
          })
        ];

        if (activeToggleIcon.value === true) {
          Object.assign(data, {
            tabindex: 0,
            ...toggleAriaAttrs.value,
            onClick: toggleIcon,
            onKeyup: toggleIconKeyboard
          });

          child.unshift(
            vue.h('div', {
              ref: blurTargetRef,
              class: 'q-expansion-item__toggle-focus q-icon q-focus-helper q-focus-helper--rounded',
              tabindex: -1
            })
          );
        }

        return vue.h(QItemSection, data, () => child)
      }

      function getHeaderChild () {
        let child;

        if (slots.header !== void 0) {
          child = [].concat(slots.header(headerSlotScope.value));
        }
        else {
          child = [
            vue.h(QItemSection, () => [
              vue.h(QItemLabel, { lines: props.labelLines }, () => props.label || ''),

              props.caption
                ? vue.h(QItemLabel, { lines: props.captionLines, caption: true }, () => props.caption)
                : null
            ])
          ];

          props.icon && child[ props.switchToggleSide === true ? 'push' : 'unshift' ](
            vue.h(QItemSection, {
              side: props.switchToggleSide === true,
              avatar: props.switchToggleSide !== true
            }, () => vue.h(QIcon, { name: props.icon }))
          );
        }

        if (props.disable !== true && props.hideExpandIcon !== true) {
          child[ props.switchToggleSide === true ? 'unshift' : 'push' ](
            getToggleIcon()
          );
        }

        return child
      }

      function getHeader () {
        const data = {
          ref: 'item',
          style: props.headerStyle,
          class: props.headerClass,
          dark: isDark.value,
          disable: props.disable,
          dense: props.dense,
          insetLevel: props.headerInsetLevel
        };

        if (isClickable.value === true) {
          data.clickable = true;
          data.onClick = onHeaderClick;

          Object.assign(
            data,
            hasLink.value === true ? linkProps.value : toggleAriaAttrs.value
          );
        }

        return vue.h(QItem, data, getHeaderChild)
      }

      function getTransitionChild () {
        return vue.withDirectives(
          vue.h('div', {
            key: 'e-content',
            class: 'q-expansion-item__content relative-position',
            style: contentStyle.value,
            id: targetUid
          }, hSlot(slots.default)),
          [ [
            vue.vShow,
            showing.value
          ] ]
        )
      }

      function getContent () {
        const node = [
          getHeader(),

          vue.h(QSlideTransition, {
            duration: props.duration,
            onShow,
            onHide
          }, getTransitionChild)
        ];

        if (props.expandSeparator === true) {
          node.push(
            vue.h(QSeparator, {
              class: 'q-expansion-item__border q-expansion-item__border--top absolute-top',
              dark: isDark.value
            }),
            vue.h(QSeparator, {
              class: 'q-expansion-item__border q-expansion-item__border--bottom absolute-bottom',
              dark: isDark.value
            })
          );
        }

        return node
      }

      props.group !== void 0 && enterGroup();

      vue.onBeforeUnmount(() => {
        exitGroup !== void 0 && exitGroup();
      });

      return () => vue.h('div', { class: classes.value }, [
        vue.h('div', { class: 'q-expansion-item__container relative-position' }, getContent())
      ])
    }
  });

  const labelPositions = [ 'top', 'right', 'bottom', 'left' ];

  const useFabProps = {
    type: {
      type: String,
      default: 'a'
    },

    outline: Boolean,
    push: Boolean,
    flat: Boolean,
    unelevated: Boolean,

    color: String,
    textColor: String,
    glossy: Boolean,

    square: Boolean,
    padding: String,

    label: {
      type: [ String, Number ],
      default: ''
    },
    labelPosition: {
      type: String,
      default: 'right',
      validator: v => labelPositions.includes(v)
    },
    externalLabel: Boolean,
    hideLabel: {
      type: Boolean
    },
    labelClass: [ Array, String, Object ],
    labelStyle: [ Array, String, Object ],

    disable: Boolean,

    tabindex: [ Number, String ]
  };

  function useFab (props, showing) {
    return {
      formClass: vue.computed(() =>
        `q-fab--form-${ props.square === true ? 'square' : 'rounded' }`
      ),

      stacked: vue.computed(() =>
        props.externalLabel === false
        && [ 'top', 'bottom' ].includes(props.labelPosition)
      ),

      labelProps: vue.computed(() => {
        if (props.externalLabel === true) {
          const hideLabel = props.hideLabel === null
            ? showing.value === false
            : props.hideLabel;

          return {
            action: 'push',
            data: {
              class: [
                props.labelClass,
                'q-fab__label q-tooltip--style q-fab__label--external'
                + ` q-fab__label--external-${ props.labelPosition }`
                + (hideLabel === true ? ' q-fab__label--external-hidden' : '')
              ],
              style: props.labelStyle
            }
          }
        }

        return {
          action: [ 'left', 'top' ].includes(props.labelPosition)
            ? 'unshift'
            : 'push',
          data: {
            class: [
              props.labelClass,
              `q-fab__label q-fab__label--internal q-fab__label--internal-${ props.labelPosition }`
              + (props.hideLabel === true ? ' q-fab__label--internal-hidden' : '')
            ],
            style: props.labelStyle
          }
        }
      })
    }
  }

  const directions = [ 'up', 'right', 'down', 'left' ];
  const alignValues = [ 'left', 'center', 'right' ];

  var QFab = createComponent({
    name: 'QFab',

    props: {
      ...useFabProps,
      ...useModelToggleProps,

      icon: String,
      activeIcon: String,

      hideIcon: Boolean,
      hideLabel: {
        default: null
      },

      direction: {
        type: String,
        default: 'right',
        validator: v => directions.includes(v)
      },

      persistent: Boolean,

      verticalActionsAlign: {
        type: String,
        default: 'center',
        validator: v => alignValues.includes(v)
      }
    },

    emits: useModelToggleEmits,

    setup (props, { slots }) {
      const triggerRef = vue.ref(null);
      const showing = vue.ref(props.modelValue === true);
      const targetUid = uid$3();

      const { proxy: { $q } } = vue.getCurrentInstance();
      const { formClass, labelProps } = useFab(props, showing);

      const hideOnRouteChange = vue.computed(() => props.persistent !== true);

      const { hide, toggle } = useModelToggle({
        showing,
        hideOnRouteChange
      });

      const slotScope = vue.computed(() => ({ opened: showing.value }));

      const classes = vue.computed(() =>
        'q-fab z-fab row inline justify-center'
        + ` q-fab--align-${ props.verticalActionsAlign } ${ formClass.value }`
        + (showing.value === true ? ' q-fab--opened' : ' q-fab--closed')
      );

      const actionClass = vue.computed(() =>
        'q-fab__actions flex no-wrap inline'
        + ` q-fab__actions--${ props.direction }`
        + ` q-fab__actions--${ showing.value === true ? 'opened' : 'closed' }`
      );

      const actionAttrs = vue.computed(() => {
        const attrs = {
          id: targetUid,
          role: 'menu'
        };

        if (showing.value !== true) {
          attrs[ 'aria-hidden' ] = 'true';
        }

        return attrs
      });

      const iconHolderClass = vue.computed(() =>
        'q-fab__icon-holder '
        + ` q-fab__icon-holder--${ showing.value === true ? 'opened' : 'closed' }`
      );

      function getIcon (kebab, camel) {
        const slotFn = slots[ kebab ];
        const classes = `q-fab__${ kebab } absolute-full`;

        return slotFn === void 0
          ? vue.h(QIcon, { class: classes, name: props[ camel ] || $q.iconSet.fab[ camel ] })
          : vue.h('div', { class: classes }, slotFn(slotScope.value))
      }

      function getTriggerContent () {
        const child = [];

        props.hideIcon !== true && child.push(
          vue.h('div', { class: iconHolderClass.value }, [
            getIcon('icon', 'icon'),
            getIcon('active-icon', 'activeIcon')
          ])
        );

        if (props.label !== '' || slots.label !== void 0) {
          child[ labelProps.value.action ](
            vue.h('div', labelProps.value.data, slots.label !== void 0 ? slots.label(slotScope.value) : [ props.label ])
          );
        }

        return hMergeSlot(slots.tooltip, child)
      }

      vue.provide(fabKey, {
        showing,

        onChildClick (evt) {
          hide(evt);

          if (triggerRef.value !== null) {
            triggerRef.value.$el.focus();
          }
        }
      });

      return () => vue.h('div', {
        class: classes.value
      }, [
        vue.h(QBtn, {
          ref: triggerRef,
          class: formClass.value,
          ...props,
          noWrap: true,
          stack: props.stacked,
          align: void 0,
          icon: void 0,
          label: void 0,
          noCaps: true,
          fab: true,
          'aria-expanded': showing.value === true ? 'true' : 'false',
          'aria-haspopup': 'true',
          'aria-controls': targetUid,
          onClick: toggle
        }, getTriggerContent),

        vue.h('div', { class: actionClass.value, ...actionAttrs.value }, hSlot(slots.default))
      ])
    }
  });

  const anchorMap = {
    start: 'self-end',
    center: 'self-center',
    end: 'self-start'
  };

  const anchorValues = Object.keys(anchorMap);

  var QFabAction = createComponent({
    name: 'QFabAction',

    props: {
      ...useFabProps,

      icon: {
        type: String,
        default: ''
      },

      anchor: {
        type: String,
        validator: v => anchorValues.includes(v)
      },

      to: [ String, Object ],
      replace: Boolean
    },

    emits: [ 'click' ],

    setup (props, { slots, emit }) {
      const $fab = vue.inject(fabKey, () => ({
        showing: { value: true },
        onChildClick: noop
      }));

      const { formClass, labelProps } = useFab(props, $fab.showing);

      const classes = vue.computed(() => {
        const align = anchorMap[ props.anchor ];
        return formClass.value + (align !== void 0 ? ` ${ align }` : '')
      });

      const isDisabled = vue.computed(() =>
        props.disable === true
        || $fab.showing.value !== true
      );

      function click (e) {
        $fab.onChildClick(e);
        emit('click', e);
      }

      function getContent () {
        const child = [];

        if (slots.icon !== void 0) {
          child.push(slots.icon());
        }
        else if (props.icon !== '') {
          child.push(
            vue.h(QIcon, { name: props.icon })
          );
        }

        if (props.label !== '' || slots.label !== void 0) {
          child[ labelProps.value.action ](
            vue.h('div', labelProps.value.data, slots.label !== void 0 ? slots.label() : [ props.label ])
          );
        }

        return hMergeSlot(slots.default, child)
      }

      // expose public methods
      const vm = vue.getCurrentInstance();
      Object.assign(vm.proxy, { click });

      return () => vue.h(QBtn, {
        class: classes.value,
        ...props,
        noWrap: true,
        stack: props.stacked,
        icon: void 0,
        label: void 0,
        noCaps: true,
        fabMini: true,
        disable: isDisabled.value,
        onClick: click
      }, getContent)
    }
  });

  function useFormChild ({ validate, resetValidation, requiresQForm }) {
    const $form = vue.inject(formKey, false);

    if ($form !== false) {
      const { props, proxy } = vue.getCurrentInstance();

      // export public method (so it can be used in QForm)
      Object.assign(proxy, { validate, resetValidation });

      vue.watch(() => props.disable, val => {
        if (val === true) {
          typeof resetValidation === 'function' && resetValidation();
          $form.unbindComponent(proxy);
        }
        else {
          $form.bindComponent(proxy);
        }
      });

      vue.onMounted(() => {
        // register to parent QForm
        props.disable !== true && $form.bindComponent(proxy);
      });

      vue.onBeforeUnmount(() => {
        // un-register from parent QForm
        props.disable !== true && $form.unbindComponent(proxy);
      });
    }
    else if (requiresQForm === true) {
      console.error('Parent QForm not found on useFormChild()!');
    }
  }

  const lazyRulesValues = [ true, false, 'ondemand' ];

  const useValidateProps = {
    modelValue: {},

    error: {
      type: Boolean,
      default: null
    },
    errorMessage: String,
    noErrorIcon: Boolean,

    rules: Array,
    reactiveRules: Boolean,
    lazyRules: {
      type: [ Boolean, String ],
      validator: v => lazyRulesValues.includes(v)
    }
  };

  function useValidate (focused, innerLoading) {
    const { props, proxy } = vue.getCurrentInstance();

    const innerError = vue.ref(false);
    const innerErrorMessage = vue.ref(null);
    const isDirtyModel = vue.ref(null);

    useFormChild({ validate, resetValidation });

    let validateIndex = 0, unwatchRules;

    const hasRules = vue.computed(() =>
      props.rules !== void 0
      && props.rules !== null
      && props.rules.length > 0
    );

    const hasActiveRules = vue.computed(() =>
      props.disable !== true
      && hasRules.value === true
    );

    const hasError = vue.computed(() =>
      props.error === true || innerError.value === true
    );

    const errorMessage = vue.computed(() => (
      typeof props.errorMessage === 'string' && props.errorMessage.length > 0
        ? props.errorMessage
        : innerErrorMessage.value
    ));

    vue.watch(() => props.modelValue, () => {
      validateIfNeeded();
    });

    vue.watch(() => props.reactiveRules, val => {
      if (val === true) {
        if (unwatchRules === void 0) {
          unwatchRules = vue.watch(() => props.rules, () => {
            validateIfNeeded(true);
          });
        }
      }
      else if (unwatchRules !== void 0) {
        unwatchRules();
        unwatchRules = void 0;
      }
    }, { immediate: true });

    vue.watch(focused, val => {
      if (val === true) {
        if (isDirtyModel.value === null) {
          isDirtyModel.value = false;
        }
      }
      else if (isDirtyModel.value === false) {
        isDirtyModel.value = true;

        if (
          hasActiveRules.value === true
          && props.lazyRules !== 'onde